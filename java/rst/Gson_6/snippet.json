[
  {
    "name": "null.translateName#38",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
    "snippet": "@Override public String translateName(Field f){\n  return f.getName();\n}",
    "begin_line": 38,
    "end_line": 40,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.translateName#54",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
    "snippet": "@Override public String translateName(Field f){\n  return upperCaseFirstLetter(f.getName());\n}",
    "begin_line": 54,
    "end_line": 56,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.translateName#73",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
    "snippet": "@Override public String translateName(Field f){\n  return upperCaseFirstLetter(separateCamelCase(f.getName(),\" \"));\n}",
    "begin_line": 73,
    "end_line": 75,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.translateName#91",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
    "snippet": "@Override public String translateName(Field f){\n  return separateCamelCase(f.getName(),\"_\").toLowerCase(Locale.ENGLISH);\n}",
    "begin_line": 91,
    "end_line": 93,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.translateName#114",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.translateName(java.lang.reflect.Field)",
    "snippet": "@Override public String translateName(Field f){\n  return separateCamelCase(f.getName(),\"-\").toLowerCase(Locale.ENGLISH);\n}",
    "begin_line": 114,
    "end_line": 116,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.separateCamelCase#123",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.separateCamelCase(java.lang.String, java.lang.String)",
    "snippet": "static String separateCamelCase(String name,String separator){\n  StringBuilder translation\u003dnew StringBuilder();\n  for (int i\u003d0; i \u003c name.length(); i++) {\n    char character\u003dname.charAt(i);\n    if (Character.isUpperCase(character) \u0026\u0026 translation.length() !\u003d 0) {\n      translation.append(separator);\n    }\n    translation.append(character);\n  }\n  return translation.toString();\n}",
    "begin_line": 123,
    "end_line": 133,
    "comment": "/** \n * Converts the field name that uses camel-case define word separation into separate words that are separated by the provided  {@code separatorString}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.upperCaseFirstLetter#138",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.upperCaseFirstLetter(java.lang.String)",
    "snippet": "static String upperCaseFirstLetter(String name){\n  StringBuilder fieldNameBuilder\u003dnew StringBuilder();\n  int index\u003d0;\n  char firstCharacter\u003dname.charAt(index);\n  while (index \u003c name.length() - 1) {\n    if (Character.isLetter(firstCharacter)) {\n      break;\n    }\n    fieldNameBuilder.append(firstCharacter);\n    firstCharacter\u003dname.charAt(++index);\n  }\n  if (index \u003d\u003d name.length()) {\n    return fieldNameBuilder.toString();\n  }\n  if (!Character.isUpperCase(firstCharacter)) {\n    String modifiedTarget\u003dmodifyString(Character.toUpperCase(firstCharacter),name,++index);\n    return fieldNameBuilder.append(modifiedTarget).toString();\n  }\n else {\n    return name;\n  }\n}",
    "begin_line": 138,
    "end_line": 162,
    "comment": "/** \n * Ensures the JSON field names begins with an upper case letter.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.modifyString#164",
    "is_bug": true,
    "src_path": "com/google/gson/FieldNamingPolicy.java",
    "class_name": "com.google.gson.FieldNamingPolicy",
    "signature": "com.google.gson.FieldNamingPolicy.modifyString(char, java.lang.String, int)",
    "snippet": "private static String modifyString(char firstCharacter,String srcString,int indexOfSubstring){\n  return (indexOfSubstring \u003c srcString.length()) ? firstCharacter + srcString.substring(indexOfSubstring) : String.valueOf(firstCharacter);\n}",
    "begin_line": 164,
    "end_line": 168,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.deserialize#137",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.deserialize(com.google.gson.JsonElement, java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eT deserialize(JsonElement json,Type typeOfT) throws JsonParseException {\n  return (T)fromJson(json,typeOfT);\n}",
    "begin_line": 137,
    "end_line": 139,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.serialize#143",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.serialize(java.lang.Object)",
    "snippet": "@Override public JsonElement serialize(Object src){\n  return toJsonTree(src);\n}",
    "begin_line": 143,
    "end_line": 145,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.serialize#146",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.serialize(java.lang.Object, java.lang.reflect.Type)",
    "snippet": "@Override public JsonElement serialize(Object src,Type typeOfSrc){\n  return toJsonTree(src,typeOfSrc);\n}",
    "begin_line": 146,
    "end_line": 148,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.Gson#185",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.Gson()",
    "snippet": "public Gson(){\n  this(Excluder.DEFAULT,FieldNamingPolicy.IDENTITY,Collections.\u003cType,InstanceCreator\u003c?\u003e\u003eemptyMap(),DEFAULT_SERIALIZE_NULLS,DEFAULT_COMPLEX_MAP_KEYS,DEFAULT_JSON_NON_EXECUTABLE,DEFAULT_ESCAPE_HTML,DEFAULT_PRETTY_PRINT,DEFAULT_LENIENT,DEFAULT_SPECIALIZE_FLOAT_VALUES,LongSerializationPolicy.DEFAULT,Collections.\u003cTypeAdapterFactory\u003eemptyList());\n}",
    "begin_line": 185,
    "end_line": 191,
    "comment": "/** \n * Constructs a Gson object with default configuration. The default configuration has the following settings: \u003cul\u003e \u003cli\u003eThe JSON generated by \u003ccode\u003etoJson\u003c/code\u003e methods is in compact representation. This means that all the unneeded white-space is removed. You can change this behavior with {@link GsonBuilder#setPrettyPrinting()}. \u003c/li\u003e \u003cli\u003eThe generated JSON omits all the fields that are null. Note that nulls in arrays are kept as is since an array is an ordered list. Moreover, if a field is not null, but its generated JSON is empty, the field is kept. You can configure Gson to serialize null values by setting  {@link GsonBuilder#serializeNulls()}.\u003c/li\u003e \u003cli\u003eGson provides default serialization and deserialization for Enums,  {@link Map}, {@link java.net.URL},  {@link java.net.URI},  {@link java.util.Locale},  {@link java.util.Date}, {@link java.math.BigDecimal}, and  {@link java.math.BigInteger} classes. If you would preferto change the default representation, you can do so by registering a type adapter through {@link GsonBuilder#registerTypeAdapter(Type,Object)}. \u003c/li\u003e \u003cli\u003eThe default Date format is same as  {@link java.text.DateFormat#DEFAULT}. This format ignores the millisecond portion of the date during serialization. You can change this by invoking  {@link GsonBuilder#setDateFormat(int)} or{@link GsonBuilder#setDateFormat(String)}. \u003c/li\u003e \u003cli\u003eBy default, Gson ignores the  {@link com.google.gson.annotations.Expose} annotation.You can enable Gson to serialize/deserialize only those fields marked with this annotation through  {@link GsonBuilder#excludeFieldsWithoutExposeAnnotation()}. \u003c/li\u003e \u003cli\u003eBy default, Gson ignores the  {@link com.google.gson.annotations.Since} annotation. Youcan enable Gson to use this annotation through  {@link GsonBuilder#setVersion(double)}.\u003c/li\u003e \u003cli\u003eThe default field naming policy for the output Json is same as in Java. So, a Java class field \u003ccode\u003eversionNumber\u003c/code\u003e will be output as \u003ccode\u003e\u0026quot;versionNumber\u0026quot;\u003c/code\u003e in Json. The same rules are applied for mapping incoming Json to the Java classes. You can change this policy through  {@link GsonBuilder#setFieldNamingPolicy(FieldNamingPolicy)}.\u003c/li\u003e \u003cli\u003eBy default, Gson excludes \u003ccode\u003etransient\u003c/code\u003e or \u003ccode\u003estatic\u003c/code\u003e fields from consideration for serialization and deserialization. You can change this behavior through {@link GsonBuilder#excludeFieldsWithModifiers(int...)}.\u003c/li\u003e \u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.Gson#193",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.Gson(com.google.gson.internal.Excluder, com.google.gson.FieldNamingStrategy, java.util.Map\u003cjava.lang.reflect.Type,com.google.gson.InstanceCreator\u003c?\u003e\u003e, boolean, boolean, boolean, boolean, boolean, boolean, boolean, com.google.gson.LongSerializationPolicy, java.util.List\u003ccom.google.gson.TypeAdapterFactory\u003e)",
    "snippet": "Gson(final Excluder excluder,final FieldNamingStrategy fieldNamingPolicy,final Map\u003cType,InstanceCreator\u003c?\u003e\u003e instanceCreators,boolean serializeNulls,boolean complexMapKeySerialization,boolean generateNonExecutableGson,boolean htmlSafe,boolean prettyPrinting,boolean lenient,boolean serializeSpecialFloatingPointValues,LongSerializationPolicy longSerializationPolicy,List\u003cTypeAdapterFactory\u003e typeAdapterFactories){\n  this.constructorConstructor\u003dnew ConstructorConstructor(instanceCreators);\n  this.serializeNulls\u003dserializeNulls;\n  this.generateNonExecutableJson\u003dgenerateNonExecutableGson;\n  this.htmlSafe\u003dhtmlSafe;\n  this.prettyPrinting\u003dprettyPrinting;\n  this.lenient\u003dlenient;\n  List\u003cTypeAdapterFactory\u003e factories\u003dnew ArrayList\u003cTypeAdapterFactory\u003e();\n  factories.add(TypeAdapters.JSON_ELEMENT_FACTORY);\n  factories.add(ObjectTypeAdapter.FACTORY);\n  factories.add(excluder);\n  factories.addAll(typeAdapterFactories);\n  factories.add(TypeAdapters.STRING_FACTORY);\n  factories.add(TypeAdapters.INTEGER_FACTORY);\n  factories.add(TypeAdapters.BOOLEAN_FACTORY);\n  factories.add(TypeAdapters.BYTE_FACTORY);\n  factories.add(TypeAdapters.SHORT_FACTORY);\n  TypeAdapter\u003cNumber\u003e longAdapter\u003dlongAdapter(longSerializationPolicy);\n  factories.add(TypeAdapters.newFactory(long.class,Long.class,longAdapter));\n  factories.add(TypeAdapters.newFactory(double.class,Double.class,doubleAdapter(serializeSpecialFloatingPointValues)));\n  factories.add(TypeAdapters.newFactory(float.class,Float.class,floatAdapter(serializeSpecialFloatingPointValues)));\n  factories.add(TypeAdapters.NUMBER_FACTORY);\n  factories.add(TypeAdapters.ATOMIC_INTEGER_FACTORY);\n  factories.add(TypeAdapters.ATOMIC_BOOLEAN_FACTORY);\n  factories.add(TypeAdapters.newFactory(AtomicLong.class,atomicLongAdapter(longAdapter)));\n  factories.add(TypeAdapters.newFactory(AtomicLongArray.class,atomicLongArrayAdapter(longAdapter)));\n  factories.add(TypeAdapters.ATOMIC_INTEGER_ARRAY_FACTORY);\n  factories.add(TypeAdapters.CHARACTER_FACTORY);\n  factories.add(TypeAdapters.STRING_BUILDER_FACTORY);\n  factories.add(TypeAdapters.STRING_BUFFER_FACTORY);\n  factories.add(TypeAdapters.newFactory(BigDecimal.class,TypeAdapters.BIG_DECIMAL));\n  factories.add(TypeAdapters.newFactory(BigInteger.class,TypeAdapters.BIG_INTEGER));\n  factories.add(TypeAdapters.URL_FACTORY);\n  factories.add(TypeAdapters.URI_FACTORY);\n  factories.add(TypeAdapters.UUID_FACTORY);\n  factories.add(TypeAdapters.CURRENCY_FACTORY);\n  factories.add(TypeAdapters.LOCALE_FACTORY);\n  factories.add(TypeAdapters.INET_ADDRESS_FACTORY);\n  factories.add(TypeAdapters.BIT_SET_FACTORY);\n  factories.add(DateTypeAdapter.FACTORY);\n  factories.add(TypeAdapters.CALENDAR_FACTORY);\n  factories.add(TimeTypeAdapter.FACTORY);\n  factories.add(SqlDateTypeAdapter.FACTORY);\n  factories.add(TypeAdapters.TIMESTAMP_FACTORY);\n  factories.add(ArrayTypeAdapter.FACTORY);\n  factories.add(TypeAdapters.CLASS_FACTORY);\n  factories.add(new CollectionTypeAdapterFactory(constructorConstructor));\n  factories.add(new MapTypeAdapterFactory(constructorConstructor,complexMapKeySerialization));\n  factories.add(new JsonAdapterAnnotationTypeAdapterFactory(constructorConstructor));\n  factories.add(TypeAdapters.ENUM_FACTORY);\n  factories.add(new ReflectiveTypeAdapterFactory(constructorConstructor,fieldNamingPolicy,excluder));\n  this.factories\u003dCollections.unmodifiableList(factories);\n}",
    "begin_line": 193,
    "end_line": 265,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.doubleAdapter#267",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.doubleAdapter(boolean)",
    "snippet": "private TypeAdapter\u003cNumber\u003e doubleAdapter(boolean serializeSpecialFloatingPointValues){\n  if (serializeSpecialFloatingPointValues) {\n    return TypeAdapters.DOUBLE;\n  }\n  return new TypeAdapter\u003cNumber\u003e(){\n    @Override public Double read(    JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextDouble();\n    }\n    @Override public void write(    JsonWriter out,    Number value) throws IOException {\n      if (value \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      double doubleValue\u003dvalue.doubleValue();\n      checkValidFloatingPoint(doubleValue);\n      out.value(value);\n    }\n  }\n;\n}",
    "begin_line": 267,
    "end_line": 289,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.read#272",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Double read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  return in.nextDouble();\n}",
    "begin_line": 272,
    "end_line": 278,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.write#279",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out,Number value) throws IOException {\n  if (value \u003d\u003d null) {\n    out.nullValue();\n    return;\n  }\n  double doubleValue\u003dvalue.doubleValue();\n  checkValidFloatingPoint(doubleValue);\n  out.value(value);\n}",
    "begin_line": 279,
    "end_line": 287,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.floatAdapter#291",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.floatAdapter(boolean)",
    "snippet": "private TypeAdapter\u003cNumber\u003e floatAdapter(boolean serializeSpecialFloatingPointValues){\n  if (serializeSpecialFloatingPointValues) {\n    return TypeAdapters.FLOAT;\n  }\n  return new TypeAdapter\u003cNumber\u003e(){\n    @Override public Float read(    JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return (float)in.nextDouble();\n    }\n    @Override public void write(    JsonWriter out,    Number value) throws IOException {\n      if (value \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      float floatValue\u003dvalue.floatValue();\n      checkValidFloatingPoint(floatValue);\n      out.value(value);\n    }\n  }\n;\n}",
    "begin_line": 291,
    "end_line": 313,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.read#296",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Float read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  return (float)in.nextDouble();\n}",
    "begin_line": 296,
    "end_line": 302,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.write#303",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out,Number value) throws IOException {\n  if (value \u003d\u003d null) {\n    out.nullValue();\n    return;\n  }\n  float floatValue\u003dvalue.floatValue();\n  checkValidFloatingPoint(floatValue);\n  out.value(value);\n}",
    "begin_line": 303,
    "end_line": 311,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.checkValidFloatingPoint#315",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.checkValidFloatingPoint(double)",
    "snippet": "static void checkValidFloatingPoint(double value){\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(value + \" is not a valid double value as per JSON specification. To override this\" + \" behavior, use GsonBuilder.serializeSpecialFloatingPointValues() method.\");\n  }\n}",
    "begin_line": 315,
    "end_line": 321,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.longAdapter#323",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.longAdapter(com.google.gson.LongSerializationPolicy)",
    "snippet": "private static TypeAdapter\u003cNumber\u003e longAdapter(LongSerializationPolicy longSerializationPolicy){\n  if (longSerializationPolicy \u003d\u003d LongSerializationPolicy.DEFAULT) {\n    return TypeAdapters.LONG;\n  }\n  return new TypeAdapter\u003cNumber\u003e(){\n    @Override public Number read(    JsonReader in) throws IOException {\n      if (in.peek() \u003d\u003d JsonToken.NULL) {\n        in.nextNull();\n        return null;\n      }\n      return in.nextLong();\n    }\n    @Override public void write(    JsonWriter out,    Number value) throws IOException {\n      if (value \u003d\u003d null) {\n        out.nullValue();\n        return;\n      }\n      out.value(value.toString());\n    }\n  }\n;\n}",
    "begin_line": 323,
    "end_line": 343,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.read#328",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Number read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  return in.nextLong();\n}",
    "begin_line": 328,
    "end_line": 334,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.write#335",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out,Number value) throws IOException {\n  if (value \u003d\u003d null) {\n    out.nullValue();\n    return;\n  }\n  out.value(value.toString());\n}",
    "begin_line": 335,
    "end_line": 341,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.atomicLongAdapter#345",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.atomicLongAdapter(com.google.gson.TypeAdapter\u003cjava.lang.Number\u003e)",
    "snippet": "private static TypeAdapter\u003cAtomicLong\u003e atomicLongAdapter(final TypeAdapter\u003cNumber\u003e longAdapter){\n  return new TypeAdapter\u003cAtomicLong\u003e(){\n    @Override public void write(    JsonWriter out,    AtomicLong value) throws IOException {\n      longAdapter.write(out,value.get());\n    }\n    @Override public AtomicLong read(    JsonReader in) throws IOException {\n      Number value\u003dlongAdapter.read(in);\n      return new AtomicLong(value.longValue());\n    }\n  }\n.nullSafe();\n}",
    "begin_line": 345,
    "end_line": 355,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.write#347",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicLong)",
    "snippet": "@Override public void write(JsonWriter out,AtomicLong value) throws IOException {\n  longAdapter.write(out,value.get());\n}",
    "begin_line": 347,
    "end_line": 349,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.read#350",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public AtomicLong read(JsonReader in) throws IOException {\n  Number value\u003dlongAdapter.read(in);\n  return new AtomicLong(value.longValue());\n}",
    "begin_line": 350,
    "end_line": 353,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.atomicLongArrayAdapter#357",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.atomicLongArrayAdapter(com.google.gson.TypeAdapter\u003cjava.lang.Number\u003e)",
    "snippet": "private static TypeAdapter\u003cAtomicLongArray\u003e atomicLongArrayAdapter(final TypeAdapter\u003cNumber\u003e longAdapter){\n  return new TypeAdapter\u003cAtomicLongArray\u003e(){\n    @Override public void write(    JsonWriter out,    AtomicLongArray value) throws IOException {\n      out.beginArray();\n      for (int i\u003d0, length\u003dvalue.length(); i \u003c length; i++) {\n        longAdapter.write(out,value.get(i));\n      }\n      out.endArray();\n    }\n    @Override public AtomicLongArray read(    JsonReader in) throws IOException {\n      List\u003cLong\u003e list\u003dnew ArrayList\u003cLong\u003e();\n      in.beginArray();\n      while (in.hasNext()) {\n        long value\u003dlongAdapter.read(in).longValue();\n        list.add(value);\n      }\n      in.endArray();\n      int length\u003dlist.size();\n      AtomicLongArray array\u003dnew AtomicLongArray(length);\n      for (int i\u003d0; i \u003c length; ++i) {\n        array.set(i,list.get(i));\n      }\n      return array;\n    }\n  }\n.nullSafe();\n}",
    "begin_line": 357,
    "end_line": 382,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.write#359",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicLongArray)",
    "snippet": "@Override public void write(JsonWriter out,AtomicLongArray value) throws IOException {\n  out.beginArray();\n  for (int i\u003d0, length\u003dvalue.length(); i \u003c length; i++) {\n    longAdapter.write(out,value.get(i));\n  }\n  out.endArray();\n}",
    "begin_line": 359,
    "end_line": 365,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.read#366",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public AtomicLongArray read(JsonReader in) throws IOException {\n  List\u003cLong\u003e list\u003dnew ArrayList\u003cLong\u003e();\n  in.beginArray();\n  while (in.hasNext()) {\n    long value\u003dlongAdapter.read(in).longValue();\n    list.add(value);\n  }\n  in.endArray();\n  int length\u003dlist.size();\n  AtomicLongArray array\u003dnew AtomicLongArray(length);\n  for (int i\u003d0; i \u003c length; ++i) {\n    array.set(i,list.get(i));\n  }\n  return array;\n}",
    "begin_line": 366,
    "end_line": 380,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.getAdapter#391",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.getAdapter(com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") public \u003cT\u003eTypeAdapter\u003cT\u003e getAdapter(TypeToken\u003cT\u003e type){\n  TypeAdapter\u003c?\u003e cached\u003dtypeTokenCache.get(type);\n  if (cached !\u003d null) {\n    return (TypeAdapter\u003cT\u003e)cached;\n  }\n  Map\u003cTypeToken\u003c?\u003e,FutureTypeAdapter\u003c?\u003e\u003e threadCalls\u003dcalls.get();\n  boolean requiresThreadLocalCleanup\u003dfalse;\n  if (threadCalls \u003d\u003d null) {\n    threadCalls\u003dnew HashMap\u003cTypeToken\u003c?\u003e,FutureTypeAdapter\u003c?\u003e\u003e();\n    calls.set(threadCalls);\n    requiresThreadLocalCleanup\u003dtrue;\n  }\n  FutureTypeAdapter\u003cT\u003e ongoingCall\u003d(FutureTypeAdapter\u003cT\u003e)threadCalls.get(type);\n  if (ongoingCall !\u003d null) {\n    return ongoingCall;\n  }\n  try {\n    FutureTypeAdapter\u003cT\u003e call\u003dnew FutureTypeAdapter\u003cT\u003e();\n    threadCalls.put(type,call);\n    for (    TypeAdapterFactory factory : factories) {\n      TypeAdapter\u003cT\u003e candidate\u003dfactory.create(this,type);\n      if (candidate !\u003d null) {\n        call.setDelegate(candidate);\n        typeTokenCache.put(type,candidate);\n        return candidate;\n      }\n    }\n    throw new IllegalArgumentException(\"GSON cannot handle \" + type);\n  }\n  finally {\n    threadCalls.remove(type);\n    if (requiresThreadLocalCleanup) {\n      calls.remove();\n    }\n  }\n}",
    "begin_line": 391,
    "end_line": 431,
    "comment": "/** \n * Returns the type adapter for  {@code} type.\n * @throws IllegalArgumentException if this GSON cannot serialize anddeserialize  {@code type}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.getDelegateAdapter#483",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.getDelegateAdapter(com.google.gson.TypeAdapterFactory, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "public \u003cT\u003eTypeAdapter\u003cT\u003e getDelegateAdapter(TypeAdapterFactory skipPast,TypeToken\u003cT\u003e type){\n  boolean skipPastFound\u003dfalse;\n  if (!factories.contains(skipPast))   skipPastFound\u003dtrue;\n  for (  TypeAdapterFactory factory : factories) {\n    if (!skipPastFound) {\n      if (factory \u003d\u003d skipPast) {\n        skipPastFound\u003dtrue;\n      }\n      continue;\n    }\n    TypeAdapter\u003cT\u003e candidate\u003dfactory.create(this,type);\n    if (candidate !\u003d null) {\n      return candidate;\n    }\n  }\n  throw new IllegalArgumentException(\"GSON cannot serialize \" + type);\n}",
    "begin_line": 483,
    "end_line": 504,
    "comment": "/** \n * This method is used to get an alternate type adapter for the specified type. This is used to access a type adapter that is overridden by a  {@link TypeAdapterFactory} that youmay have registered. This features is typically used when you want to register a type adapter that does a little bit of work but then delegates further processing to the Gson default type adapter. Here is an example: \u003cp\u003eLet\u0027s say we want to write a type adapter that counts the number of objects being read from or written to JSON. We can achieve this by writing a type adapter factory that uses the \u003ccode\u003egetDelegateAdapter\u003c/code\u003e method: \u003cpre\u003e  {@code class StatsTypeAdapterFactory implements TypeAdapterFactory  public int numReads \u003d 0; public int numWrites \u003d 0; public \u0026lt;T\u0026gt; TypeAdapter\u0026lt;T\u0026gt; create(Gson gson, TypeToken\u0026lt;T\u0026gt; type)  final TypeAdapter\u0026lt;T\u0026gt; delegate \u003d gson.getDelegateAdapter(this, type); return new TypeAdapter\u0026lt;T\u0026gt;()  public void write(JsonWriter out, T value) throws IOException  ++numWrites; delegate.write(out, value);}public T read(JsonReader in) throws IOException  ++numReads; return delegate.read(in); } }; } } } \u003c/pre\u003e This factory can now be used like this: \u003cpre\u003e  {@code StatsTypeAdapterFactory stats \u003d new StatsTypeAdapterFactory(); Gson gson \u003d new GsonBuilder().registerTypeAdapterFactory(stats).create(); // Call gson.toJson() and fromJson methods on objects System.out.println(\"Num JSON reads\" + stats.numReads); System.out.println(\"Num JSON writes\" + stats.numWrites);}\u003c/pre\u003e Note that this call will skip all factories registered before  {@code skipPast}. In case of multiple TypeAdapterFactories registered it is up to the caller of this function to insure that the order of registration does not prevent this method from reaching a factory they would expect to reply from this call. Note that since you can not override type adapter factories for String and Java primitive types, our stats factory will not count the number of String or primitives that will be read or written.\n * @param skipPast The type adapter factory that needs to be skipped while searching fora matching type adapter. In most cases, you should just pass \u003ci\u003ethis\u003c/i\u003e (the type adapter factory from where  {@link #getDelegateAdapter} method is being invoked).\n * @param type Type for which the delegate adapter is being searched for.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.getAdapter#512",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.getAdapter(java.lang.Class\u003cT\u003e)",
    "snippet": "public \u003cT\u003eTypeAdapter\u003cT\u003e getAdapter(Class\u003cT\u003e type){\n  return getAdapter(TypeToken.get(type));\n}",
    "begin_line": 512,
    "end_line": 514,
    "comment": "/** \n * Returns the type adapter for  {@code} type.\n * @throws IllegalArgumentException if this GSON cannot serialize anddeserialize  {@code type}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJsonTree#529",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJsonTree(java.lang.Object)",
    "snippet": "public JsonElement toJsonTree(Object src){\n  if (src \u003d\u003d null) {\n    return JsonNull.INSTANCE;\n  }\n  return toJsonTree(src,src.getClass());\n}",
    "begin_line": 529,
    "end_line": 534,
    "comment": "/** \n * This method serializes the specified object into its equivalent representation as a tree of {@link JsonElement}s. This method should be used when the specified object is not a generic type. This method uses  {@link Class#getClass()} to get the type for the specified object, butthe  {@code getClass()} loses the generic type information because of the Type Erasure featureof Java. Note that this method works fine if the any of the object fields are of generic type, just the object itself should not be of a generic type. If the object is of generic type, use {@link #toJsonTree(Object,Type)} instead.\n * @param src the object for which Json representation is to be created setting for Gson\n * @return Json representation of {@code src}.\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJsonTree#552",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJsonTree(java.lang.Object, java.lang.reflect.Type)",
    "snippet": "public JsonElement toJsonTree(Object src,Type typeOfSrc){\n  JsonTreeWriter writer\u003dnew JsonTreeWriter();\n  toJson(src,typeOfSrc,writer);\n  return writer.get();\n}",
    "begin_line": 552,
    "end_line": 556,
    "comment": "/** \n * This method serializes the specified object, including those of generic types, into its equivalent representation as a tree of  {@link JsonElement}s. This method must be used if the specified object is a generic type. For non-generic objects, use  {@link #toJsonTree(Object)}instead.\n * @param src the object for which JSON representation is to be created\n * @param typeOfSrc The specific genericized type of src. You can obtainthis type by using the  {@link com.google.gson.reflect.TypeToken} class. For example,to get the type for  {@code Collection\u003cFoo\u003e}, you should use: \u003cpre\u003e Type typeOfSrc \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType(); \u003c/pre\u003e\n * @return Json representation of {@code src}\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#571",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(java.lang.Object)",
    "snippet": "public String toJson(Object src){\n  if (src \u003d\u003d null) {\n    return toJson(JsonNull.INSTANCE);\n  }\n  return toJson(src,src.getClass());\n}",
    "begin_line": 571,
    "end_line": 576,
    "comment": "/** \n * This method serializes the specified object into its equivalent Json representation. This method should be used when the specified object is not a generic type. This method uses {@link Class#getClass()} to get the type for the specified object, but the{@code getClass()} loses the generic type information because of the Type Erasure featureof Java. Note that this method works fine if the any of the object fields are of generic type, just the object itself should not be of a generic type. If the object is of generic type, use {@link #toJson(Object,Type)} instead. If you want to write out the object to a{@link Writer}, use  {@link #toJson(Object,Appendable)} instead.\n * @param src the object for which Json representation is to be created setting for Gson\n * @return Json representation of {@code src}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#593",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(java.lang.Object, java.lang.reflect.Type)",
    "snippet": "public String toJson(Object src,Type typeOfSrc){\n  StringWriter writer\u003dnew StringWriter();\n  toJson(src,typeOfSrc,writer);\n  return writer.toString();\n}",
    "begin_line": 593,
    "end_line": 597,
    "comment": "/** \n * This method serializes the specified object, including those of generic types, into its equivalent Json representation. This method must be used if the specified object is a generic type. For non-generic objects, use  {@link #toJson(Object)} instead. If you want to write outthe object to a  {@link Appendable}, use  {@link #toJson(Object,Type,Appendable)} instead.\n * @param src the object for which JSON representation is to be created\n * @param typeOfSrc The specific genericized type of src. You can obtainthis type by using the  {@link com.google.gson.reflect.TypeToken} class. For example,to get the type for  {@code Collection\u003cFoo\u003e}, you should use: \u003cpre\u003e Type typeOfSrc \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType(); \u003c/pre\u003e\n * @return Json representation of {@code src}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#613",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(java.lang.Object, java.lang.Appendable)",
    "snippet": "public void toJson(Object src,Appendable writer) throws JsonIOException {\n  if (src !\u003d null) {\n    toJson(src,src.getClass(),writer);\n  }\n else {\n    toJson(JsonNull.INSTANCE,writer);\n  }\n}",
    "begin_line": 613,
    "end_line": 619,
    "comment": "/** \n * This method serializes the specified object into its equivalent Json representation. This method should be used when the specified object is not a generic type. This method uses {@link Class#getClass()} to get the type for the specified object, but the{@code getClass()} loses the generic type information because of the Type Erasure featureof Java. Note that this method works fine if the any of the object fields are of generic type, just the object itself should not be of a generic type. If the object is of generic type, use {@link #toJson(Object,Type,Appendable)} instead.\n * @param src the object for which Json representation is to be created setting for Gson\n * @param writer Writer to which the Json representation needs to be written\n * @throws JsonIOException if there was a problem writing to the writer\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#637",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(java.lang.Object, java.lang.reflect.Type, java.lang.Appendable)",
    "snippet": "public void toJson(Object src,Type typeOfSrc,Appendable writer) throws JsonIOException {\n  try {\n    JsonWriter jsonWriter\u003dnewJsonWriter(Streams.writerForAppendable(writer));\n    toJson(src,typeOfSrc,jsonWriter);\n  }\n catch (  IOException e) {\n    throw new JsonIOException(e);\n  }\n}",
    "begin_line": 637,
    "end_line": 644,
    "comment": "/** \n * This method serializes the specified object, including those of generic types, into its equivalent Json representation. This method must be used if the specified object is a generic type. For non-generic objects, use  {@link #toJson(Object,Appendable)} instead.\n * @param src the object for which JSON representation is to be created\n * @param typeOfSrc The specific genericized type of src. You can obtainthis type by using the  {@link com.google.gson.reflect.TypeToken} class. For example,to get the type for  {@code Collection\u003cFoo\u003e}, you should use: \u003cpre\u003e Type typeOfSrc \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType(); \u003c/pre\u003e\n * @param writer Writer to which the Json representation of src needs to be written.\n * @throws JsonIOException if there was a problem writing to the writer\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#652",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(java.lang.Object, java.lang.reflect.Type, com.google.gson.stream.JsonWriter)",
    "snippet": "@SuppressWarnings(\"unchecked\") public void toJson(Object src,Type typeOfSrc,JsonWriter writer) throws JsonIOException {\n  TypeAdapter\u003c?\u003e adapter\u003dgetAdapter(TypeToken.get(typeOfSrc));\n  boolean oldLenient\u003dwriter.isLenient();\n  writer.setLenient(true);\n  boolean oldHtmlSafe\u003dwriter.isHtmlSafe();\n  writer.setHtmlSafe(htmlSafe);\n  boolean oldSerializeNulls\u003dwriter.getSerializeNulls();\n  writer.setSerializeNulls(serializeNulls);\n  try {\n    ((TypeAdapter\u003cObject\u003e)adapter).write(writer,src);\n  }\n catch (  IOException e) {\n    throw new JsonIOException(e);\n  }\n finally {\n    writer.setLenient(oldLenient);\n    writer.setHtmlSafe(oldHtmlSafe);\n    writer.setSerializeNulls(oldSerializeNulls);\n  }\n}",
    "begin_line": 652,
    "end_line": 669,
    "comment": "/** \n * Writes the JSON representation of  {@code src} of type {@code typeOfSrc} to{@code writer}.\n * @throws JsonIOException if there was a problem writing to the writer\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#678",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(com.google.gson.JsonElement)",
    "snippet": "public String toJson(JsonElement jsonElement){\n  StringWriter writer\u003dnew StringWriter();\n  toJson(jsonElement,writer);\n  return writer.toString();\n}",
    "begin_line": 678,
    "end_line": 682,
    "comment": "/** \n * Converts a tree of  {@link JsonElement}s into its equivalent JSON representation.\n * @param jsonElement root of a tree of {@link JsonElement}s\n * @return JSON String representation of the tree\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#692",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(com.google.gson.JsonElement, java.lang.Appendable)",
    "snippet": "public void toJson(JsonElement jsonElement,Appendable writer) throws JsonIOException {\n  try {\n    JsonWriter jsonWriter\u003dnewJsonWriter(Streams.writerForAppendable(writer));\n    toJson(jsonElement,jsonWriter);\n  }\n catch (  IOException e) {\n    throw new RuntimeException(e);\n  }\n}",
    "begin_line": 692,
    "end_line": 699,
    "comment": "/** \n * Writes out the equivalent JSON for a tree of  {@link JsonElement}s.\n * @param jsonElement root of a tree of {@link JsonElement}s\n * @param writer Writer to which the Json representation needs to be written\n * @throws JsonIOException if there was a problem writing to the writer\n * @since 1.4\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.newJsonWriter#704",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.newJsonWriter(java.io.Writer)",
    "snippet": "public JsonWriter newJsonWriter(Writer writer) throws IOException {\n  if (generateNonExecutableJson) {\n    writer.write(JSON_NON_EXECUTABLE_PREFIX);\n  }\n  JsonWriter jsonWriter\u003dnew JsonWriter(writer);\n  if (prettyPrinting) {\n    jsonWriter.setIndent(\"  \");\n  }\n  jsonWriter.setSerializeNulls(serializeNulls);\n  return jsonWriter;\n}",
    "begin_line": 704,
    "end_line": 714,
    "comment": "/** \n * Returns a new JSON writer configured for the settings on this Gson instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.newJsonReader#719",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.newJsonReader(java.io.Reader)",
    "snippet": "public JsonReader newJsonReader(Reader reader){\n  JsonReader jsonReader\u003dnew JsonReader(reader);\n  jsonReader.setLenient(lenient);\n  return jsonReader;\n}",
    "begin_line": 719,
    "end_line": 723,
    "comment": "/** \n * Returns a new JSON writer configured for the settings on this Gson instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.toJson#729",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toJson(com.google.gson.JsonElement, com.google.gson.stream.JsonWriter)",
    "snippet": "public void toJson(JsonElement jsonElement,JsonWriter writer) throws JsonIOException {\n  boolean oldLenient\u003dwriter.isLenient();\n  writer.setLenient(true);\n  boolean oldHtmlSafe\u003dwriter.isHtmlSafe();\n  writer.setHtmlSafe(htmlSafe);\n  boolean oldSerializeNulls\u003dwriter.getSerializeNulls();\n  writer.setSerializeNulls(serializeNulls);\n  try {\n    Streams.write(jsonElement,writer);\n  }\n catch (  IOException e) {\n    throw new JsonIOException(e);\n  }\n finally {\n    writer.setLenient(oldLenient);\n    writer.setHtmlSafe(oldHtmlSafe);\n    writer.setSerializeNulls(oldSerializeNulls);\n  }\n}",
    "begin_line": 729,
    "end_line": 745,
    "comment": "/** \n * Writes the JSON for  {@code jsonElement} to {@code writer}.\n * @throws JsonIOException if there was a problem writing to the writer\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#764",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(java.lang.String, java.lang.Class\u003cT\u003e)",
    "snippet": "public \u003cT\u003eT fromJson(String json,Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n  Object object\u003dfromJson(json,(Type)classOfT);\n  return Primitives.wrap(classOfT).cast(object);\n}",
    "begin_line": 764,
    "end_line": 767,
    "comment": "/** \n * This method deserializes the specified Json into an object of the specified class. It is not suitable to use if the specified class is a generic type since it will not have the generic type information because of the Type Erasure feature of Java. Therefore, this method should not be used if the desired type is a generic type. Note that this method works fine if the any of the fields of the specified object are generics, just the object itself should not be a generic type. For the cases when the object is of generic type, invoke {@link #fromJson(String,Type)}. If you have the Json in a  {@link Reader} instead ofa String, use  {@link #fromJson(Reader,Class)} instead.\n * @param \u003c T \u003e the type of the desired object\n * @param json the string from which the object is to be deserialized\n * @param classOfT the class of T\n * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.\n * @throws JsonSyntaxException if json is not a valid representation for an object of typeclassOfT\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#788",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(java.lang.String, java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings(\"unchecked\") public \u003cT\u003eT fromJson(String json,Type typeOfT) throws JsonSyntaxException {\n  if (json \u003d\u003d null) {\n    return null;\n  }\n  StringReader reader\u003dnew StringReader(json);\n  T target\u003d(T)fromJson(reader,typeOfT);\n  return target;\n}",
    "begin_line": 788,
    "end_line": 795,
    "comment": "/** \n * This method deserializes the specified Json into an object of the specified type. This method is useful if the specified object is a generic type. For non-generic objects, use {@link #fromJson(String,Class)} instead. If you have the Json in a {@link Reader} instead ofa String, use  {@link #fromJson(Reader,Type)} instead.\n * @param \u003c T \u003e the type of the desired object\n * @param json the string from which the object is to be deserialized\n * @param typeOfT The specific genericized type of src. You can obtain this type by using the{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for{@code Collection\u003cFoo\u003e}, you should use: \u003cpre\u003e Type typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType(); \u003c/pre\u003e\n * @return an object of type T from the string. Returns {@code null} if {@code json} is {@code null}.\n * @throws JsonParseException if json is not a valid representation for an object of type typeOfT\n * @throws JsonSyntaxException if json is not a valid representation for an object of type\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#815",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(java.io.Reader, java.lang.Class\u003cT\u003e)",
    "snippet": "public \u003cT\u003eT fromJson(Reader json,Class\u003cT\u003e classOfT) throws JsonSyntaxException, JsonIOException {\n  JsonReader jsonReader\u003dnewJsonReader(json);\n  Object object\u003dfromJson(jsonReader,classOfT);\n  assertFullConsumption(object,jsonReader);\n  return Primitives.wrap(classOfT).cast(object);\n}",
    "begin_line": 815,
    "end_line": 820,
    "comment": "/** \n * This method deserializes the Json read from the specified reader into an object of the specified class. It is not suitable to use if the specified class is a generic type since it will not have the generic type information because of the Type Erasure feature of Java. Therefore, this method should not be used if the desired type is a generic type. Note that this method works fine if the any of the fields of the specified object are generics, just the object itself should not be a generic type. For the cases when the object is of generic type, invoke  {@link #fromJson(Reader,Type)}. If you have the Json in a String form instead of a {@link Reader}, use  {@link #fromJson(String,Class)} instead.\n * @param \u003c T \u003e the type of the desired object\n * @param json the reader producing the Json from which the object is to be deserialized.\n * @param classOfT the class of T\n * @return an object of type T from the string. Returns {@code null} if {@code json} is at EOF.\n * @throws JsonIOException if there was a problem reading from the Reader\n * @throws JsonSyntaxException if json is not a valid representation for an object of type\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#842",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(java.io.Reader, java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings(\"unchecked\") public \u003cT\u003eT fromJson(Reader json,Type typeOfT) throws JsonIOException, JsonSyntaxException {\n  JsonReader jsonReader\u003dnewJsonReader(json);\n  T object\u003d(T)fromJson(jsonReader,typeOfT);\n  assertFullConsumption(object,jsonReader);\n  return object;\n}",
    "begin_line": 842,
    "end_line": 847,
    "comment": "/** \n * This method deserializes the Json read from the specified reader into an object of the specified type. This method is useful if the specified object is a generic type. For non-generic objects, use  {@link #fromJson(Reader,Class)} instead. If you have the Json in aString form instead of a  {@link Reader}, use  {@link #fromJson(String,Type)} instead.\n * @param \u003c T \u003e the type of the desired object\n * @param json the reader producing Json from which the object is to be deserialized\n * @param typeOfT The specific genericized type of src. You can obtain this type by using the{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for{@code Collection\u003cFoo\u003e}, you should use: \u003cpre\u003e Type typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType(); \u003c/pre\u003e\n * @return an object of type T from the json. Returns {@code null} if {@code json} is at EOF.\n * @throws JsonIOException if there was a problem reading from the Reader\n * @throws JsonSyntaxException if json is not a valid representation for an object of type\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.assertFullConsumption#849",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.assertFullConsumption(java.lang.Object, com.google.gson.stream.JsonReader)",
    "snippet": "private static void assertFullConsumption(Object obj,JsonReader reader){\n  try {\n    if (obj !\u003d null \u0026\u0026 reader.peek() !\u003d JsonToken.END_DOCUMENT) {\n      throw new JsonIOException(\"JSON document was not fully consumed.\");\n    }\n  }\n catch (  MalformedJsonException e) {\n    throw new JsonSyntaxException(e);\n  }\ncatch (  IOException e) {\n    throw new JsonIOException(e);\n  }\n}",
    "begin_line": 849,
    "end_line": 859,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#870",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(com.google.gson.stream.JsonReader, java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings(\"unchecked\") public \u003cT\u003eT fromJson(JsonReader reader,Type typeOfT) throws JsonIOException, JsonSyntaxException {\n  boolean isEmpty\u003dtrue;\n  boolean oldLenient\u003dreader.isLenient();\n  reader.setLenient(true);\n  try {\n    reader.peek();\n    isEmpty\u003dfalse;\n    TypeToken\u003cT\u003e typeToken\u003d(TypeToken\u003cT\u003e)TypeToken.get(typeOfT);\n    TypeAdapter\u003cT\u003e typeAdapter\u003dgetAdapter(typeToken);\n    T object\u003dtypeAdapter.read(reader);\n    return object;\n  }\n catch (  EOFException e) {\n    if (isEmpty) {\n      return null;\n    }\n    throw new JsonSyntaxException(e);\n  }\ncatch (  IllegalStateException e) {\n    throw new JsonSyntaxException(e);\n  }\ncatch (  IOException e) {\n    throw new JsonSyntaxException(e);\n  }\n finally {\n    reader.setLenient(oldLenient);\n  }\n}",
    "begin_line": 870,
    "end_line": 898,
    "comment": "/** \n * Reads the next JSON value from  {@code reader} and convert it to an objectof type  {@code typeOfT}. Returns  {@code null}, if the  {@code reader} is at EOF.Since Type is not parameterized by T, this method is type unsafe and should be used carefully\n * @throws JsonIOException if there was a problem writing to the Reader\n * @throws JsonSyntaxException if json is not a valid representation for an object of type\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#916",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(com.google.gson.JsonElement, java.lang.Class\u003cT\u003e)",
    "snippet": "public \u003cT\u003eT fromJson(JsonElement json,Class\u003cT\u003e classOfT) throws JsonSyntaxException {\n  Object object\u003dfromJson(json,(Type)classOfT);\n  return Primitives.wrap(classOfT).cast(object);\n}",
    "begin_line": 916,
    "end_line": 919,
    "comment": "/** \n * This method deserializes the Json read from the specified parse tree into an object of the specified type. It is not suitable to use if the specified class is a generic type since it will not have the generic type information because of the Type Erasure feature of Java. Therefore, this method should not be used if the desired type is a generic type. Note that this method works fine if the any of the fields of the specified object are generics, just the object itself should not be a generic type. For the cases when the object is of generic type, invoke  {@link #fromJson(JsonElement,Type)}.\n * @param \u003c T \u003e the type of the desired object\n * @param json the root of the parse tree of {@link JsonElement}s from which the object is to be deserialized\n * @param classOfT The class of T\n * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.\n * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Gson.fromJson#940",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.fromJson(com.google.gson.JsonElement, java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings(\"unchecked\") public \u003cT\u003eT fromJson(JsonElement json,Type typeOfT) throws JsonSyntaxException {\n  if (json \u003d\u003d null) {\n    return null;\n  }\n  return (T)fromJson(new JsonTreeReader(json),typeOfT);\n}",
    "begin_line": 940,
    "end_line": 945,
    "comment": "/** \n * This method deserializes the Json read from the specified parse tree into an object of the specified type. This method is useful if the specified object is a generic type. For non-generic objects, use  {@link #fromJson(JsonElement,Class)} instead.\n * @param \u003c T \u003e the type of the desired object\n * @param json the root of the parse tree of {@link JsonElement}s from which the object is to be deserialized\n * @param typeOfT The specific genericized type of src. You can obtain this type by using the{@link com.google.gson.reflect.TypeToken} class. For example, to get the type for{@code Collection\u003cFoo\u003e}, you should use: \u003cpre\u003e Type typeOfT \u003d new TypeToken\u0026lt;Collection\u0026lt;Foo\u0026gt;\u0026gt;(){}.getType(); \u003c/pre\u003e\n * @return an object of type T from the json. Returns {@code null} if {@code json} is {@code null}.\n * @throws JsonSyntaxException if json is not a valid representation for an object of type typeOfT\n * @since 1.3\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FutureTypeAdapter.setDelegate#950",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.setDelegate(com.google.gson.TypeAdapter\u003cT\u003e)",
    "snippet": "public void setDelegate(TypeAdapter\u003cT\u003e typeAdapter){\n  if (delegate !\u003d null) {\n    throw new AssertionError();\n  }\n  delegate\u003dtypeAdapter;\n}",
    "begin_line": 950,
    "end_line": 955,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FutureTypeAdapter.read#957",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public T read(JsonReader in) throws IOException {\n  if (delegate \u003d\u003d null) {\n    throw new IllegalStateException();\n  }\n  return delegate.read(in);\n}",
    "begin_line": 957,
    "end_line": 962,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FutureTypeAdapter.write#964",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.write(com.google.gson.stream.JsonWriter, T)",
    "snippet": "@Override public void write(JsonWriter out,T value) throws IOException {\n  if (delegate \u003d\u003d null) {\n    throw new IllegalStateException();\n  }\n  delegate.write(out,value);\n}",
    "begin_line": 964,
    "end_line": 969,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FutureTypeAdapter.toString#973",
    "is_bug": true,
    "src_path": "com/google/gson/Gson.java",
    "class_name": "com.google.gson.Gson",
    "signature": "com.google.gson.Gson.toString()",
    "snippet": "@Override public String toString(){\n  return new StringBuilder(\"{serializeNulls:\").append(serializeNulls).append(\"factories:\").append(factories).append(\",instanceCreators:\").append(constructorConstructor).append(\"}\").toString();\n}",
    "begin_line": 973,
    "end_line": 980,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.serialize#35",
    "is_bug": true,
    "src_path": "com/google/gson/LongSerializationPolicy.java",
    "class_name": "com.google.gson.LongSerializationPolicy",
    "signature": "com.google.gson.LongSerializationPolicy.serialize(java.lang.Long)",
    "snippet": "@Override public JsonElement serialize(Long value){\n  return new JsonPrimitive(value);\n}",
    "begin_line": 35,
    "end_line": 37,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.serialize#46",
    "is_bug": true,
    "src_path": "com/google/gson/LongSerializationPolicy.java",
    "class_name": "com.google.gson.LongSerializationPolicy",
    "signature": "com.google.gson.LongSerializationPolicy.serialize(java.lang.Long)",
    "snippet": "@Override public JsonElement serialize(Long value){\n  return new JsonPrimitive(String.valueOf(value));\n}",
    "begin_line": 46,
    "end_line": 48,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "null.serialize#57",
    "is_bug": true,
    "src_path": "com/google/gson/LongSerializationPolicy.java",
    "class_name": "com.google.gson.LongSerializationPolicy",
    "signature": "com.google.gson.LongSerializationPolicy.serialize(java.lang.Long)",
    "snippet": "public abstract JsonElement serialize(Long value);",
    "begin_line": 57,
    "end_line": 57,
    "comment": "/** \n * Serialize this  {@code value} using this serialization policy.\n * @param value the long value to be serialized into a {@link JsonElement}\n * @return the serialized version of {@code value}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.write#127",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.write(com.google.gson.stream.JsonWriter, T)",
    "snippet": "public abstract void write(JsonWriter out,T value) throws IOException ;",
    "begin_line": 127,
    "end_line": 127,
    "comment": "/** \n * Writes one JSON value (an array, object, string, number, boolean or null) for  {@code value}.\n * @param value the Java object to write. May be null.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.toJson#140",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.toJson(java.io.Writer, T)",
    "snippet": "public final void toJson(Writer out,T value) throws IOException {\n  JsonWriter writer\u003dnew JsonWriter(out);\n  write(writer,value);\n}",
    "begin_line": 140,
    "end_line": 143,
    "comment": "/** \n * Converts  {@code value} to a JSON document and writes it to {@code out}. Unlike Gson\u0027s similar  {@link Gson#toJson(JsonElement,Appendable) toJson}method, this write is strict. Create a  {@link JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call{@link #write(com.google.gson.stream.JsonWriter,Object)} for lenientwriting.\n * @param value the Java object to convert. May be null.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.nullSafe#185",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.nullSafe()",
    "snippet": "public final TypeAdapter\u003cT\u003e nullSafe(){\n  return new TypeAdapter\u003cT\u003e(){\n    @Override public void write(    JsonWriter out,    T value) throws IOException {\n      if (value \u003d\u003d null) {\n        out.nullValue();\n      }\n else {\n        TypeAdapter.this.write(out,value);\n      }\n    }\n    @Override public T read(    JsonReader reader) throws IOException {\n      if (reader.peek() \u003d\u003d JsonToken.NULL) {\n        reader.nextNull();\n        return null;\n      }\n      return TypeAdapter.this.read(reader);\n    }\n  }\n;\n}",
    "begin_line": 185,
    "end_line": 202,
    "comment": "/** \n * This wrapper method is used to make a type adapter null tolerant. In general, a type adapter is required to handle nulls in write and read methods. Here is how this is typically done:\u003cbr\u003e \u003cpre\u003e    {@code Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, new TypeAdapter\u003cFoo\u003e()  public Foo read(JsonReader in) throws IOException  if (in.peek() \u003d\u003d JsonToken.NULL)  in.nextNull(); return null;}// read a Foo from in and return it } public void write(JsonWriter out, Foo src) throws IOException  if (src \u003d\u003d null)  out.nullValue(); return; } // write src as JSON to out } }).create(); }\u003c/pre\u003e You can avoid this boilerplate handling of nulls by wrapping your type adapter with this method. Here is how we will rewrite the above example: \u003cpre\u003e    {@code Gson gson \u003d new GsonBuilder().registerTypeAdapter(Foo.class, new TypeAdapter\u003cFoo\u003e()  public Foo read(JsonReader in) throws IOException  // read a Foo from in and return it}public void write(JsonWriter out, Foo src) throws IOException  // write src as JSON to out } }.nullSafe()).create(); }\u003c/pre\u003e Note that we didn\u0027t need to check for nulls in our type adapter after we used nullSafe.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.write#187",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.write(com.google.gson.stream.JsonWriter, T)",
    "snippet": "@Override public void write(JsonWriter out,T value) throws IOException {\n  if (value \u003d\u003d null) {\n    out.nullValue();\n  }\n else {\n    TypeAdapter.this.write(out,value);\n  }\n}",
    "begin_line": 187,
    "end_line": 193,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.read#194",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public T read(JsonReader reader) throws IOException {\n  if (reader.peek() \u003d\u003d JsonToken.NULL) {\n    reader.nextNull();\n    return null;\n  }\n  return TypeAdapter.this.read(reader);\n}",
    "begin_line": 194,
    "end_line": 200,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.toJson#214",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.toJson(T)",
    "snippet": "public final String toJson(T value){\n  StringWriter stringWriter\u003dnew StringWriter();\n  try {\n    toJson(stringWriter,value);\n  }\n catch (  IOException e) {\n    throw new AssertionError(e);\n  }\n  return stringWriter.toString();\n}",
    "begin_line": 214,
    "end_line": 222,
    "comment": "/** \n * Converts  {@code value} to a JSON document. Unlike Gson\u0027s similar {@link Gson#toJson(Object) toJson} method, this write is strict. Create a {@link JsonWriter#setLenient(boolean) lenient} {@code JsonWriter} and call{@link #write(com.google.gson.stream.JsonWriter,Object)} for lenientwriting.\n * @param value the Java object to convert. May be null.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.toJsonTree#231",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.toJsonTree(T)",
    "snippet": "public final JsonElement toJsonTree(T value){\n  try {\n    JsonTreeWriter jsonWriter\u003dnew JsonTreeWriter();\n    write(jsonWriter,value);\n    return jsonWriter.get();\n  }\n catch (  IOException e) {\n    throw new JsonIOException(e);\n  }\n}",
    "begin_line": 231,
    "end_line": 239,
    "comment": "/** \n * Converts  {@code value} to a JSON tree.\n * @param value the Java object to convert. May be null.\n * @return the converted JSON tree. May be {@link JsonNull}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.read#247",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "public abstract T read(JsonReader in) throws IOException ;",
    "begin_line": 247,
    "end_line": 247,
    "comment": "/** \n * Reads one JSON value (an array, object, string, number, boolean or null) and converts it to a Java object. Returns the converted object.\n * @return the converted Java object. May be null.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.fromJson#258",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.fromJson(java.io.Reader)",
    "snippet": "public final T fromJson(Reader in) throws IOException {\n  JsonReader reader\u003dnew JsonReader(in);\n  return read(reader);\n}",
    "begin_line": 258,
    "end_line": 261,
    "comment": "/** \n * Converts the JSON document in  {@code in} to a Java object. Unlike Gson\u0027ssimilar  {@link Gson#fromJson(java.io.Reader,Class) fromJson} method, thisread is strict. Create a  {@link JsonReader#setLenient(boolean) lenient}{@code JsonReader} and call {@link #read(JsonReader)} for lenient reading.\n * @return the converted Java object. May be null.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.fromJson#272",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.fromJson(java.lang.String)",
    "snippet": "public final T fromJson(String json) throws IOException {\n  return fromJson(new StringReader(json));\n}",
    "begin_line": 272,
    "end_line": 274,
    "comment": "/** \n * Converts the JSON document in  {@code json} to a Java object. Unlike Gson\u0027ssimilar  {@link Gson#fromJson(String,Class) fromJson} method, this read isstrict. Create a  {@link JsonReader#setLenient(boolean) lenient} {@code JsonReader} and call {@link #read(JsonReader)} for lenient reading.\n * @return the converted Java object. May be null.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapter.fromJsonTree#282",
    "is_bug": true,
    "src_path": "com/google/gson/TypeAdapter.java",
    "class_name": "com.google.gson.TypeAdapter",
    "signature": "com.google.gson.TypeAdapter.fromJsonTree(com.google.gson.JsonElement)",
    "snippet": "public final T fromJsonTree(JsonElement jsonTree){\n  try {\n    JsonReader jsonReader\u003dnew JsonTreeReader(jsonTree);\n    return read(jsonReader);\n  }\n catch (  IOException e) {\n    throw new JsonIOException(e);\n  }\n}",
    "begin_line": 282,
    "end_line": 289,
    "comment": "/** \n * Converts  {@code jsonTree} to a Java object.\n * @param jsonTree the Java object to convert. May be {@link JsonNull}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.ConstructorConstructor#51",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.ConstructorConstructor(java.util.Map\u003cjava.lang.reflect.Type,com.google.gson.InstanceCreator\u003c?\u003e\u003e)",
    "snippet": "public ConstructorConstructor(Map\u003cType,InstanceCreator\u003c?\u003e\u003e instanceCreators){\n  this.instanceCreators\u003dinstanceCreators;\n}",
    "begin_line": 51,
    "end_line": 53,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.get#55",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.get(com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "public \u003cT\u003eObjectConstructor\u003cT\u003e get(TypeToken\u003cT\u003e typeToken){\n  final Type type\u003dtypeToken.getType();\n  final Class\u003c? super T\u003e rawType\u003dtypeToken.getRawType();\n  @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e typeCreator\u003d(InstanceCreator\u003cT\u003e)instanceCreators.get(type);\n  if (typeCreator !\u003d null) {\n    return new ObjectConstructor\u003cT\u003e(){\n      @Override public T construct(){\n        return typeCreator.createInstance(type);\n      }\n    }\n;\n  }\n  @SuppressWarnings(\"unchecked\") final InstanceCreator\u003cT\u003e rawTypeCreator\u003d(InstanceCreator\u003cT\u003e)instanceCreators.get(rawType);\n  if (rawTypeCreator !\u003d null) {\n    return new ObjectConstructor\u003cT\u003e(){\n      @Override public T construct(){\n        return rawTypeCreator.createInstance(type);\n      }\n    }\n;\n  }\n  ObjectConstructor\u003cT\u003e defaultConstructor\u003dnewDefaultConstructor(rawType);\n  if (defaultConstructor !\u003d null) {\n    return defaultConstructor;\n  }\n  ObjectConstructor\u003cT\u003e defaultImplementation\u003dnewDefaultImplementationConstructor(type,rawType);\n  if (defaultImplementation !\u003d null) {\n    return defaultImplementation;\n  }\n  return newUnsafeAllocator(type,rawType);\n}",
    "begin_line": 55,
    "end_line": 95,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#65",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct(){\n  return typeCreator.createInstance(type);\n}",
    "begin_line": 65,
    "end_line": 67,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#77",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct(){\n  return rawTypeCreator.createInstance(type);\n}",
    "begin_line": 77,
    "end_line": 79,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.newDefaultConstructor#97",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.newDefaultConstructor(java.lang.Class\u003c? super T\u003e)",
    "snippet": "private \u003cT\u003eObjectConstructor\u003cT\u003e newDefaultConstructor(Class\u003c? super T\u003e rawType){\n  try {\n    final Constructor\u003c? super T\u003e constructor\u003drawType.getDeclaredConstructor();\n    if (!constructor.isAccessible()) {\n      constructor.setAccessible(true);\n    }\n    return new ObjectConstructor\u003cT\u003e(){\n      @SuppressWarnings(\"unchecked\") @Override public T construct(){\n        try {\n          Object[] args\u003dnull;\n          return (T)constructor.newInstance(args);\n        }\n catch (        InstantiationException e) {\n          throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",e);\n        }\ncatch (        InvocationTargetException e) {\n          throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",e.getTargetException());\n        }\ncatch (        IllegalAccessException e) {\n          throw new AssertionError(e);\n        }\n      }\n    }\n;\n  }\n catch (  NoSuchMethodException e) {\n    return null;\n  }\n}",
    "begin_line": 97,
    "end_line": 125,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#105",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public T construct(){\n  try {\n    Object[] args\u003dnull;\n    return (T)constructor.newInstance(args);\n  }\n catch (  InstantiationException e) {\n    throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",e);\n  }\ncatch (  InvocationTargetException e) {\n    throw new RuntimeException(\"Failed to invoke \" + constructor + \" with no args\",e.getTargetException());\n  }\ncatch (  IllegalAccessException e) {\n    throw new AssertionError(e);\n  }\n}",
    "begin_line": 105,
    "end_line": 120,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.newDefaultImplementationConstructor#132",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.newDefaultImplementationConstructor(java.lang.reflect.Type, java.lang.Class\u003c? super T\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") private \u003cT\u003eObjectConstructor\u003cT\u003e newDefaultImplementationConstructor(final Type type,Class\u003c? super T\u003e rawType){\n  if (Collection.class.isAssignableFrom(rawType)) {\n    if (SortedSet.class.isAssignableFrom(rawType)) {\n      return new ObjectConstructor\u003cT\u003e(){\n        @Override public T construct(){\n          return (T)new TreeSet\u003cObject\u003e();\n        }\n      }\n;\n    }\n else     if (EnumSet.class.isAssignableFrom(rawType)) {\n      return new ObjectConstructor\u003cT\u003e(){\n        @SuppressWarnings(\"rawtypes\") @Override public T construct(){\n          if (type instanceof ParameterizedType) {\n            Type elementType\u003d((ParameterizedType)type).getActualTypeArguments()[0];\n            if (elementType instanceof Class) {\n              return (T)EnumSet.noneOf((Class)elementType);\n            }\n else {\n              throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n            }\n          }\n else {\n            throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n          }\n        }\n      }\n;\n    }\n else     if (Set.class.isAssignableFrom(rawType)) {\n      return new ObjectConstructor\u003cT\u003e(){\n        @Override public T construct(){\n          return (T)new LinkedHashSet\u003cObject\u003e();\n        }\n      }\n;\n    }\n else     if (Queue.class.isAssignableFrom(rawType)) {\n      return new ObjectConstructor\u003cT\u003e(){\n        @Override public T construct(){\n          return (T)new LinkedList\u003cObject\u003e();\n        }\n      }\n;\n    }\n else {\n      return new ObjectConstructor\u003cT\u003e(){\n        @Override public T construct(){\n          return (T)new ArrayList\u003cObject\u003e();\n        }\n      }\n;\n    }\n  }\n  if (Map.class.isAssignableFrom(rawType)) {\n    if (ConcurrentNavigableMap.class.isAssignableFrom(rawType)) {\n      return new ObjectConstructor\u003cT\u003e(){\n        @Override public T construct(){\n          return (T)new ConcurrentSkipListMap\u003cObject,Object\u003e();\n        }\n      }\n;\n    }\n else     if (ConcurrentMap.class.isAssignableFrom(rawType)) {\n      return new ObjectConstructor\u003cT\u003e(){\n        @Override public T construct(){\n          return (T)new ConcurrentHashMap\u003cObject,Object\u003e();\n        }\n      }\n;\n    }\n else     if (SortedMap.class.isAssignableFrom(rawType)) {\n      return new ObjectConstructor\u003cT\u003e(){\n        @Override public T construct(){\n          return (T)new TreeMap\u003cObject,Object\u003e();\n        }\n      }\n;\n    }\n else     if (type instanceof ParameterizedType \u0026\u0026 !(String.class.isAssignableFrom(TypeToken.get(((ParameterizedType)type).getActualTypeArguments()[0]).getRawType()))) {\n      return new ObjectConstructor\u003cT\u003e(){\n        @Override public T construct(){\n          return (T)new LinkedHashMap\u003cObject,Object\u003e();\n        }\n      }\n;\n    }\n else {\n      return new ObjectConstructor\u003cT\u003e(){\n        @Override public T construct(){\n          return (T)new LinkedTreeMap\u003cString,Object\u003e();\n        }\n      }\n;\n    }\n  }\n  return null;\n}",
    "begin_line": 132,
    "end_line": 214,
    "comment": "/** \n * Constructors for common interface types like Map and List and their subtypes.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#137",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct(){\n  return (T)new TreeSet\u003cObject\u003e();\n}",
    "begin_line": 137,
    "end_line": 139,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#144",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@SuppressWarnings(\"rawtypes\") @Override public T construct(){\n  if (type instanceof ParameterizedType) {\n    Type elementType\u003d((ParameterizedType)type).getActualTypeArguments()[0];\n    if (elementType instanceof Class) {\n      return (T)EnumSet.noneOf((Class)elementType);\n    }\n else {\n      throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n    }\n  }\n else {\n    throw new JsonIOException(\"Invalid EnumSet type: \" + type.toString());\n  }\n}",
    "begin_line": 144,
    "end_line": 155,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#159",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct(){\n  return (T)new LinkedHashSet\u003cObject\u003e();\n}",
    "begin_line": 159,
    "end_line": 161,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#165",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct(){\n  return (T)new LinkedList\u003cObject\u003e();\n}",
    "begin_line": 165,
    "end_line": 167,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#171",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct(){\n  return (T)new ArrayList\u003cObject\u003e();\n}",
    "begin_line": 171,
    "end_line": 173,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#181",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct(){\n  return (T)new ConcurrentSkipListMap\u003cObject,Object\u003e();\n}",
    "begin_line": 181,
    "end_line": 183,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#187",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct(){\n  return (T)new ConcurrentHashMap\u003cObject,Object\u003e();\n}",
    "begin_line": 187,
    "end_line": 189,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#193",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct(){\n  return (T)new TreeMap\u003cObject,Object\u003e();\n}",
    "begin_line": 193,
    "end_line": 195,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#200",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct(){\n  return (T)new LinkedHashMap\u003cObject,Object\u003e();\n}",
    "begin_line": 200,
    "end_line": 202,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#206",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@Override public T construct(){\n  return (T)new LinkedTreeMap\u003cString,Object\u003e();\n}",
    "begin_line": 206,
    "end_line": 208,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.newUnsafeAllocator#216",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.newUnsafeAllocator(java.lang.reflect.Type, java.lang.Class\u003c? super T\u003e)",
    "snippet": "private \u003cT\u003eObjectConstructor\u003cT\u003e newUnsafeAllocator(final Type type,final Class\u003c? super T\u003e rawType){\n  return new ObjectConstructor\u003cT\u003e(){\n    private final UnsafeAllocator unsafeAllocator\u003dUnsafeAllocator.create();\n    @SuppressWarnings(\"unchecked\") @Override public T construct(){\n      try {\n        Object newInstance\u003dunsafeAllocator.newInstance(rawType);\n        return (T)newInstance;\n      }\n catch (      Exception e) {\n        throw new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"+ \"Register an InstanceCreator with Gson for this type may fix this problem.\"),e);\n      }\n    }\n  }\n;\n}",
    "begin_line": 216,
    "end_line": 231,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.construct#221",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.construct()",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public T construct(){\n  try {\n    Object newInstance\u003dunsafeAllocator.newInstance(rawType);\n    return (T)newInstance;\n  }\n catch (  Exception e) {\n    throw new RuntimeException((\"Unable to invoke no-args constructor for \" + type + \". \"+ \"Register an InstanceCreator with Gson for this type may fix this problem.\"),e);\n  }\n}",
    "begin_line": 221,
    "end_line": 229,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ConstructorConstructor.toString#233",
    "is_bug": true,
    "src_path": "com/google/gson/internal/ConstructorConstructor.java",
    "class_name": "com.google.gson.internal.ConstructorConstructor",
    "signature": "com.google.gson.internal.ConstructorConstructor.toString()",
    "snippet": "@Override public String toString(){\n  return instanceCreators.toString();\n}",
    "begin_line": 233,
    "end_line": 235,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.clone#61",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.clone()",
    "snippet": "@Override protected Excluder clone(){\n  try {\n    return (Excluder)super.clone();\n  }\n catch (  CloneNotSupportedException e) {\n    throw new AssertionError(e);\n  }\n}",
    "begin_line": 61,
    "end_line": 67,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.withVersion#69",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.withVersion(double)",
    "snippet": "public Excluder withVersion(double ignoreVersionsAfter){\n  Excluder result\u003dclone();\n  result.version\u003dignoreVersionsAfter;\n  return result;\n}",
    "begin_line": 69,
    "end_line": 73,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.withModifiers#75",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.withModifiers(int)",
    "snippet": "public Excluder withModifiers(int... modifiers){\n  Excluder result\u003dclone();\n  result.modifiers\u003d0;\n  for (  int modifier : modifiers) {\n    result.modifiers|\u003dmodifier;\n  }\n  return result;\n}",
    "begin_line": 75,
    "end_line": 82,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.disableInnerClassSerialization#84",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.disableInnerClassSerialization()",
    "snippet": "public Excluder disableInnerClassSerialization(){\n  Excluder result\u003dclone();\n  result.serializeInnerClasses\u003dfalse;\n  return result;\n}",
    "begin_line": 84,
    "end_line": 88,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.excludeFieldsWithoutExposeAnnotation#90",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.excludeFieldsWithoutExposeAnnotation()",
    "snippet": "public Excluder excludeFieldsWithoutExposeAnnotation(){\n  Excluder result\u003dclone();\n  result.requireExpose\u003dtrue;\n  return result;\n}",
    "begin_line": 90,
    "end_line": 94,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.withExclusionStrategy#96",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.withExclusionStrategy(com.google.gson.ExclusionStrategy, boolean, boolean)",
    "snippet": "public Excluder withExclusionStrategy(ExclusionStrategy exclusionStrategy,boolean serialization,boolean deserialization){\n  Excluder result\u003dclone();\n  if (serialization) {\n    result.serializationStrategies\u003dnew ArrayList\u003cExclusionStrategy\u003e(serializationStrategies);\n    result.serializationStrategies.add(exclusionStrategy);\n  }\n  if (deserialization) {\n    result.deserializationStrategies\u003dnew ArrayList\u003cExclusionStrategy\u003e(deserializationStrategies);\n    result.deserializationStrategies.add(exclusionStrategy);\n  }\n  return result;\n}",
    "begin_line": 96,
    "end_line": 109,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.create#111",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "public \u003cT\u003eTypeAdapter\u003cT\u003e create(final Gson gson,final TypeToken\u003cT\u003e type){\n  Class\u003c?\u003e rawType\u003dtype.getRawType();\n  final boolean skipSerialize\u003dexcludeClass(rawType,true);\n  final boolean skipDeserialize\u003dexcludeClass(rawType,false);\n  if (!skipSerialize \u0026\u0026 !skipDeserialize) {\n    return null;\n  }\n  return new TypeAdapter\u003cT\u003e(){\n    \n    private TypeAdapter\u003cT\u003e delegate;\n    @Override public T read(    JsonReader in) throws IOException {\n      if (skipDeserialize) {\n        in.skipValue();\n        return null;\n      }\n      return delegate().read(in);\n    }\n    @Override public void write(    JsonWriter out,    T value) throws IOException {\n      if (skipSerialize) {\n        out.nullValue();\n        return;\n      }\n      delegate().write(out,value);\n    }\n    private TypeAdapter\u003cT\u003e delegate(){\n      TypeAdapter\u003cT\u003e d\u003ddelegate;\n      return d !\u003d null ? d : (delegate\u003dgson.getDelegateAdapter(Excluder.this,type));\n    }\n  }\n;\n}",
    "begin_line": 111,
    "end_line": 147,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.read#124",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public T read(JsonReader in) throws IOException {\n  if (skipDeserialize) {\n    in.skipValue();\n    return null;\n  }\n  return delegate().read(in);\n}",
    "begin_line": 124,
    "end_line": 130,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.write#132",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.write(com.google.gson.stream.JsonWriter, T)",
    "snippet": "@Override public void write(JsonWriter out,T value) throws IOException {\n  if (skipSerialize) {\n    out.nullValue();\n    return;\n  }\n  delegate().write(out,value);\n}",
    "begin_line": 132,
    "end_line": 138,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.delegate#140",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.delegate()",
    "snippet": "private TypeAdapter\u003cT\u003e delegate(){\n  TypeAdapter\u003cT\u003e d\u003ddelegate;\n  return d !\u003d null ? d : (delegate\u003dgson.getDelegateAdapter(Excluder.this,type));\n}",
    "begin_line": 140,
    "end_line": 145,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.excludeField#149",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.excludeField(java.lang.reflect.Field, boolean)",
    "snippet": "public boolean excludeField(Field field,boolean serialize){\n  if ((modifiers \u0026 field.getModifiers()) !\u003d 0) {\n    return true;\n  }\n  if (version !\u003d Excluder.IGNORE_VERSIONS \u0026\u0026 !isValidVersion(field.getAnnotation(Since.class),field.getAnnotation(Until.class))) {\n    return true;\n  }\n  if (field.isSynthetic()) {\n    return true;\n  }\n  if (requireExpose) {\n    Expose annotation\u003dfield.getAnnotation(Expose.class);\n    if (annotation \u003d\u003d null || (serialize ? !annotation.serialize() : !annotation.deserialize())) {\n      return true;\n    }\n  }\n  if (!serializeInnerClasses \u0026\u0026 isInnerClass(field.getType())) {\n    return true;\n  }\n  if (isAnonymousOrLocal(field.getType())) {\n    return true;\n  }\n  List\u003cExclusionStrategy\u003e list\u003dserialize ? serializationStrategies : deserializationStrategies;\n  if (!list.isEmpty()) {\n    FieldAttributes fieldAttributes\u003dnew FieldAttributes(field);\n    for (    ExclusionStrategy exclusionStrategy : list) {\n      if (exclusionStrategy.shouldSkipField(fieldAttributes)) {\n        return true;\n      }\n    }\n  }\n  return false;\n}",
    "begin_line": 149,
    "end_line": 189,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.excludeClass#191",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.excludeClass(java.lang.Class\u003c?\u003e, boolean)",
    "snippet": "public boolean excludeClass(Class\u003c?\u003e clazz,boolean serialize){\n  if (version !\u003d Excluder.IGNORE_VERSIONS \u0026\u0026 !isValidVersion(clazz.getAnnotation(Since.class),clazz.getAnnotation(Until.class))) {\n    return true;\n  }\n  if (!serializeInnerClasses \u0026\u0026 isInnerClass(clazz)) {\n    return true;\n  }\n  if (isAnonymousOrLocal(clazz)) {\n    return true;\n  }\n  List\u003cExclusionStrategy\u003e list\u003dserialize ? serializationStrategies : deserializationStrategies;\n  for (  ExclusionStrategy exclusionStrategy : list) {\n    if (exclusionStrategy.shouldSkipClass(clazz)) {\n      return true;\n    }\n  }\n  return false;\n}",
    "begin_line": 191,
    "end_line": 213,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.isAnonymousOrLocal#215",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.isAnonymousOrLocal(java.lang.Class\u003c?\u003e)",
    "snippet": "private boolean isAnonymousOrLocal(Class\u003c?\u003e clazz){\n  return !Enum.class.isAssignableFrom(clazz) \u0026\u0026 (clazz.isAnonymousClass() || clazz.isLocalClass());\n}",
    "begin_line": 215,
    "end_line": 218,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.isInnerClass#220",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.isInnerClass(java.lang.Class\u003c?\u003e)",
    "snippet": "private boolean isInnerClass(Class\u003c?\u003e clazz){\n  return clazz.isMemberClass() \u0026\u0026 !isStatic(clazz);\n}",
    "begin_line": 220,
    "end_line": 222,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.isStatic#224",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.isStatic(java.lang.Class\u003c?\u003e)",
    "snippet": "private boolean isStatic(Class\u003c?\u003e clazz){\n  return (clazz.getModifiers() \u0026 Modifier.STATIC) !\u003d 0;\n}",
    "begin_line": 224,
    "end_line": 226,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.isValidVersion#228",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.isValidVersion(com.google.gson.annotations.Since, com.google.gson.annotations.Until)",
    "snippet": "private boolean isValidVersion(Since since,Until until){\n  return isValidSince(since) \u0026\u0026 isValidUntil(until);\n}",
    "begin_line": 228,
    "end_line": 230,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.isValidSince#232",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.isValidSince(com.google.gson.annotations.Since)",
    "snippet": "private boolean isValidSince(Since annotation){\n  if (annotation !\u003d null) {\n    double annotationVersion\u003dannotation.value();\n    if (annotationVersion \u003e version) {\n      return false;\n    }\n  }\n  return true;\n}",
    "begin_line": 232,
    "end_line": 240,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Excluder.isValidUntil#242",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Excluder.java",
    "class_name": "com.google.gson.internal.Excluder",
    "signature": "com.google.gson.internal.Excluder.isValidUntil(com.google.gson.annotations.Until)",
    "snippet": "private boolean isValidUntil(Until annotation){\n  if (annotation !\u003d null) {\n    double annotationVersion\u003dannotation.value();\n    if (annotationVersion \u003c\u003d version) {\n      return false;\n    }\n  }\n  return true;\n}",
    "begin_line": 242,
    "end_line": 250,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReaderInternalAccess.promoteNameToValue#31",
    "is_bug": true,
    "src_path": "com/google/gson/internal/JsonReaderInternalAccess.java",
    "class_name": "com.google.gson.internal.JsonReaderInternalAccess",
    "signature": "com.google.gson.internal.JsonReaderInternalAccess.promoteNameToValue(com.google.gson.stream.JsonReader)",
    "snippet": "public abstract void promoteNameToValue(JsonReader reader) throws IOException ;",
    "begin_line": 31,
    "end_line": 31,
    "comment": "/** \n * Changes the type of the current property name token to a string value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Streams.Streams#36",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.Streams()",
    "snippet": "private Streams(){\n  throw new UnsupportedOperationException();\n}",
    "begin_line": 36,
    "end_line": 38,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Streams.parse#43",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.parse(com.google.gson.stream.JsonReader)",
    "snippet": "public static JsonElement parse(JsonReader reader) throws JsonParseException {\n  boolean isEmpty\u003dtrue;\n  try {\n    reader.peek();\n    isEmpty\u003dfalse;\n    return TypeAdapters.JSON_ELEMENT.read(reader);\n  }\n catch (  EOFException e) {\n    if (isEmpty) {\n      return JsonNull.INSTANCE;\n    }\n    throw new JsonSyntaxException(e);\n  }\ncatch (  MalformedJsonException e) {\n    throw new JsonSyntaxException(e);\n  }\ncatch (  IOException e) {\n    throw new JsonIOException(e);\n  }\ncatch (  NumberFormatException e) {\n    throw new JsonSyntaxException(e);\n  }\n}",
    "begin_line": 43,
    "end_line": 66,
    "comment": "/** \n * Takes a reader in any state and returns the next value as a JsonElement.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Streams.write#71",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.write(com.google.gson.JsonElement, com.google.gson.stream.JsonWriter)",
    "snippet": "public static void write(JsonElement element,JsonWriter writer) throws IOException {\n  TypeAdapters.JSON_ELEMENT.write(writer,element);\n}",
    "begin_line": 71,
    "end_line": 73,
    "comment": "/** \n * Writes the JSON element to the writer, recursively.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Streams.writerForAppendable#76",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.writerForAppendable(java.lang.Appendable)",
    "snippet": "@SuppressWarnings(\"resource\") public static Writer writerForAppendable(Appendable appendable){\n  return appendable instanceof Writer ? (Writer)appendable : new AppendableWriter(appendable);\n}",
    "begin_line": 76,
    "end_line": 78,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AppendableWriter.AppendableWriter#88",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.AppendableWriter(java.lang.Appendable)",
    "snippet": "AppendableWriter(Appendable appendable){\n  this.appendable\u003dappendable;\n}",
    "begin_line": 88,
    "end_line": 90,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AppendableWriter.write#92",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.write(char[], int, int)",
    "snippet": "@Override public void write(char[] chars,int offset,int length) throws IOException {\n  currentWrite.chars\u003dchars;\n  appendable.append(currentWrite,offset,offset + length);\n}",
    "begin_line": 92,
    "end_line": 95,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AppendableWriter.write#97",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.write(int)",
    "snippet": "@Override public void write(int i) throws IOException {\n  appendable.append((char)i);\n}",
    "begin_line": 97,
    "end_line": 99,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AppendableWriter.flush#101",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.flush()",
    "snippet": "@Override public void flush(){\n}",
    "begin_line": 101,
    "end_line": 101,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AppendableWriter.close#102",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.close()",
    "snippet": "@Override public void close(){\n}",
    "begin_line": 102,
    "end_line": 102,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CurrentWrite.length#109",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.length()",
    "snippet": "public int length(){\n  return chars.length;\n}",
    "begin_line": 109,
    "end_line": 111,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CurrentWrite.charAt#112",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.charAt(int)",
    "snippet": "public char charAt(int i){\n  return chars[i];\n}",
    "begin_line": 112,
    "end_line": 114,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CurrentWrite.subSequence#115",
    "is_bug": true,
    "src_path": "com/google/gson/internal/Streams.java",
    "class_name": "com.google.gson.internal.Streams",
    "signature": "com.google.gson.internal.Streams.subSequence(int, int)",
    "snippet": "public CharSequence subSequence(int start,int end){\n  return new String(chars,start,end - start);\n}",
    "begin_line": 115,
    "end_line": 117,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArrayTypeAdapter.create#41",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ArrayTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ArrayTypeAdapter",
    "signature": "com.google.gson.internal.bind.ArrayTypeAdapter.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e typeToken){\n  Type type\u003dtypeToken.getType();\n  if (!(type instanceof GenericArrayType || type instanceof Class \u0026\u0026 ((Class\u003c?\u003e)type).isArray())) {\n    return null;\n  }\n  Type componentType\u003d$Gson$Types.getArrayComponentType(type);\n  TypeAdapter\u003c?\u003e componentTypeAdapter\u003dgson.getAdapter(TypeToken.get(componentType));\n  return new ArrayTypeAdapter(gson,componentTypeAdapter,$Gson$Types.getRawType(componentType));\n}",
    "begin_line": 41,
    "end_line": 51,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArrayTypeAdapter.ArrayTypeAdapter#57",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ArrayTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ArrayTypeAdapter",
    "signature": "com.google.gson.internal.bind.ArrayTypeAdapter.ArrayTypeAdapter(com.google.gson.Gson, com.google.gson.TypeAdapter\u003cE\u003e, java.lang.Class\u003cE\u003e)",
    "snippet": "public ArrayTypeAdapter(Gson context,TypeAdapter\u003cE\u003e componentTypeAdapter,Class\u003cE\u003e componentType){\n  this.componentTypeAdapter\u003dnew TypeAdapterRuntimeTypeWrapper\u003cE\u003e(context,componentTypeAdapter,componentType);\n  this.componentType\u003dcomponentType;\n}",
    "begin_line": 57,
    "end_line": 61,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArrayTypeAdapter.read#63",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ArrayTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ArrayTypeAdapter",
    "signature": "com.google.gson.internal.bind.ArrayTypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Object read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  List\u003cE\u003e list\u003dnew ArrayList\u003cE\u003e();\n  in.beginArray();\n  while (in.hasNext()) {\n    E instance\u003dcomponentTypeAdapter.read(in);\n    list.add(instance);\n  }\n  in.endArray();\n  Object array\u003dArray.newInstance(componentType,list.size());\n  for (int i\u003d0; i \u003c list.size(); i++) {\n    Array.set(array,i,list.get(i));\n  }\n  return array;\n}",
    "begin_line": 63,
    "end_line": 81,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ArrayTypeAdapter.write#84",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ArrayTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ArrayTypeAdapter",
    "signature": "com.google.gson.internal.bind.ArrayTypeAdapter.write(com.google.gson.stream.JsonWriter, java.lang.Object)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public void write(JsonWriter out,Object array) throws IOException {\n  if (array \u003d\u003d null) {\n    out.nullValue();\n    return;\n  }\n  out.beginArray();\n  for (int i\u003d0, length\u003dArray.getLength(array); i \u003c length; i++) {\n    E value\u003d(E)Array.get(array,i);\n    componentTypeAdapter.write(out,value);\n  }\n  out.endArray();\n}",
    "begin_line": 84,
    "end_line": 96,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CollectionTypeAdapterFactory.CollectionTypeAdapterFactory#39",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.CollectionTypeAdapterFactory(com.google.gson.internal.ConstructorConstructor)",
    "snippet": "public CollectionTypeAdapterFactory(ConstructorConstructor constructorConstructor){\n  this.constructorConstructor\u003dconstructorConstructor;\n}",
    "begin_line": 39,
    "end_line": 41,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CollectionTypeAdapterFactory.create#44",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e typeToken){\n  Type type\u003dtypeToken.getType();\n  Class\u003c? super T\u003e rawType\u003dtypeToken.getRawType();\n  if (!Collection.class.isAssignableFrom(rawType)) {\n    return null;\n  }\n  Type elementType\u003d$Gson$Types.getCollectionElementType(type,rawType);\n  TypeAdapter\u003c?\u003e elementTypeAdapter\u003dgson.getAdapter(TypeToken.get(elementType));\n  ObjectConstructor\u003cT\u003e constructor\u003dconstructorConstructor.get(typeToken);\n  @SuppressWarnings({\"unchecked\",\"rawtypes\"}) TypeAdapter\u003cT\u003e result\u003dnew Adapter(gson,elementType,elementTypeAdapter,constructor);\n  return result;\n}",
    "begin_line": 44,
    "end_line": 59,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.Adapter#65",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.Adapter(com.google.gson.Gson, java.lang.reflect.Type, com.google.gson.TypeAdapter\u003cE\u003e, com.google.gson.internal.ObjectConstructor\u003c? extends java.util.Collection\u003cE\u003e\u003e)",
    "snippet": "public Adapter(Gson context,Type elementType,TypeAdapter\u003cE\u003e elementTypeAdapter,ObjectConstructor\u003c? extends Collection\u003cE\u003e\u003e constructor){\n  this.elementTypeAdapter\u003dnew TypeAdapterRuntimeTypeWrapper\u003cE\u003e(context,elementTypeAdapter,elementType);\n  this.constructor\u003dconstructor;\n}",
    "begin_line": 65,
    "end_line": 71,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.read#73",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Collection\u003cE\u003e read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  Collection\u003cE\u003e collection\u003dconstructor.construct();\n  in.beginArray();\n  while (in.hasNext()) {\n    E instance\u003delementTypeAdapter.read(in);\n    collection.add(instance);\n  }\n  in.endArray();\n  return collection;\n}",
    "begin_line": 73,
    "end_line": 87,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.write#89",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/CollectionTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.CollectionTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.CollectionTypeAdapterFactory.write(com.google.gson.stream.JsonWriter, java.util.Collection\u003cE\u003e)",
    "snippet": "@Override public void write(JsonWriter out,Collection\u003cE\u003e collection) throws IOException {\n  if (collection \u003d\u003d null) {\n    out.nullValue();\n    return;\n  }\n  out.beginArray();\n  for (  E element : collection) {\n    elementTypeAdapter.write(out,element);\n  }\n  out.endArray();\n}",
    "begin_line": 89,
    "end_line": 100,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DateTypeAdapter.create#44",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/DateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.DateTypeAdapter",
    "signature": "com.google.gson.internal.bind.DateTypeAdapter.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e typeToken){\n  return typeToken.getRawType() \u003d\u003d Date.class ? (TypeAdapter\u003cT\u003e)new DateTypeAdapter() : null;\n}",
    "begin_line": 44,
    "end_line": 46,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DateTypeAdapter.read#54",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/DateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.DateTypeAdapter",
    "signature": "com.google.gson.internal.bind.DateTypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Date read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  return deserializeToDate(in.nextString());\n}",
    "begin_line": 54,
    "end_line": 60,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DateTypeAdapter.deserializeToDate#62",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/DateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.DateTypeAdapter",
    "signature": "com.google.gson.internal.bind.DateTypeAdapter.deserializeToDate(java.lang.String)",
    "snippet": "private synchronized Date deserializeToDate(String json){\n  try {\n    return localFormat.parse(json);\n  }\n catch (  ParseException ignored) {\n  }\n  try {\n    return enUsFormat.parse(json);\n  }\n catch (  ParseException ignored) {\n  }\n  try {\n    return ISO8601Utils.parse(json,new ParsePosition(0));\n  }\n catch (  ParseException e) {\n    throw new JsonSyntaxException(json,e);\n  }\n}",
    "begin_line": 62,
    "end_line": 76,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "DateTypeAdapter.write#78",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/DateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.DateTypeAdapter",
    "signature": "com.google.gson.internal.bind.DateTypeAdapter.write(com.google.gson.stream.JsonWriter, java.util.Date)",
    "snippet": "@Override public synchronized void write(JsonWriter out,Date value) throws IOException {\n  if (value \u003d\u003d null) {\n    out.nullValue();\n    return;\n  }\n  String dateFormatAsString\u003denUsFormat.format(value);\n  out.value(dateFormatAsString);\n}",
    "begin_line": 78,
    "end_line": 85,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonAdapterAnnotationTypeAdapterFactory.JsonAdapterAnnotationTypeAdapterFactory#36",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.JsonAdapterAnnotationTypeAdapterFactory(com.google.gson.internal.ConstructorConstructor)",
    "snippet": "public JsonAdapterAnnotationTypeAdapterFactory(ConstructorConstructor constructorConstructor){\n  this.constructorConstructor\u003dconstructorConstructor;\n}",
    "begin_line": 36,
    "end_line": 38,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonAdapterAnnotationTypeAdapterFactory.create#42",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e targetType){\n  JsonAdapter annotation\u003dtargetType.getRawType().getAnnotation(JsonAdapter.class);\n  if (annotation \u003d\u003d null) {\n    return null;\n  }\n  return (TypeAdapter\u003cT\u003e)getTypeAdapter(constructorConstructor,gson,targetType,annotation);\n}",
    "begin_line": 42,
    "end_line": 48,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter#51",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/JsonAdapterAnnotationTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.JsonAdapterAnnotationTypeAdapterFactory.getTypeAdapter(com.google.gson.internal.ConstructorConstructor, com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003c?\u003e, com.google.gson.annotations.JsonAdapter)",
    "snippet": "@SuppressWarnings(\"unchecked\") static TypeAdapter\u003c?\u003e getTypeAdapter(ConstructorConstructor constructorConstructor,Gson gson,TypeToken\u003c?\u003e fieldType,JsonAdapter annotation){\n  Class\u003c?\u003e value\u003dannotation.value();\n  TypeAdapter\u003c?\u003e typeAdapter;\n  if (TypeAdapter.class.isAssignableFrom(value)) {\n    Class\u003cTypeAdapter\u003c?\u003e\u003e typeAdapterClass\u003d(Class\u003cTypeAdapter\u003c?\u003e\u003e)value;\n    typeAdapter\u003dconstructorConstructor.get(TypeToken.get(typeAdapterClass)).construct();\n  }\n else   if (TypeAdapterFactory.class.isAssignableFrom(value)) {\n    Class\u003cTypeAdapterFactory\u003e typeAdapterFactory\u003d(Class\u003cTypeAdapterFactory\u003e)value;\n    typeAdapter\u003dconstructorConstructor.get(TypeToken.get(typeAdapterFactory)).construct().create(gson,fieldType);\n  }\n else {\n    throw new IllegalArgumentException(\"@JsonAdapter value must be TypeAdapter or TypeAdapterFactory reference.\");\n  }\n  typeAdapter\u003dtypeAdapter.nullSafe();\n  return typeAdapter;\n}",
    "begin_line": 51,
    "end_line": 69,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MapTypeAdapterFactory.MapTypeAdapterFactory#109",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.MapTypeAdapterFactory(com.google.gson.internal.ConstructorConstructor, boolean)",
    "snippet": "public MapTypeAdapterFactory(ConstructorConstructor constructorConstructor,boolean complexMapKeySerialization){\n  this.constructorConstructor\u003dconstructorConstructor;\n  this.complexMapKeySerialization\u003dcomplexMapKeySerialization;\n}",
    "begin_line": 109,
    "end_line": 113,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MapTypeAdapterFactory.create#115",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e typeToken){\n  Type type\u003dtypeToken.getType();\n  Class\u003c? super T\u003e rawType\u003dtypeToken.getRawType();\n  if (!Map.class.isAssignableFrom(rawType)) {\n    return null;\n  }\n  Class\u003c?\u003e rawTypeOfSrc\u003d$Gson$Types.getRawType(type);\n  Type[] keyAndValueTypes\u003d$Gson$Types.getMapKeyAndValueTypes(type,rawTypeOfSrc);\n  TypeAdapter\u003c?\u003e keyAdapter\u003dgetKeyAdapter(gson,keyAndValueTypes[0]);\n  TypeAdapter\u003c?\u003e valueAdapter\u003dgson.getAdapter(TypeToken.get(keyAndValueTypes[1]));\n  ObjectConstructor\u003cT\u003e constructor\u003dconstructorConstructor.get(typeToken);\n  @SuppressWarnings({\"unchecked\",\"rawtypes\"}) TypeAdapter\u003cT\u003e result\u003dnew Adapter(gson,keyAndValueTypes[0],keyAdapter,keyAndValueTypes[1],valueAdapter,constructor);\n  return result;\n}",
    "begin_line": 115,
    "end_line": 134,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MapTypeAdapterFactory.getKeyAdapter#139",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.getKeyAdapter(com.google.gson.Gson, java.lang.reflect.Type)",
    "snippet": "private TypeAdapter\u003c?\u003e getKeyAdapter(Gson context,Type keyType){\n  return (keyType \u003d\u003d boolean.class || keyType \u003d\u003d Boolean.class) ? TypeAdapters.BOOLEAN_AS_STRING : context.getAdapter(TypeToken.get(keyType));\n}",
    "begin_line": 139,
    "end_line": 143,
    "comment": "/** \n * Returns a type adapter that writes the value as a string.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.Adapter#150",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.Adapter(com.google.gson.Gson, java.lang.reflect.Type, com.google.gson.TypeAdapter\u003cK\u003e, java.lang.reflect.Type, com.google.gson.TypeAdapter\u003cV\u003e, com.google.gson.internal.ObjectConstructor\u003c? extends java.util.Map\u003cK,V\u003e\u003e)",
    "snippet": "public Adapter(Gson context,Type keyType,TypeAdapter\u003cK\u003e keyTypeAdapter,Type valueType,TypeAdapter\u003cV\u003e valueTypeAdapter,ObjectConstructor\u003c? extends Map\u003cK,V\u003e\u003e constructor){\n  this.keyTypeAdapter\u003dnew TypeAdapterRuntimeTypeWrapper\u003cK\u003e(context,keyTypeAdapter,keyType);\n  this.valueTypeAdapter\u003dnew TypeAdapterRuntimeTypeWrapper\u003cV\u003e(context,valueTypeAdapter,valueType);\n  this.constructor\u003dconstructor;\n}",
    "begin_line": 150,
    "end_line": 158,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.read#160",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Map\u003cK,V\u003e read(JsonReader in) throws IOException {\n  JsonToken peek\u003din.peek();\n  if (peek \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  Map\u003cK,V\u003e map\u003dconstructor.construct();\n  if (peek \u003d\u003d JsonToken.BEGIN_ARRAY) {\n    in.beginArray();\n    while (in.hasNext()) {\n      in.beginArray();\n      K key\u003dkeyTypeAdapter.read(in);\n      V value\u003dvalueTypeAdapter.read(in);\n      V replaced\u003dmap.put(key,value);\n      if (replaced !\u003d null) {\n        throw new JsonSyntaxException(\"duplicate key: \" + key);\n      }\n      in.endArray();\n    }\n    in.endArray();\n  }\n else {\n    in.beginObject();\n    while (in.hasNext()) {\n      JsonReaderInternalAccess.INSTANCE.promoteNameToValue(in);\n      K key\u003dkeyTypeAdapter.read(in);\n      V value\u003dvalueTypeAdapter.read(in);\n      V replaced\u003dmap.put(key,value);\n      if (replaced !\u003d null) {\n        throw new JsonSyntaxException(\"duplicate key: \" + key);\n      }\n    }\n    in.endObject();\n  }\n  return map;\n}",
    "begin_line": 160,
    "end_line": 196,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.write#198",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.write(com.google.gson.stream.JsonWriter, java.util.Map\u003cK,V\u003e)",
    "snippet": "@Override public void write(JsonWriter out,Map\u003cK,V\u003e map) throws IOException {\n  if (map \u003d\u003d null) {\n    out.nullValue();\n    return;\n  }\n  if (!complexMapKeySerialization) {\n    out.beginObject();\n    for (    Map.Entry\u003cK,V\u003e entry : map.entrySet()) {\n      out.name(String.valueOf(entry.getKey()));\n      valueTypeAdapter.write(out,entry.getValue());\n    }\n    out.endObject();\n    return;\n  }\n  boolean hasComplexKeys\u003dfalse;\n  List\u003cJsonElement\u003e keys\u003dnew ArrayList\u003cJsonElement\u003e(map.size());\n  List\u003cV\u003e values\u003dnew ArrayList\u003cV\u003e(map.size());\n  for (  Map.Entry\u003cK,V\u003e entry : map.entrySet()) {\n    JsonElement keyElement\u003dkeyTypeAdapter.toJsonTree(entry.getKey());\n    keys.add(keyElement);\n    values.add(entry.getValue());\n    hasComplexKeys|\u003dkeyElement.isJsonArray() || keyElement.isJsonObject();\n  }\n  if (hasComplexKeys) {\n    out.beginArray();\n    for (int i\u003d0; i \u003c keys.size(); i++) {\n      out.beginArray();\n      Streams.write(keys.get(i),out);\n      valueTypeAdapter.write(out,values.get(i));\n      out.endArray();\n    }\n    out.endArray();\n  }\n else {\n    out.beginObject();\n    for (int i\u003d0; i \u003c keys.size(); i++) {\n      JsonElement keyElement\u003dkeys.get(i);\n      out.name(keyToString(keyElement));\n      valueTypeAdapter.write(out,values.get(i));\n    }\n    out.endObject();\n  }\n}",
    "begin_line": 198,
    "end_line": 243,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.keyToString#245",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/MapTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.MapTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.MapTypeAdapterFactory.keyToString(com.google.gson.JsonElement)",
    "snippet": "private String keyToString(JsonElement keyElement){\n  if (keyElement.isJsonPrimitive()) {\n    JsonPrimitive primitive\u003dkeyElement.getAsJsonPrimitive();\n    if (primitive.isNumber()) {\n      return String.valueOf(primitive.getAsNumber());\n    }\n else     if (primitive.isBoolean()) {\n      return Boolean.toString(primitive.getAsBoolean());\n    }\n else     if (primitive.isString()) {\n      return primitive.getAsString();\n    }\n else {\n      throw new AssertionError();\n    }\n  }\n else   if (keyElement.isJsonNull()) {\n    return \"null\";\n  }\n else {\n    throw new AssertionError();\n  }\n}",
    "begin_line": 245,
    "end_line": 262,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectTypeAdapter.create#40",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ObjectTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ObjectTypeAdapter",
    "signature": "com.google.gson.internal.bind.ObjectTypeAdapter.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e type){\n  if (type.getRawType() \u003d\u003d Object.class) {\n    return (TypeAdapter\u003cT\u003e)new ObjectTypeAdapter(gson);\n  }\n  return null;\n}",
    "begin_line": 40,
    "end_line": 45,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectTypeAdapter.ObjectTypeAdapter#50",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ObjectTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ObjectTypeAdapter",
    "signature": "com.google.gson.internal.bind.ObjectTypeAdapter.ObjectTypeAdapter(com.google.gson.Gson)",
    "snippet": "ObjectTypeAdapter(Gson gson){\n  this.gson\u003dgson;\n}",
    "begin_line": 50,
    "end_line": 52,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectTypeAdapter.read#54",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ObjectTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ObjectTypeAdapter",
    "signature": "com.google.gson.internal.bind.ObjectTypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Object read(JsonReader in) throws IOException {\n  JsonToken token\u003din.peek();\nswitch (token) {\ncase BEGIN_ARRAY:    List\u003cObject\u003e list\u003dnew ArrayList\u003cObject\u003e();\n  in.beginArray();\nwhile (in.hasNext()) {\n  list.add(read(in));\n}\nin.endArray();\nreturn list;\ncase BEGIN_OBJECT:Map\u003cString,Object\u003e map\u003dnew LinkedTreeMap\u003cString,Object\u003e();\nin.beginObject();\nwhile (in.hasNext()) {\nmap.put(in.nextName(),read(in));\n}\nin.endObject();\nreturn map;\ncase STRING:return in.nextString();\ncase NUMBER:return in.nextDouble();\ncase BOOLEAN:return in.nextBoolean();\ncase NULL:in.nextNull();\nreturn null;\ndefault:throw new IllegalStateException();\n}\n}",
    "begin_line": 54,
    "end_line": 91,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ObjectTypeAdapter.write#94",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ObjectTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.ObjectTypeAdapter",
    "signature": "com.google.gson.internal.bind.ObjectTypeAdapter.write(com.google.gson.stream.JsonWriter, java.lang.Object)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public void write(JsonWriter out,Object value) throws IOException {\n  if (value \u003d\u003d null) {\n    out.nullValue();\n    return;\n  }\n  TypeAdapter\u003cObject\u003e typeAdapter\u003d(TypeAdapter\u003cObject\u003e)gson.getAdapter(value.getClass());\n  if (typeAdapter instanceof ObjectTypeAdapter) {\n    out.beginObject();\n    out.endObject();\n    return;\n  }\n  typeAdapter.write(out,value);\n}",
    "begin_line": 94,
    "end_line": 108,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.ReflectiveTypeAdapterFactory#53",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.ReflectiveTypeAdapterFactory(com.google.gson.internal.ConstructorConstructor, com.google.gson.FieldNamingStrategy, com.google.gson.internal.Excluder)",
    "snippet": "public ReflectiveTypeAdapterFactory(ConstructorConstructor constructorConstructor,FieldNamingStrategy fieldNamingPolicy,Excluder excluder){\n  this.constructorConstructor\u003dconstructorConstructor;\n  this.fieldNamingPolicy\u003dfieldNamingPolicy;\n  this.excluder\u003dexcluder;\n}",
    "begin_line": 53,
    "end_line": 58,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.excludeField#60",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.excludeField(java.lang.reflect.Field, boolean)",
    "snippet": "public boolean excludeField(Field f,boolean serialize){\n  return excludeField(f,serialize,excluder);\n}",
    "begin_line": 60,
    "end_line": 62,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.excludeField#64",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.excludeField(java.lang.reflect.Field, boolean, com.google.gson.internal.Excluder)",
    "snippet": "static boolean excludeField(Field f,boolean serialize,Excluder excluder){\n  return !excluder.excludeClass(f.getType(),serialize) \u0026\u0026 !excluder.excludeField(f,serialize);\n}",
    "begin_line": 64,
    "end_line": 66,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.getFieldNames#69",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.getFieldNames(java.lang.reflect.Field)",
    "snippet": "private List\u003cString\u003e getFieldNames(Field f){\n  return getFieldName(fieldNamingPolicy,f);\n}",
    "begin_line": 69,
    "end_line": 71,
    "comment": "/** \n * first element holds the default name \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.getFieldName#74",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.getFieldName(com.google.gson.FieldNamingStrategy, java.lang.reflect.Field)",
    "snippet": "static List\u003cString\u003e getFieldName(FieldNamingStrategy fieldNamingPolicy,Field f){\n  SerializedName serializedName\u003df.getAnnotation(SerializedName.class);\n  List\u003cString\u003e fieldNames\u003dnew LinkedList\u003cString\u003e();\n  if (serializedName \u003d\u003d null) {\n    fieldNames.add(fieldNamingPolicy.translateName(f));\n  }\n else {\n    fieldNames.add(serializedName.value());\n    for (    String alternate : serializedName.alternate()) {\n      fieldNames.add(alternate);\n    }\n  }\n  return fieldNames;\n}",
    "begin_line": 74,
    "end_line": 86,
    "comment": "/** \n * first element holds the default name \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.create#88",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,final TypeToken\u003cT\u003e type){\n  Class\u003c? super T\u003e raw\u003dtype.getRawType();\n  if (!Object.class.isAssignableFrom(raw)) {\n    return null;\n  }\n  ObjectConstructor\u003cT\u003e constructor\u003dconstructorConstructor.get(type);\n  return new Adapter\u003cT\u003e(constructor,getBoundFields(gson,type,raw));\n}",
    "begin_line": 88,
    "end_line": 97,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.createBoundField#99",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.createBoundField(com.google.gson.Gson, java.lang.reflect.Field, java.lang.String, com.google.gson.reflect.TypeToken\u003c?\u003e, boolean, boolean)",
    "snippet": "private ReflectiveTypeAdapterFactory.BoundField createBoundField(final Gson context,final Field field,final String name,final TypeToken\u003c?\u003e fieldType,boolean serialize,boolean deserialize){\n  final boolean isPrimitive\u003dPrimitives.isPrimitive(fieldType.getRawType());\n  return new ReflectiveTypeAdapterFactory.BoundField(name,serialize,deserialize){\n    final TypeAdapter\u003c?\u003e typeAdapter\u003dgetFieldAdapter(context,field,fieldType);\n    @SuppressWarnings({\"unchecked\",\"rawtypes\"}) @Override void write(    JsonWriter writer,    Object value) throws IOException, IllegalAccessException {\n      Object fieldValue\u003dfield.get(value);\n      TypeAdapter t\u003dnew TypeAdapterRuntimeTypeWrapper(context,this.typeAdapter,fieldType.getType());\n      t.write(writer,fieldValue);\n    }\n    @Override void read(    JsonReader reader,    Object value) throws IOException, IllegalAccessException {\n      Object fieldValue\u003dtypeAdapter.read(reader);\n      if (fieldValue !\u003d null || !isPrimitive) {\n        field.set(value,fieldValue);\n      }\n    }\n    @Override public boolean writeField(    Object value) throws IOException, IllegalAccessException {\n      if (!serialized)       return false;\n      Object fieldValue\u003dfield.get(value);\n      return fieldValue !\u003d value;\n    }\n  }\n;\n}",
    "begin_line": 99,
    "end_line": 127,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.write#107",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.write(com.google.gson.stream.JsonWriter, java.lang.Object)",
    "snippet": "@SuppressWarnings({\"unchecked\",\"rawtypes\"}) @Override void write(JsonWriter writer,Object value) throws IOException, IllegalAccessException {\n  Object fieldValue\u003dfield.get(value);\n  TypeAdapter t\u003dnew TypeAdapterRuntimeTypeWrapper(context,this.typeAdapter,fieldType.getType());\n  t.write(writer,fieldValue);\n}",
    "begin_line": 107,
    "end_line": 113,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.read#114",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.read(com.google.gson.stream.JsonReader, java.lang.Object)",
    "snippet": "@Override void read(JsonReader reader,Object value) throws IOException, IllegalAccessException {\n  Object fieldValue\u003dtypeAdapter.read(reader);\n  if (fieldValue !\u003d null || !isPrimitive) {\n    field.set(value,fieldValue);\n  }\n}",
    "begin_line": 114,
    "end_line": 120,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.writeField#121",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.writeField(java.lang.Object)",
    "snippet": "@Override public boolean writeField(Object value) throws IOException, IllegalAccessException {\n  if (!serialized)   return false;\n  Object fieldValue\u003dfield.get(value);\n  return fieldValue !\u003d value;\n}",
    "begin_line": 121,
    "end_line": 125,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.getFieldAdapter#129",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.getFieldAdapter(com.google.gson.Gson, java.lang.reflect.Field, com.google.gson.reflect.TypeToken\u003c?\u003e)",
    "snippet": "TypeAdapter\u003c?\u003e getFieldAdapter(Gson gson,Field field,TypeToken\u003c?\u003e fieldType){\n  JsonAdapter annotation\u003dfield.getAnnotation(JsonAdapter.class);\n  if (annotation !\u003d null) {\n    TypeAdapter\u003c?\u003e adapter\u003dgetTypeAdapter(constructorConstructor,gson,fieldType,annotation);\n    if (adapter !\u003d null)     return adapter;\n  }\n  return gson.getAdapter(fieldType);\n}",
    "begin_line": 129,
    "end_line": 136,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "ReflectiveTypeAdapterFactory.getBoundFields#138",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.getBoundFields(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003c?\u003e, java.lang.Class\u003c?\u003e)",
    "snippet": "private Map\u003cString,BoundField\u003e getBoundFields(Gson context,TypeToken\u003c?\u003e type,Class\u003c?\u003e raw){\n  Map\u003cString,BoundField\u003e result\u003dnew LinkedHashMap\u003cString,BoundField\u003e();\n  if (raw.isInterface()) {\n    return result;\n  }\n  Type declaredType\u003dtype.getType();\n  while (raw !\u003d Object.class) {\n    Field[] fields\u003draw.getDeclaredFields();\n    for (    Field field : fields) {\n      boolean serialize\u003dexcludeField(field,true);\n      boolean deserialize\u003dexcludeField(field,false);\n      if (!serialize \u0026\u0026 !deserialize) {\n        continue;\n      }\n      field.setAccessible(true);\n      Type fieldType\u003d$Gson$Types.resolve(type.getType(),raw,field.getGenericType());\n      List\u003cString\u003e fieldNames\u003dgetFieldNames(field);\n      BoundField previous\u003dnull;\n      for (int i\u003d0; i \u003c fieldNames.size(); ++i) {\n        String name\u003dfieldNames.get(i);\n        if (i !\u003d 0)         serialize\u003dfalse;\n        BoundField boundField\u003dcreateBoundField(context,field,name,TypeToken.get(fieldType),serialize,deserialize);\n        BoundField replaced\u003dresult.put(name,boundField);\n        if (previous \u003d\u003d null)         previous\u003dreplaced;\n      }\n      if (previous !\u003d null) {\n        throw new IllegalArgumentException(declaredType + \" declares multiple JSON fields named \" + previous.name);\n      }\n    }\n    type\u003dTypeToken.get($Gson$Types.resolve(type.getType(),raw,raw.getGenericSuperclass()));\n    raw\u003dtype.getRawType();\n  }\n  return result;\n}",
    "begin_line": 138,
    "end_line": 174,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundField.BoundField#181",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField(java.lang.String, boolean, boolean)",
    "snippet": "protected BoundField(String name,boolean serialized,boolean deserialized){\n  this.name\u003dname;\n  this.serialized\u003dserialized;\n  this.deserialized\u003ddeserialized;\n}",
    "begin_line": 181,
    "end_line": 185,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundField.writeField#186",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.writeField(java.lang.Object)",
    "snippet": "abstract boolean writeField(Object value) throws IOException, IllegalAccessException ;",
    "begin_line": 186,
    "end_line": 186,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundField.write#187",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.write(com.google.gson.stream.JsonWriter, java.lang.Object)",
    "snippet": "abstract void write(JsonWriter writer,Object value) throws IOException, IllegalAccessException ;",
    "begin_line": 187,
    "end_line": 187,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundField.read#188",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.read(com.google.gson.stream.JsonReader, java.lang.Object)",
    "snippet": "abstract void read(JsonReader reader,Object value) throws IOException, IllegalAccessException ;",
    "begin_line": 188,
    "end_line": 188,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.Adapter#195",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.Adapter(com.google.gson.internal.ObjectConstructor\u003cT\u003e, java.util.Map\u003cjava.lang.String,com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.BoundField\u003e)",
    "snippet": "Adapter(ObjectConstructor\u003cT\u003e constructor,Map\u003cString,BoundField\u003e boundFields){\n  this.constructor\u003dconstructor;\n  this.boundFields\u003dboundFields;\n}",
    "begin_line": 195,
    "end_line": 198,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.read#200",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public T read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  T instance\u003dconstructor.construct();\n  try {\n    in.beginObject();\n    while (in.hasNext()) {\n      String name\u003din.nextName();\n      BoundField field\u003dboundFields.get(name);\n      if (field \u003d\u003d null || !field.deserialized) {\n        in.skipValue();\n      }\n else {\n        field.read(in,instance);\n      }\n    }\n  }\n catch (  IllegalStateException e) {\n    throw new JsonSyntaxException(e);\n  }\ncatch (  IllegalAccessException e) {\n    throw new AssertionError(e);\n  }\n  in.endObject();\n  return instance;\n}",
    "begin_line": 200,
    "end_line": 226,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Adapter.write#228",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/ReflectiveTypeAdapterFactory.java",
    "class_name": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory",
    "signature": "com.google.gson.internal.bind.ReflectiveTypeAdapterFactory.write(com.google.gson.stream.JsonWriter, T)",
    "snippet": "@Override public void write(JsonWriter out,T value) throws IOException {\n  if (value \u003d\u003d null) {\n    out.nullValue();\n    return;\n  }\n  out.beginObject();\n  try {\n    for (    BoundField boundField : boundFields.values()) {\n      if (boundField.writeField(value)) {\n        out.name(boundField.name);\n        boundField.write(out,value);\n      }\n    }\n  }\n catch (  IllegalAccessException e) {\n    throw new AssertionError(e);\n  }\n  out.endObject();\n}",
    "begin_line": 228,
    "end_line": 246,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SqlDateTypeAdapter.create#41",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/SqlDateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.SqlDateTypeAdapter",
    "signature": "com.google.gson.internal.bind.SqlDateTypeAdapter.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e typeToken){\n  return typeToken.getRawType() \u003d\u003d java.sql.Date.class ? (TypeAdapter\u003cT\u003e)new SqlDateTypeAdapter() : null;\n}",
    "begin_line": 41,
    "end_line": 44,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SqlDateTypeAdapter.read#50",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/SqlDateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.SqlDateTypeAdapter",
    "signature": "com.google.gson.internal.bind.SqlDateTypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public synchronized java.sql.Date read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  try {\n    final long utilDate\u003dformat.parse(in.nextString()).getTime();\n    return new java.sql.Date(utilDate);\n  }\n catch (  ParseException e) {\n    throw new JsonSyntaxException(e);\n  }\n}",
    "begin_line": 50,
    "end_line": 61,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SqlDateTypeAdapter.write#64",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/SqlDateTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.SqlDateTypeAdapter",
    "signature": "com.google.gson.internal.bind.SqlDateTypeAdapter.write(com.google.gson.stream.JsonWriter, java.sql.Date)",
    "snippet": "@Override public synchronized void write(JsonWriter out,java.sql.Date value) throws IOException {\n  out.value(value \u003d\u003d null ? null : format.format(value));\n}",
    "begin_line": 64,
    "end_line": 66,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TimeTypeAdapter.create#43",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TimeTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.TimeTypeAdapter",
    "signature": "com.google.gson.internal.bind.TimeTypeAdapter.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e typeToken){\n  return typeToken.getRawType() \u003d\u003d Time.class ? (TypeAdapter\u003cT\u003e)new TimeTypeAdapter() : null;\n}",
    "begin_line": 43,
    "end_line": 45,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TimeTypeAdapter.read#50",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TimeTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.TimeTypeAdapter",
    "signature": "com.google.gson.internal.bind.TimeTypeAdapter.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public synchronized Time read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  try {\n    Date date\u003dformat.parse(in.nextString());\n    return new Time(date.getTime());\n  }\n catch (  ParseException e) {\n    throw new JsonSyntaxException(e);\n  }\n}",
    "begin_line": 50,
    "end_line": 61,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TimeTypeAdapter.write#63",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TimeTypeAdapter.java",
    "class_name": "com.google.gson.internal.bind.TimeTypeAdapter",
    "signature": "com.google.gson.internal.bind.TimeTypeAdapter.write(com.google.gson.stream.JsonWriter, java.sql.Time)",
    "snippet": "@Override public synchronized void write(JsonWriter out,Time value) throws IOException {\n  out.value(value \u003d\u003d null ? null : format.format(value));\n}",
    "begin_line": 63,
    "end_line": 65,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.TypeAdapters#64",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.TypeAdapters()",
    "snippet": "private TypeAdapters(){\n  throw new UnsupportedOperationException();\n}",
    "begin_line": 64,
    "end_line": 66,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#71",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Class)",
    "snippet": "@Override public void write(JsonWriter out,Class value) throws IOException {\n  if (value \u003d\u003d null) {\n    out.nullValue();\n  }\n else {\n    throw new UnsupportedOperationException(\"Attempted to serialize java.lang.Class: \" + value.getName() + \". Forgot to register a type adapter?\");\n  }\n}",
    "begin_line": 71,
    "end_line": 78,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#80",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Class read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n else {\n    throw new UnsupportedOperationException(\"Attempted to deserialize a java.lang.Class. Forgot to register a type adapter?\");\n  }\n}",
    "begin_line": 80,
    "end_line": 88,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#93",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public BitSet read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  BitSet bitset\u003dnew BitSet();\n  in.beginArray();\n  int i\u003d0;\n  JsonToken tokenType\u003din.peek();\n  while (tokenType !\u003d JsonToken.END_ARRAY) {\n    boolean set;\nswitch (tokenType) {\ncase NUMBER:      set\u003din.nextInt() !\u003d 0;\n    break;\ncase BOOLEAN:  set\u003din.nextBoolean();\nbreak;\ncase STRING:String stringValue\u003din.nextString();\ntry {\nset\u003dInteger.parseInt(stringValue) !\u003d 0;\n}\n catch (NumberFormatException e) {\nthrow new JsonSyntaxException(\"Error: Expecting: bitset number value (1, 0), Found: \" + stringValue);\n}\nbreak;\ndefault:throw new JsonSyntaxException(\"Invalid bitset value type: \" + tokenType);\n}\nif (set) {\nbitset.set(i);\n}\n++i;\ntokenType\u003din.peek();\n}\nin.endArray();\nreturn bitset;\n}",
    "begin_line": 93,
    "end_line": 132,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#134",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.BitSet)",
    "snippet": "@Override public void write(JsonWriter out,BitSet src) throws IOException {\n  if (src \u003d\u003d null) {\n    out.nullValue();\n    return;\n  }\n  out.beginArray();\n  for (int i\u003d0; i \u003c src.length(); i++) {\n    int value\u003d(src.get(i)) ? 1 : 0;\n    out.value(value);\n  }\n  out.endArray();\n}",
    "begin_line": 134,
    "end_line": 146,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#153",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Boolean read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n else   if (in.peek() \u003d\u003d JsonToken.STRING) {\n    return Boolean.parseBoolean(in.nextString());\n  }\n  return in.nextBoolean();\n}",
    "begin_line": 153,
    "end_line": 162,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#164",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Boolean)",
    "snippet": "@Override public void write(JsonWriter out,Boolean value) throws IOException {\n  if (value \u003d\u003d null) {\n    out.nullValue();\n    return;\n  }\n  out.value(value);\n}",
    "begin_line": 164,
    "end_line": 170,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#178",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Boolean read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  return Boolean.valueOf(in.nextString());\n}",
    "begin_line": 178,
    "end_line": 184,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#186",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Boolean)",
    "snippet": "@Override public void write(JsonWriter out,Boolean value) throws IOException {\n  out.value(value \u003d\u003d null ? \"null\" : value.toString());\n}",
    "begin_line": 186,
    "end_line": 188,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#196",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Number read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  try {\n    int intValue\u003din.nextInt();\n    return (byte)intValue;\n  }\n catch (  NumberFormatException e) {\n    throw new JsonSyntaxException(e);\n  }\n}",
    "begin_line": 196,
    "end_line": 207,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#209",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out,Number value) throws IOException {\n  out.value(value);\n}",
    "begin_line": 209,
    "end_line": 211,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#219",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Number read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  try {\n    return (short)in.nextInt();\n  }\n catch (  NumberFormatException e) {\n    throw new JsonSyntaxException(e);\n  }\n}",
    "begin_line": 219,
    "end_line": 229,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#231",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out,Number value) throws IOException {\n  out.value(value);\n}",
    "begin_line": 231,
    "end_line": 233,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#241",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Number read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  try {\n    return in.nextInt();\n  }\n catch (  NumberFormatException e) {\n    throw new JsonSyntaxException(e);\n  }\n}",
    "begin_line": 241,
    "end_line": 251,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#253",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out,Number value) throws IOException {\n  out.value(value);\n}",
    "begin_line": 253,
    "end_line": 255,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#261",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public AtomicInteger read(JsonReader in) throws IOException {\n  try {\n    return new AtomicInteger(in.nextInt());\n  }\n catch (  NumberFormatException e) {\n    throw new JsonSyntaxException(e);\n  }\n}",
    "begin_line": 261,
    "end_line": 267,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#268",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicInteger)",
    "snippet": "@Override public void write(JsonWriter out,AtomicInteger value) throws IOException {\n  out.value(value.get());\n}",
    "begin_line": 268,
    "end_line": 270,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#276",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public AtomicBoolean read(JsonReader in) throws IOException {\n  return new AtomicBoolean(in.nextBoolean());\n}",
    "begin_line": 276,
    "end_line": 278,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#279",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicBoolean)",
    "snippet": "@Override public void write(JsonWriter out,AtomicBoolean value) throws IOException {\n  out.value(value.get());\n}",
    "begin_line": 279,
    "end_line": 281,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#287",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public AtomicIntegerArray read(JsonReader in) throws IOException {\n  List\u003cInteger\u003e list\u003dnew ArrayList\u003cInteger\u003e();\n  in.beginArray();\n  while (in.hasNext()) {\n    try {\n      int integer\u003din.nextInt();\n      list.add(integer);\n    }\n catch (    NumberFormatException e) {\n      throw new JsonSyntaxException(e);\n    }\n  }\n  in.endArray();\n  int length\u003dlist.size();\n  AtomicIntegerArray array\u003dnew AtomicIntegerArray(length);\n  for (int i\u003d0; i \u003c length; ++i) {\n    array.set(i,list.get(i));\n  }\n  return array;\n}",
    "begin_line": 287,
    "end_line": 305,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#306",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.concurrent.atomic.AtomicIntegerArray)",
    "snippet": "@Override public void write(JsonWriter out,AtomicIntegerArray value) throws IOException {\n  out.beginArray();\n  for (int i\u003d0, length\u003dvalue.length(); i \u003c length; i++) {\n    out.value(value.get(i));\n  }\n  out.endArray();\n}",
    "begin_line": 306,
    "end_line": 312,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#319",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Number read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  try {\n    return in.nextLong();\n  }\n catch (  NumberFormatException e) {\n    throw new JsonSyntaxException(e);\n  }\n}",
    "begin_line": 319,
    "end_line": 329,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#331",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out,Number value) throws IOException {\n  out.value(value);\n}",
    "begin_line": 331,
    "end_line": 333,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#338",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Number read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  return (float)in.nextDouble();\n}",
    "begin_line": 338,
    "end_line": 344,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#346",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out,Number value) throws IOException {\n  out.value(value);\n}",
    "begin_line": 346,
    "end_line": 348,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#353",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Number read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  return in.nextDouble();\n}",
    "begin_line": 353,
    "end_line": 359,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#361",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out,Number value) throws IOException {\n  out.value(value);\n}",
    "begin_line": 361,
    "end_line": 363,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#368",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Number read(JsonReader in) throws IOException {\n  JsonToken jsonToken\u003din.peek();\nswitch (jsonToken) {\ncase NULL:    in.nextNull();\n  return null;\ncase NUMBER:return new LazilyParsedNumber(in.nextString());\ndefault:throw new JsonSyntaxException(\"Expecting number, got: \" + jsonToken);\n}\n}",
    "begin_line": 368,
    "end_line": 379,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#381",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Number)",
    "snippet": "@Override public void write(JsonWriter out,Number value) throws IOException {\n  out.value(value);\n}",
    "begin_line": 381,
    "end_line": 383,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#390",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Character read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  String str\u003din.nextString();\n  if (str.length() !\u003d 1) {\n    throw new JsonSyntaxException(\"Expecting character, got: \" + str);\n  }\n  return str.charAt(0);\n}",
    "begin_line": 390,
    "end_line": 400,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#402",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.Character)",
    "snippet": "@Override public void write(JsonWriter out,Character value) throws IOException {\n  out.value(value \u003d\u003d null ? null : String.valueOf(value));\n}",
    "begin_line": 402,
    "end_line": 404,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#412",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public String read(JsonReader in) throws IOException {\n  JsonToken peek\u003din.peek();\n  if (peek \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  if (peek \u003d\u003d JsonToken.BOOLEAN) {\n    return Boolean.toString(in.nextBoolean());\n  }\n  return in.nextString();\n}",
    "begin_line": 412,
    "end_line": 423,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#425",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.String)",
    "snippet": "@Override public void write(JsonWriter out,String value) throws IOException {\n  out.value(value);\n}",
    "begin_line": 425,
    "end_line": 427,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#431",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public BigDecimal read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  try {\n    return new BigDecimal(in.nextString());\n  }\n catch (  NumberFormatException e) {\n    throw new JsonSyntaxException(e);\n  }\n}",
    "begin_line": 431,
    "end_line": 441,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#443",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.math.BigDecimal)",
    "snippet": "@Override public void write(JsonWriter out,BigDecimal value) throws IOException {\n  out.value(value);\n}",
    "begin_line": 443,
    "end_line": 445,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#449",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public BigInteger read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  try {\n    return new BigInteger(in.nextString());\n  }\n catch (  NumberFormatException e) {\n    throw new JsonSyntaxException(e);\n  }\n}",
    "begin_line": 449,
    "end_line": 459,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#461",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.math.BigInteger)",
    "snippet": "@Override public void write(JsonWriter out,BigInteger value) throws IOException {\n  out.value(value);\n}",
    "begin_line": 461,
    "end_line": 463,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#470",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public StringBuilder read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  return new StringBuilder(in.nextString());\n}",
    "begin_line": 470,
    "end_line": 476,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#478",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.StringBuilder)",
    "snippet": "@Override public void write(JsonWriter out,StringBuilder value) throws IOException {\n  out.value(value \u003d\u003d null ? null : value.toString());\n}",
    "begin_line": 478,
    "end_line": 480,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#488",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public StringBuffer read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  return new StringBuffer(in.nextString());\n}",
    "begin_line": 488,
    "end_line": 494,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#496",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.lang.StringBuffer)",
    "snippet": "@Override public void write(JsonWriter out,StringBuffer value) throws IOException {\n  out.value(value \u003d\u003d null ? null : value.toString());\n}",
    "begin_line": 496,
    "end_line": 498,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#506",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public URL read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  String nextString\u003din.nextString();\n  return \"null\".equals(nextString) ? null : new URL(nextString);\n}",
    "begin_line": 506,
    "end_line": 513,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#515",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.net.URL)",
    "snippet": "@Override public void write(JsonWriter out,URL value) throws IOException {\n  out.value(value \u003d\u003d null ? null : value.toExternalForm());\n}",
    "begin_line": 515,
    "end_line": 517,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#524",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public URI read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  try {\n    String nextString\u003din.nextString();\n    return \"null\".equals(nextString) ? null : new URI(nextString);\n  }\n catch (  URISyntaxException e) {\n    throw new JsonIOException(e);\n  }\n}",
    "begin_line": 524,
    "end_line": 535,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#537",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.net.URI)",
    "snippet": "@Override public void write(JsonWriter out,URI value) throws IOException {\n  out.value(value \u003d\u003d null ? null : value.toASCIIString());\n}",
    "begin_line": 537,
    "end_line": 539,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#546",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public InetAddress read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  return InetAddress.getByName(in.nextString());\n}",
    "begin_line": 546,
    "end_line": 553,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#555",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.net.InetAddress)",
    "snippet": "@Override public void write(JsonWriter out,InetAddress value) throws IOException {\n  out.value(value \u003d\u003d null ? null : value.getHostAddress());\n}",
    "begin_line": 555,
    "end_line": 557,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#565",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public UUID read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  return java.util.UUID.fromString(in.nextString());\n}",
    "begin_line": 565,
    "end_line": 571,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#573",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.UUID)",
    "snippet": "@Override public void write(JsonWriter out,UUID value) throws IOException {\n  out.value(value \u003d\u003d null ? null : value.toString());\n}",
    "begin_line": 573,
    "end_line": 575,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#582",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Currency read(JsonReader in) throws IOException {\n  return Currency.getInstance(in.nextString());\n}",
    "begin_line": 582,
    "end_line": 584,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#586",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.Currency)",
    "snippet": "@Override public void write(JsonWriter out,Currency value) throws IOException {\n  out.value(value.getCurrencyCode());\n}",
    "begin_line": 586,
    "end_line": 588,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.create#594",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e typeToken){\n  if (typeToken.getRawType() !\u003d Timestamp.class) {\n    return null;\n  }\n  final TypeAdapter\u003cDate\u003e dateTypeAdapter\u003dgson.getAdapter(Date.class);\n  return (TypeAdapter\u003cT\u003e)new TypeAdapter\u003cTimestamp\u003e(){\n    @Override public Timestamp read(    JsonReader in) throws IOException {\n      Date date\u003ddateTypeAdapter.read(in);\n      return date !\u003d null ? new Timestamp(date.getTime()) : null;\n    }\n    @Override public void write(    JsonWriter out,    Timestamp value) throws IOException {\n      dateTypeAdapter.write(out,value);\n    }\n  }\n;\n}",
    "begin_line": 594,
    "end_line": 610,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#601",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Timestamp read(JsonReader in) throws IOException {\n  Date date\u003ddateTypeAdapter.read(in);\n  return date !\u003d null ? new Timestamp(date.getTime()) : null;\n}",
    "begin_line": 601,
    "end_line": 604,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#606",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.sql.Timestamp)",
    "snippet": "@Override public void write(JsonWriter out,Timestamp value) throws IOException {\n  dateTypeAdapter.write(out,value);\n}",
    "begin_line": 606,
    "end_line": 608,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#622",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Calendar read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  in.beginObject();\n  int year\u003d0;\n  int month\u003d0;\n  int dayOfMonth\u003d0;\n  int hourOfDay\u003d0;\n  int minute\u003d0;\n  int second\u003d0;\n  while (in.peek() !\u003d JsonToken.END_OBJECT) {\n    String name\u003din.nextName();\n    int value\u003din.nextInt();\n    if (YEAR.equals(name)) {\n      year\u003dvalue;\n    }\n else     if (MONTH.equals(name)) {\n      month\u003dvalue;\n    }\n else     if (DAY_OF_MONTH.equals(name)) {\n      dayOfMonth\u003dvalue;\n    }\n else     if (HOUR_OF_DAY.equals(name)) {\n      hourOfDay\u003dvalue;\n    }\n else     if (MINUTE.equals(name)) {\n      minute\u003dvalue;\n    }\n else     if (SECOND.equals(name)) {\n      second\u003dvalue;\n    }\n  }\n  in.endObject();\n  return new GregorianCalendar(year,month,dayOfMonth,hourOfDay,minute,second);\n}",
    "begin_line": 622,
    "end_line": 653,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#656",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.Calendar)",
    "snippet": "@Override public void write(JsonWriter out,Calendar value) throws IOException {\n  if (value \u003d\u003d null) {\n    out.nullValue();\n    return;\n  }\n  out.beginObject();\n  out.name(YEAR);\n  out.value(value.get(Calendar.YEAR));\n  out.name(MONTH);\n  out.value(value.get(Calendar.MONTH));\n  out.name(DAY_OF_MONTH);\n  out.value(value.get(Calendar.DAY_OF_MONTH));\n  out.name(HOUR_OF_DAY);\n  out.value(value.get(Calendar.HOUR_OF_DAY));\n  out.name(MINUTE);\n  out.value(value.get(Calendar.MINUTE));\n  out.name(SECOND);\n  out.value(value.get(Calendar.SECOND));\n  out.endObject();\n}",
    "begin_line": 656,
    "end_line": 675,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#683",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public Locale read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  String locale\u003din.nextString();\n  StringTokenizer tokenizer\u003dnew StringTokenizer(locale,\"_\");\n  String language\u003dnull;\n  String country\u003dnull;\n  String variant\u003dnull;\n  if (tokenizer.hasMoreElements()) {\n    language\u003dtokenizer.nextToken();\n  }\n  if (tokenizer.hasMoreElements()) {\n    country\u003dtokenizer.nextToken();\n  }\n  if (tokenizer.hasMoreElements()) {\n    variant\u003dtokenizer.nextToken();\n  }\n  if (country \u003d\u003d null \u0026\u0026 variant \u003d\u003d null) {\n    return new Locale(language);\n  }\n else   if (variant \u003d\u003d null) {\n    return new Locale(language,country);\n  }\n else {\n    return new Locale(language,country,variant);\n  }\n}",
    "begin_line": 683,
    "end_line": 709,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#711",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, java.util.Locale)",
    "snippet": "@Override public void write(JsonWriter out,Locale value) throws IOException {\n  out.value(value \u003d\u003d null ? null : value.toString());\n}",
    "begin_line": 711,
    "end_line": 713,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.read#719",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public JsonElement read(JsonReader in) throws IOException {\nswitch (in.peek()) {\ncase STRING:    return new JsonPrimitive(in.nextString());\ncase NUMBER:  String number\u003din.nextString();\nreturn new JsonPrimitive(new LazilyParsedNumber(number));\ncase BOOLEAN:return new JsonPrimitive(in.nextBoolean());\ncase NULL:in.nextNull();\nreturn JsonNull.INSTANCE;\ncase BEGIN_ARRAY:JsonArray array\u003dnew JsonArray();\nin.beginArray();\nwhile (in.hasNext()) {\narray.add(read(in));\n}\nin.endArray();\nreturn array;\ncase BEGIN_OBJECT:JsonObject object\u003dnew JsonObject();\nin.beginObject();\nwhile (in.hasNext()) {\nobject.add(in.nextName(),read(in));\n}\nin.endObject();\nreturn object;\ncase END_DOCUMENT:case NAME:case END_OBJECT:case END_ARRAY:default:throw new IllegalArgumentException();\n}\n}",
    "begin_line": 719,
    "end_line": 754,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeAdapters.write#756",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, com.google.gson.JsonElement)",
    "snippet": "@Override public void write(JsonWriter out,JsonElement value) throws IOException {\n  if (value \u003d\u003d null || value.isJsonNull()) {\n    out.nullValue();\n  }\n else   if (value.isJsonPrimitive()) {\n    JsonPrimitive primitive\u003dvalue.getAsJsonPrimitive();\n    if (primitive.isNumber()) {\n      out.value(primitive.getAsNumber());\n    }\n else     if (primitive.isBoolean()) {\n      out.value(primitive.getAsBoolean());\n    }\n else {\n      out.value(primitive.getAsString());\n    }\n  }\n else   if (value.isJsonArray()) {\n    out.beginArray();\n    for (    JsonElement e : value.getAsJsonArray()) {\n      write(out,e);\n    }\n    out.endArray();\n  }\n else   if (value.isJsonObject()) {\n    out.beginObject();\n    for (    Map.Entry\u003cString,JsonElement\u003e e : value.getAsJsonObject().entrySet()) {\n      out.name(e.getKey());\n      write(out,e.getValue());\n    }\n    out.endObject();\n  }\n else {\n    throw new IllegalArgumentException(\"Couldn\u0027t write \" + value.getClass());\n  }\n}",
    "begin_line": 756,
    "end_line": 787,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.EnumTypeAdapter#797",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.EnumTypeAdapter(java.lang.Class\u003cT\u003e)",
    "snippet": "public EnumTypeAdapter(Class\u003cT\u003e classOfT){\n  try {\n    for (    T constant : classOfT.getEnumConstants()) {\n      String name\u003dconstant.name();\n      SerializedName annotation\u003dclassOfT.getField(name).getAnnotation(SerializedName.class);\n      if (annotation !\u003d null) {\n        name\u003dannotation.value();\n        for (        String alternate : annotation.alternate()) {\n          nameToConstant.put(alternate,constant);\n        }\n      }\n      nameToConstant.put(name,constant);\n      constantToName.put(constant,name);\n    }\n  }\n catch (  NoSuchFieldException e) {\n    throw new AssertionError(\"Missing field in \" + classOfT.getName(),e);\n  }\n}",
    "begin_line": 797,
    "end_line": 814,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.read#815",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public T read(JsonReader in) throws IOException {\n  if (in.peek() \u003d\u003d JsonToken.NULL) {\n    in.nextNull();\n    return null;\n  }\n  return nameToConstant.get(in.nextString());\n}",
    "begin_line": 815,
    "end_line": 821,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.write#823",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, T)",
    "snippet": "@Override public void write(JsonWriter out,T value) throws IOException {\n  out.value(value \u003d\u003d null ? null : constantToName.get(value));\n}",
    "begin_line": 823,
    "end_line": 825,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.create#830",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings({\"rawtypes\",\"unchecked\"}) @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e typeToken){\n  Class\u003c? super T\u003e rawType\u003dtypeToken.getRawType();\n  if (!Enum.class.isAssignableFrom(rawType) || rawType \u003d\u003d Enum.class) {\n    return null;\n  }\n  if (!rawType.isEnum()) {\n    rawType\u003drawType.getSuperclass();\n  }\n  return (TypeAdapter\u003cT\u003e)new EnumTypeAdapter(rawType);\n}",
    "begin_line": 830,
    "end_line": 839,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.newFactory#842",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.newFactory(com.google.gson.reflect.TypeToken\u003cTT\u003e, com.google.gson.TypeAdapter\u003cTT\u003e)",
    "snippet": "public static \u003cTT\u003eTypeAdapterFactory newFactory(final TypeToken\u003cTT\u003e type,final TypeAdapter\u003cTT\u003e typeAdapter){\n  return new TypeAdapterFactory(){\n    @SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(    Gson gson,    TypeToken\u003cT\u003e typeToken){\n      return typeToken.equals(type) ? (TypeAdapter\u003cT\u003e)typeAdapter : null;\n    }\n  }\n;\n}",
    "begin_line": 842,
    "end_line": 850,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.create#846",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e typeToken){\n  return typeToken.equals(type) ? (TypeAdapter\u003cT\u003e)typeAdapter : null;\n}",
    "begin_line": 846,
    "end_line": 848,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.newFactory#852",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.newFactory(java.lang.Class\u003cTT\u003e, com.google.gson.TypeAdapter\u003cTT\u003e)",
    "snippet": "public static \u003cTT\u003eTypeAdapterFactory newFactory(final Class\u003cTT\u003e type,final TypeAdapter\u003cTT\u003e typeAdapter){\n  return new TypeAdapterFactory(){\n    @SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(    Gson gson,    TypeToken\u003cT\u003e typeToken){\n      return typeToken.getRawType() \u003d\u003d type ? (TypeAdapter\u003cT\u003e)typeAdapter : null;\n    }\n    @Override public String toString(){\n      return \"Factory[type\u003d\" + type.getName() + \",adapter\u003d\"+ typeAdapter+ \"]\";\n    }\n  }\n;\n}",
    "begin_line": 852,
    "end_line": 863,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.create#856",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e typeToken){\n  return typeToken.getRawType() \u003d\u003d type ? (TypeAdapter\u003cT\u003e)typeAdapter : null;\n}",
    "begin_line": 856,
    "end_line": 858,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.toString#859",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.toString()",
    "snippet": "@Override public String toString(){\n  return \"Factory[type\u003d\" + type.getName() + \",adapter\u003d\"+ typeAdapter+ \"]\";\n}",
    "begin_line": 859,
    "end_line": 861,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.newFactory#865",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.newFactory(java.lang.Class\u003cTT\u003e, java.lang.Class\u003cTT\u003e, com.google.gson.TypeAdapter\u003c? super TT\u003e)",
    "snippet": "public static \u003cTT\u003eTypeAdapterFactory newFactory(final Class\u003cTT\u003e unboxed,final Class\u003cTT\u003e boxed,final TypeAdapter\u003c? super TT\u003e typeAdapter){\n  return new TypeAdapterFactory(){\n    @SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(    Gson gson,    TypeToken\u003cT\u003e typeToken){\n      Class\u003c? super T\u003e rawType\u003dtypeToken.getRawType();\n      return (rawType \u003d\u003d unboxed || rawType \u003d\u003d boxed) ? (TypeAdapter\u003cT\u003e)typeAdapter : null;\n    }\n    @Override public String toString(){\n      return \"Factory[type\u003d\" + boxed.getName() + \"+\"+ unboxed.getName()+ \",adapter\u003d\"+ typeAdapter+ \"]\";\n    }\n  }\n;\n}",
    "begin_line": 865,
    "end_line": 878,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.create#869",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e typeToken){\n  Class\u003c? super T\u003e rawType\u003dtypeToken.getRawType();\n  return (rawType \u003d\u003d unboxed || rawType \u003d\u003d boxed) ? (TypeAdapter\u003cT\u003e)typeAdapter : null;\n}",
    "begin_line": 869,
    "end_line": 872,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.toString#873",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.toString()",
    "snippet": "@Override public String toString(){\n  return \"Factory[type\u003d\" + boxed.getName() + \"+\"+ unboxed.getName()+ \",adapter\u003d\"+ typeAdapter+ \"]\";\n}",
    "begin_line": 873,
    "end_line": 876,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.newFactoryForMultipleTypes#880",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.newFactoryForMultipleTypes(java.lang.Class\u003cTT\u003e, java.lang.Class\u003c? extends TT\u003e, com.google.gson.TypeAdapter\u003c? super TT\u003e)",
    "snippet": "public static \u003cTT\u003eTypeAdapterFactory newFactoryForMultipleTypes(final Class\u003cTT\u003e base,final Class\u003c? extends TT\u003e sub,final TypeAdapter\u003c? super TT\u003e typeAdapter){\n  return new TypeAdapterFactory(){\n    @SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(    Gson gson,    TypeToken\u003cT\u003e typeToken){\n      Class\u003c? super T\u003e rawType\u003dtypeToken.getRawType();\n      return (rawType \u003d\u003d base || rawType \u003d\u003d sub) ? (TypeAdapter\u003cT\u003e)typeAdapter : null;\n    }\n    @Override public String toString(){\n      return \"Factory[type\u003d\" + base.getName() + \"+\"+ sub.getName()+ \",adapter\u003d\"+ typeAdapter+ \"]\";\n    }\n  }\n;\n}",
    "begin_line": 880,
    "end_line": 893,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.create#884",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public \u003cT\u003eTypeAdapter\u003cT\u003e create(Gson gson,TypeToken\u003cT\u003e typeToken){\n  Class\u003c? super T\u003e rawType\u003dtypeToken.getRawType();\n  return (rawType \u003d\u003d base || rawType \u003d\u003d sub) ? (TypeAdapter\u003cT\u003e)typeAdapter : null;\n}",
    "begin_line": 884,
    "end_line": 887,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.toString#888",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.toString()",
    "snippet": "@Override public String toString(){\n  return \"Factory[type\u003d\" + base.getName() + \"+\"+ sub.getName()+ \",adapter\u003d\"+ typeAdapter+ \"]\";\n}",
    "begin_line": 888,
    "end_line": 891,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.newTypeHierarchyFactory#899",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.newTypeHierarchyFactory(java.lang.Class\u003cT1\u003e, com.google.gson.TypeAdapter\u003cT1\u003e)",
    "snippet": "public static \u003cT1\u003eTypeAdapterFactory newTypeHierarchyFactory(final Class\u003cT1\u003e clazz,final TypeAdapter\u003cT1\u003e typeAdapter){\n  return new TypeAdapterFactory(){\n    @SuppressWarnings(\"unchecked\") @Override public \u003cT2\u003eTypeAdapter\u003cT2\u003e create(    Gson gson,    TypeToken\u003cT2\u003e typeToken){\n      final Class\u003c? super T2\u003e requestedType\u003dtypeToken.getRawType();\n      if (!clazz.isAssignableFrom(requestedType)) {\n        return null;\n      }\n      return (TypeAdapter\u003cT2\u003e)new TypeAdapter\u003cT1\u003e(){\n        @Override public void write(        JsonWriter out,        T1 value) throws IOException {\n          typeAdapter.write(out,value);\n        }\n        @Override public T1 read(        JsonReader in) throws IOException {\n          T1 result\u003dtypeAdapter.read(in);\n          if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\n            throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \"+ result.getClass().getName());\n          }\n          return result;\n        }\n      }\n;\n    }\n    @Override public String toString(){\n      return \"Factory[typeHierarchy\u003d\" + clazz.getName() + \",adapter\u003d\"+ typeAdapter+ \"]\";\n    }\n  }\n;\n}",
    "begin_line": 899,
    "end_line": 927,
    "comment": "/** \n * Returns a factory for all subtypes of  {@code typeAdapter}. We do a runtime check to confirm that the deserialized type matches the type requested.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.create#903",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.create(com.google.gson.Gson, com.google.gson.reflect.TypeToken\u003cT2\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") @Override public \u003cT2\u003eTypeAdapter\u003cT2\u003e create(Gson gson,TypeToken\u003cT2\u003e typeToken){\n  final Class\u003c? super T2\u003e requestedType\u003dtypeToken.getRawType();\n  if (!clazz.isAssignableFrom(requestedType)) {\n    return null;\n  }\n  return (TypeAdapter\u003cT2\u003e)new TypeAdapter\u003cT1\u003e(){\n    @Override public void write(    JsonWriter out,    T1 value) throws IOException {\n      typeAdapter.write(out,value);\n    }\n    @Override public T1 read(    JsonReader in) throws IOException {\n      T1 result\u003dtypeAdapter.read(in);\n      if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\n        throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \"+ result.getClass().getName());\n      }\n      return result;\n    }\n  }\n;\n}",
    "begin_line": 903,
    "end_line": 922,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.write#909",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.write(com.google.gson.stream.JsonWriter, T1)",
    "snippet": "@Override public void write(JsonWriter out,T1 value) throws IOException {\n  typeAdapter.write(out,value);\n}",
    "begin_line": 909,
    "end_line": 911,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.read#913",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.read(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public T1 read(JsonReader in) throws IOException {\n  T1 result\u003dtypeAdapter.read(in);\n  if (result !\u003d null \u0026\u0026 !requestedType.isInstance(result)) {\n    throw new JsonSyntaxException(\"Expected a \" + requestedType.getName() + \" but was \"+ result.getClass().getName());\n  }\n  return result;\n}",
    "begin_line": 913,
    "end_line": 920,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EnumTypeAdapter.toString#923",
    "is_bug": true,
    "src_path": "com/google/gson/internal/bind/TypeAdapters.java",
    "class_name": "com.google.gson.internal.bind.TypeAdapters",
    "signature": "com.google.gson.internal.bind.TypeAdapters.toString()",
    "snippet": "@Override public String toString(){\n  return \"Factory[typeHierarchy\u003d\" + clazz.getName() + \",adapter\u003d\"+ typeAdapter+ \"]\";\n}",
    "begin_line": 923,
    "end_line": 925,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.TypeToken#61",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.TypeToken()",
    "snippet": "@SuppressWarnings(\"unchecked\") protected TypeToken(){\n  this.type\u003dgetSuperclassTypeParameter(getClass());\n  this.rawType\u003d(Class\u003c? super T\u003e)$Gson$Types.getRawType(type);\n  this.hashCode\u003dtype.hashCode();\n}",
    "begin_line": 61,
    "end_line": 65,
    "comment": "/** \n * Constructs a new type literal. Derives represented class from type parameter. \u003cp\u003eClients create an empty anonymous subclass. Doing so embeds the type parameter in the anonymous class\u0027s type hierarchy so we can reconstitute it at runtime despite erasure.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.TypeToken#71",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.TypeToken(java.lang.reflect.Type)",
    "snippet": "@SuppressWarnings(\"unchecked\") TypeToken(Type type){\n  this.type\u003d$Gson$Types.canonicalize($Gson$Preconditions.checkNotNull(type));\n  this.rawType\u003d(Class\u003c? super T\u003e)$Gson$Types.getRawType(this.type);\n  this.hashCode\u003dthis.type.hashCode();\n}",
    "begin_line": 71,
    "end_line": 75,
    "comment": "/** \n * Unsafe. Constructs a type literal manually.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.getSuperclassTypeParameter#81",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.getSuperclassTypeParameter(java.lang.Class\u003c?\u003e)",
    "snippet": "static Type getSuperclassTypeParameter(Class\u003c?\u003e subclass){\n  Type superclass\u003dsubclass.getGenericSuperclass();\n  if (superclass instanceof Class) {\n    throw new RuntimeException(\"Missing type parameter.\");\n  }\n  ParameterizedType parameterized\u003d(ParameterizedType)superclass;\n  return $Gson$Types.canonicalize(parameterized.getActualTypeArguments()[0]);\n}",
    "begin_line": 81,
    "end_line": 88,
    "comment": "/** \n * Returns the type from super class\u0027s type parameter in  {@link $Gson$Types#canonicalize canonical form}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.getRawType#93",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.getRawType()",
    "snippet": "public final Class\u003c? super T\u003e getRawType(){\n  return rawType;\n}",
    "begin_line": 93,
    "end_line": 95,
    "comment": "/** \n * Returns the raw (non-generic) type for this type.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.getType#100",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.getType()",
    "snippet": "public final Type getType(){\n  return type;\n}",
    "begin_line": 100,
    "end_line": 102,
    "comment": "/** \n * Gets underlying  {@code Type} instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.isAssignableFrom#111",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(java.lang.Class\u003c?\u003e)",
    "snippet": "@Deprecated public boolean isAssignableFrom(Class\u003c?\u003e cls){\n  return isAssignableFrom((Type)cls);\n}",
    "begin_line": 111,
    "end_line": 113,
    "comment": "/** \n * Check if this type is assignable from the given class object.\n * @deprecated this implementation may be inconsistent with javac for typeswith wildcards.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.isAssignableFrom#122",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(java.lang.reflect.Type)",
    "snippet": "@Deprecated public boolean isAssignableFrom(Type from){\n  if (from \u003d\u003d null) {\n    return false;\n  }\n  if (type.equals(from)) {\n    return true;\n  }\n  if (type instanceof Class\u003c?\u003e) {\n    return rawType.isAssignableFrom($Gson$Types.getRawType(from));\n  }\n else   if (type instanceof ParameterizedType) {\n    return isAssignableFrom(from,(ParameterizedType)type,new HashMap\u003cString,Type\u003e());\n  }\n else   if (type instanceof GenericArrayType) {\n    return rawType.isAssignableFrom($Gson$Types.getRawType(from)) \u0026\u0026 isAssignableFrom(from,(GenericArrayType)type);\n  }\n else {\n    throw buildUnexpectedTypeError(type,Class.class,ParameterizedType.class,GenericArrayType.class);\n  }\n}",
    "begin_line": 122,
    "end_line": 143,
    "comment": "/** \n * Check if this type is assignable from the given Type.\n * @deprecated this implementation may be inconsistent with javac for typeswith wildcards.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.isAssignableFrom#152",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(com.google.gson.reflect.TypeToken\u003c?\u003e)",
    "snippet": "@Deprecated public boolean isAssignableFrom(TypeToken\u003c?\u003e token){\n  return isAssignableFrom(token.getType());\n}",
    "begin_line": 152,
    "end_line": 154,
    "comment": "/** \n * Check if this type is assignable from the given type token.\n * @deprecated this implementation may be inconsistent with javac for typeswith wildcards.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.isAssignableFrom#160",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(java.lang.reflect.Type, java.lang.reflect.GenericArrayType)",
    "snippet": "private static boolean isAssignableFrom(Type from,GenericArrayType to){\n  Type toGenericComponentType\u003dto.getGenericComponentType();\n  if (toGenericComponentType instanceof ParameterizedType) {\n    Type t\u003dfrom;\n    if (from instanceof GenericArrayType) {\n      t\u003d((GenericArrayType)from).getGenericComponentType();\n    }\n else     if (from instanceof Class\u003c?\u003e) {\n      Class\u003c?\u003e classType\u003d(Class\u003c?\u003e)from;\n      while (classType.isArray()) {\n        classType\u003dclassType.getComponentType();\n      }\n      t\u003dclassType;\n    }\n    return isAssignableFrom(t,(ParameterizedType)toGenericComponentType,new HashMap\u003cString,Type\u003e());\n  }\n  return true;\n}",
    "begin_line": 160,
    "end_line": 179,
    "comment": "/** \n * Private helper function that performs some assignability checks for the provided GenericArrayType.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.isAssignableFrom#185",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.isAssignableFrom(java.lang.reflect.Type, java.lang.reflect.ParameterizedType, java.util.Map\u003cjava.lang.String,java.lang.reflect.Type\u003e)",
    "snippet": "private static boolean isAssignableFrom(Type from,ParameterizedType to,Map\u003cString,Type\u003e typeVarMap){\n  if (from \u003d\u003d null) {\n    return false;\n  }\n  if (to.equals(from)) {\n    return true;\n  }\n  Class\u003c?\u003e clazz\u003d$Gson$Types.getRawType(from);\n  ParameterizedType ptype\u003dnull;\n  if (from instanceof ParameterizedType) {\n    ptype\u003d(ParameterizedType)from;\n  }\n  if (ptype !\u003d null) {\n    Type[] tArgs\u003dptype.getActualTypeArguments();\n    TypeVariable\u003c?\u003e[] tParams\u003dclazz.getTypeParameters();\n    for (int i\u003d0; i \u003c tArgs.length; i++) {\n      Type arg\u003dtArgs[i];\n      TypeVariable\u003c?\u003e var\u003dtParams[i];\n      while (arg instanceof TypeVariable\u003c?\u003e) {\n        TypeVariable\u003c?\u003e v\u003d(TypeVariable\u003c?\u003e)arg;\n        arg\u003dtypeVarMap.get(v.getName());\n      }\n      typeVarMap.put(var.getName(),arg);\n    }\n    if (typeEquals(ptype,to,typeVarMap)) {\n      return true;\n    }\n  }\n  for (  Type itype : clazz.getGenericInterfaces()) {\n    if (isAssignableFrom(itype,to,new HashMap\u003cString,Type\u003e(typeVarMap))) {\n      return true;\n    }\n  }\n  Type sType\u003dclazz.getGenericSuperclass();\n  return isAssignableFrom(sType,to,new HashMap\u003cString,Type\u003e(typeVarMap));\n}",
    "begin_line": 185,
    "end_line": 232,
    "comment": "/** \n * Private recursive helper function to actually do the type-safe checking of assignability.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.typeEquals#238",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.typeEquals(java.lang.reflect.ParameterizedType, java.lang.reflect.ParameterizedType, java.util.Map\u003cjava.lang.String,java.lang.reflect.Type\u003e)",
    "snippet": "private static boolean typeEquals(ParameterizedType from,ParameterizedType to,Map\u003cString,Type\u003e typeVarMap){\n  if (from.getRawType().equals(to.getRawType())) {\n    Type[] fromArgs\u003dfrom.getActualTypeArguments();\n    Type[] toArgs\u003dto.getActualTypeArguments();\n    for (int i\u003d0; i \u003c fromArgs.length; i++) {\n      if (!matches(fromArgs[i],toArgs[i],typeVarMap)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  return false;\n}",
    "begin_line": 238,
    "end_line": 251,
    "comment": "/** \n * Checks if two parameterized types are exactly equal, under the variable replacement described in the typeVarMap.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.buildUnexpectedTypeError#253",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.buildUnexpectedTypeError(java.lang.reflect.Type, java.lang.Class\u003c?\u003e)",
    "snippet": "private static AssertionError buildUnexpectedTypeError(Type token,Class\u003c?\u003e... expected){\n  StringBuilder exceptionMessage\u003dnew StringBuilder(\"Unexpected type. Expected one of: \");\n  for (  Class\u003c?\u003e clazz : expected) {\n    exceptionMessage.append(clazz.getName()).append(\", \");\n  }\n  exceptionMessage.append(\"but got: \").append(token.getClass().getName()).append(\", for type token: \").append(token.toString()).append(\u0027.\u0027);\n  return new AssertionError(exceptionMessage.toString());\n}",
    "begin_line": 253,
    "end_line": 266,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.matches#272",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.matches(java.lang.reflect.Type, java.lang.reflect.Type, java.util.Map\u003cjava.lang.String,java.lang.reflect.Type\u003e)",
    "snippet": "private static boolean matches(Type from,Type to,Map\u003cString,Type\u003e typeMap){\n  return to.equals(from) || (from instanceof TypeVariable \u0026\u0026 to.equals(typeMap.get(((TypeVariable\u003c?\u003e)from).getName())));\n}",
    "begin_line": 272,
    "end_line": 277,
    "comment": "/** \n * Checks if two types are the same or are equivalent under a variable mapping given in the type map that was provided.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.hashCode#279",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.hashCode()",
    "snippet": "@Override public final int hashCode(){\n  return this.hashCode;\n}",
    "begin_line": 279,
    "end_line": 281,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.equals#283",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.equals(java.lang.Object)",
    "snippet": "@Override public final boolean equals(Object o){\n  return o instanceof TypeToken\u003c?\u003e \u0026\u0026 $Gson$Types.equals(type,((TypeToken\u003c?\u003e)o).type);\n}",
    "begin_line": 283,
    "end_line": 286,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.toString#288",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.toString()",
    "snippet": "@Override public final String toString(){\n  return $Gson$Types.typeToString(type);\n}",
    "begin_line": 288,
    "end_line": 290,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.get#295",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.get(java.lang.reflect.Type)",
    "snippet": "public static TypeToken\u003c?\u003e get(Type type){\n  return new TypeToken\u003cObject\u003e(type);\n}",
    "begin_line": 295,
    "end_line": 297,
    "comment": "/** \n * Gets type literal for the given  {@code Type} instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "TypeToken.get#302",
    "is_bug": true,
    "src_path": "com/google/gson/reflect/TypeToken.java",
    "class_name": "com.google.gson.reflect.TypeToken",
    "signature": "com.google.gson.reflect.TypeToken.get(java.lang.Class\u003cT\u003e)",
    "snippet": "public static \u003cT\u003eTypeToken\u003cT\u003e get(Class\u003cT\u003e type){\n  return new TypeToken\u003cT\u003e(type);\n}",
    "begin_line": 302,
    "end_line": 304,
    "comment": "/** \n * Gets type literal for the given  {@code Class} instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.JsonReader#289",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.JsonReader(java.io.Reader)",
    "snippet": "public JsonReader(Reader in){\n  if (in \u003d\u003d null) {\n    throw new NullPointerException(\"in \u003d\u003d null\");\n  }\n  this.in\u003din;\n}",
    "begin_line": 289,
    "end_line": 294,
    "comment": "/** \n * Creates a new instance that reads a JSON-encoded stream from  {@code in}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.setLenient#325",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.setLenient(boolean)",
    "snippet": "public final void setLenient(boolean lenient){\n  this.lenient\u003dlenient;\n}",
    "begin_line": 325,
    "end_line": 327,
    "comment": "/** \n * Configure this parser to be liberal in what it accepts. By default, this parser is strict and only accepts JSON as specified by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc4627.txt\"\u003eRFC 4627\u003c/a\u003e. Setting the parser to lenient causes it to ignore the following syntax errors: \u003cul\u003e \u003cli\u003eStreams that start with the \u003ca href\u003d\"#nonexecuteprefix\"\u003enon-execute prefix\u003c/a\u003e, \u003ccode\u003e\")]}\u0027\\n\"\u003c/code\u003e. \u003cli\u003eStreams that include multiple top-level values. With strict parsing, each stream must contain exactly one top-level value. \u003cli\u003eTop-level values of any type. With strict parsing, the top-level value must be an object or an array. \u003cli\u003eNumbers may be  {@link Double#isNaN() NaNs} or {@link Double#isInfinite() infinities}. \u003cli\u003eEnd of line comments starting with  {@code //} or {@code #} andending with a newline character. \u003cli\u003eC-style comments starting with  {@code /*} and ending with{@code *}{@code /}. Such comments may not be nested. \u003cli\u003eNames that are unquoted or  {@code \u0027single quoted\u0027}. \u003cli\u003eStrings that are unquoted or  {@code \u0027single quoted\u0027}. \u003cli\u003eArray elements separated by  {@code ;} instead of {@code ,}. \u003cli\u003eUnnecessary array separators. These are interpreted as if null was the omitted value. \u003cli\u003eNames and values separated by  {@code \u003d} or {@code \u003d\u003e} instead of{@code :}. \u003cli\u003eName/value pairs separated by  {@code ;} instead of {@code ,}. \u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.isLenient#332",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.isLenient()",
    "snippet": "public final boolean isLenient(){\n  return lenient;\n}",
    "begin_line": 332,
    "end_line": 334,
    "comment": "/** \n * Returns true if this parser is liberal in what it accepts.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.beginArray#340",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.beginArray()",
    "snippet": "public void beginArray() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\n  if (p \u003d\u003d PEEKED_BEGIN_ARRAY) {\n    push(JsonScope.EMPTY_ARRAY);\n    pathIndices[stackSize - 1]\u003d0;\n    peeked\u003dPEEKED_NONE;\n  }\n else {\n    throw new IllegalStateException(\"Expected BEGIN_ARRAY but was \" + peek() + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n}",
    "begin_line": 340,
    "end_line": 353,
    "comment": "/** \n * Consumes the next token from the JSON stream and asserts that it is the beginning of a new array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.endArray#359",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.endArray()",
    "snippet": "public void endArray() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\n  if (p \u003d\u003d PEEKED_END_ARRAY) {\n    stackSize--;\n    pathIndices[stackSize - 1]++;\n    peeked\u003dPEEKED_NONE;\n  }\n else {\n    throw new IllegalStateException(\"Expected END_ARRAY but was \" + peek() + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n}",
    "begin_line": 359,
    "end_line": 372,
    "comment": "/** \n * Consumes the next token from the JSON stream and asserts that it is the end of the current array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.beginObject#378",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.beginObject()",
    "snippet": "public void beginObject() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\n  if (p \u003d\u003d PEEKED_BEGIN_OBJECT) {\n    push(JsonScope.EMPTY_OBJECT);\n    peeked\u003dPEEKED_NONE;\n  }\n else {\n    throw new IllegalStateException(\"Expected BEGIN_OBJECT but was \" + peek() + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n}",
    "begin_line": 378,
    "end_line": 390,
    "comment": "/** \n * Consumes the next token from the JSON stream and asserts that it is the beginning of a new object.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.endObject#396",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.endObject()",
    "snippet": "public void endObject() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\n  if (p \u003d\u003d PEEKED_END_OBJECT) {\n    stackSize--;\n    pathNames[stackSize]\u003dnull;\n    pathIndices[stackSize - 1]++;\n    peeked\u003dPEEKED_NONE;\n  }\n else {\n    throw new IllegalStateException(\"Expected END_OBJECT but was \" + peek() + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n}",
    "begin_line": 396,
    "end_line": 410,
    "comment": "/** \n * Consumes the next token from the JSON stream and asserts that it is the end of the current object.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.hasNext#415",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.hasNext()",
    "snippet": "public boolean hasNext() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\n  return p !\u003d PEEKED_END_OBJECT \u0026\u0026 p !\u003d PEEKED_END_ARRAY;\n}",
    "begin_line": 415,
    "end_line": 421,
    "comment": "/** \n * Returns true if the current array or object has another element.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.peek#426",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.peek()",
    "snippet": "public JsonToken peek() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\nswitch (p) {\ncase PEEKED_BEGIN_OBJECT:    return JsonToken.BEGIN_OBJECT;\ncase PEEKED_END_OBJECT:  return JsonToken.END_OBJECT;\ncase PEEKED_BEGIN_ARRAY:return JsonToken.BEGIN_ARRAY;\ncase PEEKED_END_ARRAY:return JsonToken.END_ARRAY;\ncase PEEKED_SINGLE_QUOTED_NAME:case PEEKED_DOUBLE_QUOTED_NAME:case PEEKED_UNQUOTED_NAME:return JsonToken.NAME;\ncase PEEKED_TRUE:case PEEKED_FALSE:return JsonToken.BOOLEAN;\ncase PEEKED_NULL:return JsonToken.NULL;\ncase PEEKED_SINGLE_QUOTED:case PEEKED_DOUBLE_QUOTED:case PEEKED_UNQUOTED:case PEEKED_BUFFERED:return JsonToken.STRING;\ncase PEEKED_LONG:case PEEKED_NUMBER:return JsonToken.NUMBER;\ncase PEEKED_EOF:return JsonToken.END_DOCUMENT;\ndefault:throw new AssertionError();\n}\n}",
    "begin_line": 426,
    "end_line": 463,
    "comment": "/** \n * Returns the type of the next token without consuming it.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.doPeek#465",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.doPeek()",
    "snippet": "int doPeek() throws IOException {\n  int peekStack\u003dstack[stackSize - 1];\n  if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\n    stack[stackSize - 1]\u003dJsonScope.NONEMPTY_ARRAY;\n  }\n else   if (peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\n    int c\u003dnextNonWhitespace(true);\nswitch (c) {\ncase \u0027]\u0027:      return peeked\u003dPEEKED_END_ARRAY;\ncase \u0027;\u0027:    checkLenient();\ncase \u0027,\u0027:  break;\ndefault:throw syntaxError(\"Unterminated array\");\n}\n}\n else if (peekStack \u003d\u003d JsonScope.EMPTY_OBJECT || peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\nstack[stackSize - 1]\u003dJsonScope.DANGLING_NAME;\nif (peekStack \u003d\u003d JsonScope.NONEMPTY_OBJECT) {\nint c\u003dnextNonWhitespace(true);\nswitch (c) {\ncase \u0027}\u0027:return peeked\u003dPEEKED_END_OBJECT;\ncase \u0027;\u0027:checkLenient();\ncase \u0027,\u0027:break;\ndefault:throw syntaxError(\"Unterminated object\");\n}\n}\nint c\u003dnextNonWhitespace(true);\nswitch (c) {\ncase \u0027\"\u0027:return peeked\u003dPEEKED_DOUBLE_QUOTED_NAME;\ncase \u0027\\\u0027\u0027:checkLenient();\nreturn peeked\u003dPEEKED_SINGLE_QUOTED_NAME;\ncase \u0027}\u0027:if (peekStack !\u003d JsonScope.NONEMPTY_OBJECT) {\nreturn peeked\u003dPEEKED_END_OBJECT;\n}\n else {\nthrow syntaxError(\"Expected name\");\n}\ndefault:checkLenient();\npos--;\nif (isLiteral((char)c)) {\nreturn peeked\u003dPEEKED_UNQUOTED_NAME;\n}\n else {\nthrow syntaxError(\"Expected name\");\n}\n}\n}\n else if (peekStack \u003d\u003d JsonScope.DANGLING_NAME) {\nstack[stackSize - 1]\u003dJsonScope.NONEMPTY_OBJECT;\nint c\u003dnextNonWhitespace(true);\nswitch (c) {\ncase \u0027:\u0027:break;\ncase \u0027\u003d\u0027:checkLenient();\nif ((pos \u003c limit || fillBuffer(1)) \u0026\u0026 buffer[pos] \u003d\u003d \u0027\u003e\u0027) {\npos++;\n}\nbreak;\ndefault:throw syntaxError(\"Expected \u0027:\u0027\");\n}\n}\n else if (peekStack \u003d\u003d JsonScope.EMPTY_DOCUMENT) {\nif (lenient) {\nconsumeNonExecutePrefix();\n}\nstack[stackSize - 1]\u003dJsonScope.NONEMPTY_DOCUMENT;\n}\n else if (peekStack \u003d\u003d JsonScope.NONEMPTY_DOCUMENT) {\nint c\u003dnextNonWhitespace(false);\nif (c \u003d\u003d -1) {\nreturn peeked\u003dPEEKED_EOF;\n}\n else {\ncheckLenient();\npos--;\n}\n}\n else if (peekStack \u003d\u003d JsonScope.CLOSED) {\nthrow new IllegalStateException(\"JsonReader is closed\");\n}\nint c\u003dnextNonWhitespace(true);\nswitch (c) {\ncase \u0027]\u0027:if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY) {\nreturn peeked\u003dPEEKED_END_ARRAY;\n}\ncase \u0027;\u0027:case \u0027,\u0027:if (peekStack \u003d\u003d JsonScope.EMPTY_ARRAY || peekStack \u003d\u003d JsonScope.NONEMPTY_ARRAY) {\ncheckLenient();\npos--;\nreturn peeked\u003dPEEKED_NULL;\n}\n else {\nthrow syntaxError(\"Unexpected value\");\n}\ncase \u0027\\\u0027\u0027:checkLenient();\nreturn peeked\u003dPEEKED_SINGLE_QUOTED;\ncase \u0027\"\u0027:return peeked\u003dPEEKED_DOUBLE_QUOTED;\ncase \u0027[\u0027:return peeked\u003dPEEKED_BEGIN_ARRAY;\ncase \u0027{\u0027:return peeked\u003dPEEKED_BEGIN_OBJECT;\ndefault:pos--;\n}\nint result\u003dpeekKeyword();\nif (result !\u003d PEEKED_NONE) {\nreturn result;\n}\nresult\u003dpeekNumber();\nif (result !\u003d PEEKED_NONE) {\nreturn result;\n}\nif (!isLiteral(buffer[pos])) {\nthrow syntaxError(\"Expected value\");\n}\ncheckLenient();\nreturn peeked\u003dPEEKED_UNQUOTED;\n}",
    "begin_line": 465,
    "end_line": 599,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.peekKeyword#601",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.peekKeyword()",
    "snippet": "private int peekKeyword() throws IOException {\n  char c\u003dbuffer[pos];\n  String keyword;\n  String keywordUpper;\n  int peeking;\n  if (c \u003d\u003d \u0027t\u0027 || c \u003d\u003d \u0027T\u0027) {\n    keyword\u003d\"true\";\n    keywordUpper\u003d\"TRUE\";\n    peeking\u003dPEEKED_TRUE;\n  }\n else   if (c \u003d\u003d \u0027f\u0027 || c \u003d\u003d \u0027F\u0027) {\n    keyword\u003d\"false\";\n    keywordUpper\u003d\"FALSE\";\n    peeking\u003dPEEKED_FALSE;\n  }\n else   if (c \u003d\u003d \u0027n\u0027 || c \u003d\u003d \u0027N\u0027) {\n    keyword\u003d\"null\";\n    keywordUpper\u003d\"NULL\";\n    peeking\u003dPEEKED_NULL;\n  }\n else {\n    return PEEKED_NONE;\n  }\n  int length\u003dkeyword.length();\n  for (int i\u003d1; i \u003c length; i++) {\n    if (pos + i \u003e\u003d limit \u0026\u0026 !fillBuffer(i + 1)) {\n      return PEEKED_NONE;\n    }\n    c\u003dbuffer[pos + i];\n    if (c !\u003d keyword.charAt(i) \u0026\u0026 c !\u003d keywordUpper.charAt(i)) {\n      return PEEKED_NONE;\n    }\n  }\n  if ((pos + length \u003c limit || fillBuffer(length + 1)) \u0026\u0026 isLiteral(buffer[pos + length])) {\n    return PEEKED_NONE;\n  }\n  pos+\u003dlength;\n  return peeked\u003dpeeking;\n}",
    "begin_line": 601,
    "end_line": 643,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.peekNumber#645",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.peekNumber()",
    "snippet": "private int peekNumber() throws IOException {\n  char[] buffer\u003dthis.buffer;\n  int p\u003dpos;\n  int l\u003dlimit;\n  long value\u003d0;\n  boolean negative\u003dfalse;\n  boolean fitsInLong\u003dtrue;\n  int last\u003dNUMBER_CHAR_NONE;\n  int i\u003d0;\n  charactersOfNumber:   for (; true; i++) {\n    if (p + i \u003d\u003d l) {\n      if (i \u003d\u003d buffer.length) {\n        return PEEKED_NONE;\n      }\n      if (!fillBuffer(i + 1)) {\n        break;\n      }\n      p\u003dpos;\n      l\u003dlimit;\n    }\n    char c\u003dbuffer[p + i];\nswitch (c) {\ncase \u0027-\u0027:      if (last \u003d\u003d NUMBER_CHAR_NONE) {\n        negative\u003dtrue;\n        last\u003dNUMBER_CHAR_SIGN;\n        continue;\n      }\n else       if (last \u003d\u003d NUMBER_CHAR_EXP_E) {\n        last\u003dNUMBER_CHAR_EXP_SIGN;\n        continue;\n      }\n    return PEEKED_NONE;\ncase \u0027+\u0027:  if (last \u003d\u003d NUMBER_CHAR_EXP_E) {\n    last\u003dNUMBER_CHAR_EXP_SIGN;\n    continue;\n  }\nreturn PEEKED_NONE;\ncase \u0027e\u0027:case \u0027E\u0027:if (last \u003d\u003d NUMBER_CHAR_DIGIT || last \u003d\u003d NUMBER_CHAR_FRACTION_DIGIT) {\nlast\u003dNUMBER_CHAR_EXP_E;\ncontinue;\n}\nreturn PEEKED_NONE;\ncase \u0027.\u0027:if (last \u003d\u003d NUMBER_CHAR_DIGIT) {\nlast\u003dNUMBER_CHAR_DECIMAL;\ncontinue;\n}\nreturn PEEKED_NONE;\ndefault:if (c \u003c \u00270\u0027 || c \u003e \u00279\u0027) {\nif (!isLiteral(c)) {\nbreak charactersOfNumber;\n}\nreturn PEEKED_NONE;\n}\nif (last \u003d\u003d NUMBER_CHAR_SIGN || last \u003d\u003d NUMBER_CHAR_NONE) {\nvalue\u003d-(c - \u00270\u0027);\nlast\u003dNUMBER_CHAR_DIGIT;\n}\n else if (last \u003d\u003d NUMBER_CHAR_DIGIT) {\nif (value \u003d\u003d 0) {\nreturn PEEKED_NONE;\n}\nlong newValue\u003dvalue * 10 - (c - \u00270\u0027);\nfitsInLong\u0026\u003dvalue \u003e MIN_INCOMPLETE_INTEGER || (value \u003d\u003d MIN_INCOMPLETE_INTEGER \u0026\u0026 newValue \u003c value);\nvalue\u003dnewValue;\n}\n else if (last \u003d\u003d NUMBER_CHAR_DECIMAL) {\nlast\u003dNUMBER_CHAR_FRACTION_DIGIT;\n}\n else if (last \u003d\u003d NUMBER_CHAR_EXP_E || last \u003d\u003d NUMBER_CHAR_EXP_SIGN) {\nlast\u003dNUMBER_CHAR_EXP_DIGIT;\n}\n}\n}\nif (last \u003d\u003d NUMBER_CHAR_DIGIT \u0026\u0026 fitsInLong \u0026\u0026 (value !\u003d Long.MIN_VALUE || negative)) {\npeekedLong\u003dnegative ? value : -value;\npos+\u003di;\nreturn peeked\u003dPEEKED_LONG;\n}\n else if (last \u003d\u003d NUMBER_CHAR_DIGIT || last \u003d\u003d NUMBER_CHAR_FRACTION_DIGIT || last \u003d\u003d NUMBER_CHAR_EXP_DIGIT) {\npeekedNumberLength\u003di;\nreturn peeked\u003dPEEKED_NUMBER;\n}\n else {\nreturn PEEKED_NONE;\n}\n}",
    "begin_line": 645,
    "end_line": 746,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.isLiteral#748",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.isLiteral(char)",
    "snippet": "private boolean isLiteral(char c) throws IOException {\nswitch (c) {\ncase \u0027/\u0027:case \u0027\\\\\u0027:case \u0027;\u0027:case \u0027#\u0027:case \u0027\u003d\u0027:    checkLenient();\ncase \u0027{\u0027:case \u0027}\u0027:case \u0027[\u0027:case \u0027]\u0027:case \u0027:\u0027:case \u0027,\u0027:case \u0027 \u0027:case \u0027\\t\u0027:case \u0027\\f\u0027:case \u0027\\r\u0027:case \u0027\\n\u0027:  return false;\ndefault:return true;\n}\n}",
    "begin_line": 748,
    "end_line": 771,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextName#780",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextName()",
    "snippet": "public String nextName() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\n  String result;\n  if (p \u003d\u003d PEEKED_UNQUOTED_NAME) {\n    result\u003dnextUnquotedValue();\n  }\n else   if (p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\n    result\u003dnextQuotedValue(\u0027\\\u0027\u0027);\n  }\n else   if (p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\n    result\u003dnextQuotedValue(\u0027\"\u0027);\n  }\n else {\n    throw new IllegalStateException(\"Expected a name but was \" + peek() + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n  peeked\u003dPEEKED_NONE;\n  pathNames[stackSize - 1]\u003dresult;\n  return result;\n}",
    "begin_line": 780,
    "end_line": 799,
    "comment": "/** \n * Returns the next token, a  {@link com.google.gson.stream.JsonToken#NAME property name}, and consumes it.\n * @throws java.io.IOException if the next token in the stream is not a propertyname.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextString#809",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextString()",
    "snippet": "public String nextString() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\n  String result;\n  if (p \u003d\u003d PEEKED_UNQUOTED) {\n    result\u003dnextUnquotedValue();\n  }\n else   if (p \u003d\u003d PEEKED_SINGLE_QUOTED) {\n    result\u003dnextQuotedValue(\u0027\\\u0027\u0027);\n  }\n else   if (p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\n    result\u003dnextQuotedValue(\u0027\"\u0027);\n  }\n else   if (p \u003d\u003d PEEKED_BUFFERED) {\n    result\u003dpeekedString;\n    peekedString\u003dnull;\n  }\n else   if (p \u003d\u003d PEEKED_LONG) {\n    result\u003dLong.toString(peekedLong);\n  }\n else   if (p \u003d\u003d PEEKED_NUMBER) {\n    result\u003dnew String(buffer,pos,peekedNumberLength);\n    pos+\u003dpeekedNumberLength;\n  }\n else {\n    throw new IllegalStateException(\"Expected a string but was \" + peek() + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n  peeked\u003dPEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
    "begin_line": 809,
    "end_line": 836,
    "comment": "/** \n * Returns the  {@link com.google.gson.stream.JsonToken#STRING string} value of the next token,consuming it. If the next token is a number, this method will return its string form.\n * @throws IllegalStateException if the next token is not a string or ifthis reader is closed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextBoolean#845",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextBoolean()",
    "snippet": "public boolean nextBoolean() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\n  if (p \u003d\u003d PEEKED_TRUE) {\n    peeked\u003dPEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return true;\n  }\n else   if (p \u003d\u003d PEEKED_FALSE) {\n    peeked\u003dPEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return false;\n  }\n  throw new IllegalStateException(\"Expected a boolean but was \" + peek() + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n}",
    "begin_line": 845,
    "end_line": 861,
    "comment": "/** \n * Returns the  {@link com.google.gson.stream.JsonToken#BOOLEAN boolean} value of the next token,consuming it.\n * @throws IllegalStateException if the next token is not a boolean or ifthis reader is closed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextNull#870",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextNull()",
    "snippet": "public void nextNull() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\n  if (p \u003d\u003d PEEKED_NULL) {\n    peeked\u003dPEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n  }\n else {\n    throw new IllegalStateException(\"Expected null but was \" + peek() + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n}",
    "begin_line": 870,
    "end_line": 882,
    "comment": "/** \n * Consumes the next token from the JSON stream and asserts that it is a literal null.\n * @throws IllegalStateException if the next token is not null or if thisreader is closed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextDouble#893",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextDouble()",
    "snippet": "public double nextDouble() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\n  if (p \u003d\u003d PEEKED_LONG) {\n    peeked\u003dPEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return (double)peekedLong;\n  }\n  if (p \u003d\u003d PEEKED_NUMBER) {\n    peekedString\u003dnew String(buffer,pos,peekedNumberLength);\n    pos+\u003dpeekedNumberLength;\n  }\n else   if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\n    peekedString\u003dnextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\n  }\n else   if (p \u003d\u003d PEEKED_UNQUOTED) {\n    peekedString\u003dnextUnquotedValue();\n  }\n else   if (p !\u003d PEEKED_BUFFERED) {\n    throw new IllegalStateException(\"Expected a double but was \" + peek() + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n  peeked\u003dPEEKED_BUFFERED;\n  double result\u003dDouble.parseDouble(peekedString);\n  if (!lenient \u0026\u0026 (Double.isNaN(result) || Double.isInfinite(result))) {\n    throw new MalformedJsonException(\"JSON forbids NaN and infinities: \" + result + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n  peekedString\u003dnull;\n  peeked\u003dPEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
    "begin_line": 893,
    "end_line": 927,
    "comment": "/** \n * Returns the  {@link com.google.gson.stream.JsonToken#NUMBER double} value of the next token,consuming it. If the next token is a string, this method will attempt to parse it as a double using  {@link Double#parseDouble(String)}.\n * @throws IllegalStateException if the next token is not a literal value.\n * @throws NumberFormatException if the next literal value cannot be parsedas a double, or is non-finite.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextLong#939",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextLong()",
    "snippet": "public long nextLong() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\n  if (p \u003d\u003d PEEKED_LONG) {\n    peeked\u003dPEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return peekedLong;\n  }\n  if (p \u003d\u003d PEEKED_NUMBER) {\n    peekedString\u003dnew String(buffer,pos,peekedNumberLength);\n    pos+\u003dpeekedNumberLength;\n  }\n else   if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\n    peekedString\u003dnextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\n    try {\n      long result\u003dLong.parseLong(peekedString);\n      peeked\u003dPEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n catch (    NumberFormatException ignored) {\n    }\n  }\n else {\n    throw new IllegalStateException(\"Expected a long but was \" + peek() + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n  peeked\u003dPEEKED_BUFFERED;\n  double asDouble\u003dDouble.parseDouble(peekedString);\n  long result\u003d(long)asDouble;\n  if (result !\u003d asDouble) {\n    throw new NumberFormatException(\"Expected a long but was \" + peekedString + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n  peekedString\u003dnull;\n  peeked\u003dPEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
    "begin_line": 939,
    "end_line": 980,
    "comment": "/** \n * Returns the  {@link com.google.gson.stream.JsonToken#NUMBER long} value of the next token,consuming it. If the next token is a string, this method will attempt to parse it as a long. If the next token\u0027s numeric value cannot be exactly represented by a Java  {@code long}, this method throws.\n * @throws IllegalStateException if the next token is not a literal value.\n * @throws NumberFormatException if the next literal value cannot be parsedas a number, or exactly represented as a long.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextQuotedValue#992",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextQuotedValue(char)",
    "snippet": "private String nextQuotedValue(char quote) throws IOException {\n  char[] buffer\u003dthis.buffer;\n  StringBuilder builder\u003dnew StringBuilder();\n  while (true) {\n    int p\u003dpos;\n    int l\u003dlimit;\n    int start\u003dp;\n    while (p \u003c l) {\n      int c\u003dbuffer[p++];\n      if (c \u003d\u003d quote) {\n        pos\u003dp;\n        builder.append(buffer,start,p - start - 1);\n        return builder.toString();\n      }\n else       if (c \u003d\u003d \u0027\\\\\u0027) {\n        pos\u003dp;\n        builder.append(buffer,start,p - start - 1);\n        builder.append(readEscapeCharacter());\n        p\u003dpos;\n        l\u003dlimit;\n        start\u003dp;\n      }\n else       if (c \u003d\u003d \u0027\\n\u0027) {\n        lineNumber++;\n        lineStart\u003dp;\n      }\n    }\n    builder.append(buffer,start,p - start);\n    pos\u003dp;\n    if (!fillBuffer(1)) {\n      throw syntaxError(\"Unterminated string\");\n    }\n  }\n}",
    "begin_line": 992,
    "end_line": 1027,
    "comment": "/** \n * Returns the string up to but not including  {@code quote}, unescaping any character escape sequences encountered along the way. The opening quote should have already been read. This consumes the closing quote, but does not include it in the returned string.\n * @param quote either \u0027 or \".\n * @throws NumberFormatException if any unicode escape sequences aremalformed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextUnquotedValue#1033",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextUnquotedValue()",
    "snippet": "@SuppressWarnings(\"fallthrough\") private String nextUnquotedValue() throws IOException {\n  StringBuilder builder\u003dnull;\n  int i\u003d0;\n  findNonLiteralCharacter:   while (true) {\n    for (; pos + i \u003c limit; i++) {\nswitch (buffer[pos + i]) {\ncase \u0027/\u0027:case \u0027\\\\\u0027:case \u0027;\u0027:case \u0027#\u0027:case \u0027\u003d\u0027:        checkLenient();\ncase \u0027{\u0027:case \u0027}\u0027:case \u0027[\u0027:case \u0027]\u0027:case \u0027:\u0027:case \u0027,\u0027:case \u0027 \u0027:case \u0027\\t\u0027:case \u0027\\f\u0027:case \u0027\\r\u0027:case \u0027\\n\u0027:      break findNonLiteralCharacter;\n  }\n}\nif (i \u003c buffer.length) {\n  if (fillBuffer(i + 1)) {\n    continue;\n  }\n else {\n    break;\n  }\n}\nif (builder \u003d\u003d null) {\n  builder\u003dnew StringBuilder();\n}\nbuilder.append(buffer,pos,i);\npos+\u003di;\ni\u003d0;\nif (!fillBuffer(1)) {\n  break;\n}\n}\nString result;\nif (builder \u003d\u003d null) {\nresult\u003dnew String(buffer,pos,i);\n}\n else {\nbuilder.append(buffer,pos,i);\nresult\u003dbuilder.toString();\n}\npos+\u003di;\nreturn result;\n}",
    "begin_line": 1033,
    "end_line": 1092,
    "comment": "/** \n * Returns an unquoted value as a string.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.skipQuotedValue#1094",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.skipQuotedValue(char)",
    "snippet": "private void skipQuotedValue(char quote) throws IOException {\n  char[] buffer\u003dthis.buffer;\n  do {\n    int p\u003dpos;\n    int l\u003dlimit;\n    while (p \u003c l) {\n      int c\u003dbuffer[p++];\n      if (c \u003d\u003d quote) {\n        pos\u003dp;\n        return;\n      }\n else       if (c \u003d\u003d \u0027\\\\\u0027) {\n        pos\u003dp;\n        readEscapeCharacter();\n        p\u003dpos;\n        l\u003dlimit;\n      }\n else       if (c \u003d\u003d \u0027\\n\u0027) {\n        lineNumber++;\n        lineStart\u003dp;\n      }\n    }\n    pos\u003dp;\n  }\n while (fillBuffer(1));\n  throw syntaxError(\"Unterminated string\");\n}",
    "begin_line": 1094,
    "end_line": 1119,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.skipUnquotedValue#1121",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.skipUnquotedValue()",
    "snippet": "private void skipUnquotedValue() throws IOException {\n  do {\n    int i\u003d0;\n    for (; pos + i \u003c limit; i++) {\nswitch (buffer[pos + i]) {\ncase \u0027/\u0027:case \u0027\\\\\u0027:case \u0027;\u0027:case \u0027#\u0027:case \u0027\u003d\u0027:        checkLenient();\ncase \u0027{\u0027:case \u0027}\u0027:case \u0027[\u0027:case \u0027]\u0027:case \u0027:\u0027:case \u0027,\u0027:case \u0027 \u0027:case \u0027\\t\u0027:case \u0027\\f\u0027:case \u0027\\r\u0027:case \u0027\\n\u0027:      pos+\u003di;\n    return;\n}\n}\npos+\u003di;\n}\n while (fillBuffer(1));\n}",
    "begin_line": 1121,
    "end_line": 1149,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextInt#1161",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextInt()",
    "snippet": "public int nextInt() throws IOException {\n  int p\u003dpeeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003ddoPeek();\n  }\n  int result;\n  if (p \u003d\u003d PEEKED_LONG) {\n    result\u003d(int)peekedLong;\n    if (peekedLong !\u003d result) {\n      throw new NumberFormatException(\"Expected an int but was \" + peekedLong + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n    }\n    peeked\u003dPEEKED_NONE;\n    pathIndices[stackSize - 1]++;\n    return result;\n  }\n  if (p \u003d\u003d PEEKED_NUMBER) {\n    peekedString\u003dnew String(buffer,pos,peekedNumberLength);\n    pos+\u003dpeekedNumberLength;\n  }\n else   if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED) {\n    peekedString\u003dnextQuotedValue(p \u003d\u003d PEEKED_SINGLE_QUOTED ? \u0027\\\u0027\u0027 : \u0027\"\u0027);\n    try {\n      result\u003dInteger.parseInt(peekedString);\n      peeked\u003dPEEKED_NONE;\n      pathIndices[stackSize - 1]++;\n      return result;\n    }\n catch (    NumberFormatException ignored) {\n    }\n  }\n else {\n    throw new IllegalStateException(\"Expected an int but was \" + peek() + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n  peeked\u003dPEEKED_BUFFERED;\n  double asDouble\u003dDouble.parseDouble(peekedString);\n  result\u003d(int)asDouble;\n  if (result !\u003d asDouble) {\n    throw new NumberFormatException(\"Expected an int but was \" + peekedString + \" at line \"+ getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n  }\n  peekedString\u003dnull;\n  peeked\u003dPEEKED_NONE;\n  pathIndices[stackSize - 1]++;\n  return result;\n}",
    "begin_line": 1161,
    "end_line": 1208,
    "comment": "/** \n * Returns the  {@link com.google.gson.stream.JsonToken#NUMBER int} value of the next token,consuming it. If the next token is a string, this method will attempt to parse it as an int. If the next token\u0027s numeric value cannot be exactly represented by a Java  {@code int}, this method throws.\n * @throws IllegalStateException if the next token is not a literal value.\n * @throws NumberFormatException if the next literal value cannot be parsedas a number, or exactly represented as an int.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.close#1213",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.close()",
    "snippet": "public void close() throws IOException {\n  peeked\u003dPEEKED_NONE;\n  stack[0]\u003dJsonScope.CLOSED;\n  stackSize\u003d1;\n  in.close();\n}",
    "begin_line": 1213,
    "end_line": 1218,
    "comment": "/** \n * Closes this JSON reader and the underlying  {@link java.io.Reader}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.skipValue#1225",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.skipValue()",
    "snippet": "public void skipValue() throws IOException {\n  int count\u003d0;\n  do {\n    int p\u003dpeeked;\n    if (p \u003d\u003d PEEKED_NONE) {\n      p\u003ddoPeek();\n    }\n    if (p \u003d\u003d PEEKED_BEGIN_ARRAY) {\n      push(JsonScope.EMPTY_ARRAY);\n      count++;\n    }\n else     if (p \u003d\u003d PEEKED_BEGIN_OBJECT) {\n      push(JsonScope.EMPTY_OBJECT);\n      count++;\n    }\n else     if (p \u003d\u003d PEEKED_END_ARRAY) {\n      stackSize--;\n      count--;\n    }\n else     if (p \u003d\u003d PEEKED_END_OBJECT) {\n      stackSize--;\n      count--;\n    }\n else     if (p \u003d\u003d PEEKED_UNQUOTED_NAME || p \u003d\u003d PEEKED_UNQUOTED) {\n      skipUnquotedValue();\n    }\n else     if (p \u003d\u003d PEEKED_SINGLE_QUOTED || p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\n      skipQuotedValue(\u0027\\\u0027\u0027);\n    }\n else     if (p \u003d\u003d PEEKED_DOUBLE_QUOTED || p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\n      skipQuotedValue(\u0027\"\u0027);\n    }\n else     if (p \u003d\u003d PEEKED_NUMBER) {\n      pos+\u003dpeekedNumberLength;\n    }\n    peeked\u003dPEEKED_NONE;\n  }\n while (count !\u003d 0);\n  pathIndices[stackSize - 1]++;\n  pathNames[stackSize - 1]\u003d\"null\";\n}",
    "begin_line": 1225,
    "end_line": 1259,
    "comment": "/** \n * Skips the next value recursively. If it is an object or array, all nested elements are skipped. This method is intended for use when the JSON token stream contains unrecognized or unhandled values.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.push#1261",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.push(int)",
    "snippet": "private void push(int newTop){\n  if (stackSize \u003d\u003d stack.length) {\n    int[] newStack\u003dnew int[stackSize * 2];\n    int[] newPathIndices\u003dnew int[stackSize * 2];\n    String[] newPathNames\u003dnew String[stackSize * 2];\n    System.arraycopy(stack,0,newStack,0,stackSize);\n    System.arraycopy(pathIndices,0,newPathIndices,0,stackSize);\n    System.arraycopy(pathNames,0,newPathNames,0,stackSize);\n    stack\u003dnewStack;\n    pathIndices\u003dnewPathIndices;\n    pathNames\u003dnewPathNames;\n  }\n  stack[stackSize++]\u003dnewTop;\n}",
    "begin_line": 1261,
    "end_line": 1274,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.fillBuffer#1281",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.fillBuffer(int)",
    "snippet": "private boolean fillBuffer(int minimum) throws IOException {\n  char[] buffer\u003dthis.buffer;\n  lineStart-\u003dpos;\n  if (limit !\u003d pos) {\n    limit-\u003dpos;\n    System.arraycopy(buffer,pos,buffer,0,limit);\n  }\n else {\n    limit\u003d0;\n  }\n  pos\u003d0;\n  int total;\n  while ((total\u003din.read(buffer,limit,buffer.length - limit)) !\u003d -1) {\n    limit+\u003dtotal;\n    if (lineNumber \u003d\u003d 0 \u0026\u0026 lineStart \u003d\u003d 0 \u0026\u0026 limit \u003e 0 \u0026\u0026 buffer[0] \u003d\u003d \u0027\\ufeff\u0027) {\n      pos++;\n      lineStart++;\n      minimum++;\n    }\n    if (limit \u003e\u003d minimum) {\n      return true;\n    }\n  }\n  return false;\n}",
    "begin_line": 1281,
    "end_line": 1308,
    "comment": "/** \n * Returns true once  {@code limit - pos \u003e\u003d minimum}. If the data is exhausted before that many characters are available, this returns false.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.getLineNumber#1310",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.getLineNumber()",
    "snippet": "int getLineNumber(){\n  return lineNumber + 1;\n}",
    "begin_line": 1310,
    "end_line": 1312,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.getColumnNumber#1314",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.getColumnNumber()",
    "snippet": "int getColumnNumber(){\n  return pos - lineStart + 1;\n}",
    "begin_line": 1314,
    "end_line": 1316,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.nextNonWhitespace#1324",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.nextNonWhitespace(boolean)",
    "snippet": "private int nextNonWhitespace(boolean throwOnEof) throws IOException {\n  char[] buffer\u003dthis.buffer;\n  int p\u003dpos;\n  int l\u003dlimit;\n  while (true) {\n    if (p \u003d\u003d l) {\n      pos\u003dp;\n      if (!fillBuffer(1)) {\n        break;\n      }\n      p\u003dpos;\n      l\u003dlimit;\n    }\n    int c\u003dbuffer[p++];\n    if (c \u003d\u003d \u0027\\n\u0027) {\n      lineNumber++;\n      lineStart\u003dp;\n      continue;\n    }\n else     if (c \u003d\u003d \u0027 \u0027 || c \u003d\u003d \u0027\\r\u0027 || c \u003d\u003d \u0027\\t\u0027) {\n      continue;\n    }\n    if (c \u003d\u003d \u0027/\u0027) {\n      pos\u003dp;\n      if (p \u003d\u003d l) {\n        pos--;\n        boolean charsLoaded\u003dfillBuffer(2);\n        pos++;\n        if (!charsLoaded) {\n          return c;\n        }\n      }\n      checkLenient();\n      char peek\u003dbuffer[pos];\nswitch (peek) {\ncase \u0027*\u0027:        pos++;\n      if (!skipTo(\"*/\")) {\n        throw syntaxError(\"Unterminated comment\");\n      }\n    p\u003dpos + 2;\n  l\u003dlimit;\ncontinue;\ncase \u0027/\u0027:pos++;\nskipToEndOfLine();\np\u003dpos;\nl\u003dlimit;\ncontinue;\ndefault:return c;\n}\n}\n else if (c \u003d\u003d \u0027#\u0027) {\npos\u003dp;\ncheckLenient();\nskipToEndOfLine();\np\u003dpos;\nl\u003dlimit;\n}\n else {\npos\u003dp;\nreturn c;\n}\n}\nif (throwOnEof) {\nthrow new EOFException(\"End of input\" + \" at line \" + getLineNumber() + \" column \"+ getColumnNumber());\n}\n else {\nreturn -1;\n}\n}",
    "begin_line": 1324,
    "end_line": 1412,
    "comment": "/** \n * Returns the next character in the stream that is neither whitespace nor a part of a comment. When this returns, the returned character is always at {@code buffer[pos-1]}; this means the caller can always push back the returned character by decrementing  {@code pos}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.checkLenient#1414",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.checkLenient()",
    "snippet": "private void checkLenient() throws IOException {\n  if (!lenient) {\n    throw syntaxError(\"Use JsonReader.setLenient(true) to accept malformed JSON\");\n  }\n}",
    "begin_line": 1414,
    "end_line": 1418,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.skipToEndOfLine#1425",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.skipToEndOfLine()",
    "snippet": "private void skipToEndOfLine() throws IOException {\n  while (pos \u003c limit || fillBuffer(1)) {\n    char c\u003dbuffer[pos++];\n    if (c \u003d\u003d \u0027\\n\u0027) {\n      lineNumber++;\n      lineStart\u003dpos;\n      break;\n    }\n else     if (c \u003d\u003d \u0027\\r\u0027) {\n      break;\n    }\n  }\n}",
    "begin_line": 1425,
    "end_line": 1436,
    "comment": "/** \n * Advances the position until after the next newline character. If the line is terminated by \"\\r\\n\", the \u0027\\n\u0027 must be consumed as whitespace by the caller.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.skipTo#1441",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.skipTo(java.lang.String)",
    "snippet": "private boolean skipTo(String toFind) throws IOException {\n  outer:   for (; pos + toFind.length() \u003c\u003d limit || fillBuffer(toFind.length()); pos++) {\n    if (buffer[pos] \u003d\u003d \u0027\\n\u0027) {\n      lineNumber++;\n      lineStart\u003dpos + 1;\n      continue;\n    }\n    for (int c\u003d0; c \u003c toFind.length(); c++) {\n      if (buffer[pos + c] !\u003d toFind.charAt(c)) {\n        continue outer;\n      }\n    }\n    return true;\n  }\n  return false;\n}",
    "begin_line": 1441,
    "end_line": 1457,
    "comment": "/** \n * @param toFind a string to search for. Must not contain a newline.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.toString#1459",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.toString()",
    "snippet": "@Override public String toString(){\n  return getClass().getSimpleName() + \" at line \" + getLineNumber()+ \" column \"+ getColumnNumber();\n}",
    "begin_line": 1459,
    "end_line": 1462,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.getPath#1468",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.getPath()",
    "snippet": "public String getPath(){\n  StringBuilder result\u003dnew StringBuilder().append(\u0027$\u0027);\n  for (int i\u003d0, size\u003dstackSize; i \u003c size; i++) {\nswitch (stack[i]) {\ncase JsonScope.EMPTY_ARRAY:case JsonScope.NONEMPTY_ARRAY:      result.append(\u0027[\u0027).append(pathIndices[i]).append(\u0027]\u0027);\n    break;\ncase JsonScope.EMPTY_OBJECT:case JsonScope.DANGLING_NAME:case JsonScope.NONEMPTY_OBJECT:  result.append(\u0027.\u0027);\nif (pathNames[i] !\u003d null) {\n  result.append(pathNames[i]);\n}\nbreak;\ncase JsonScope.NONEMPTY_DOCUMENT:case JsonScope.EMPTY_DOCUMENT:case JsonScope.CLOSED:break;\n}\n}\nreturn result.toString();\n}",
    "begin_line": 1468,
    "end_line": 1493,
    "comment": "/** \n * Returns a \u003ca href\u003d\"http://goessner.net/articles/JsonPath/\"\u003eJsonPath\u003c/a\u003e to the current location in the JSON value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.readEscapeCharacter#1504",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.readEscapeCharacter()",
    "snippet": "private char readEscapeCharacter() throws IOException {\n  if (pos \u003d\u003d limit \u0026\u0026 !fillBuffer(1)) {\n    throw syntaxError(\"Unterminated escape sequence\");\n  }\n  char escaped\u003dbuffer[pos++];\nswitch (escaped) {\ncase \u0027u\u0027:    if (pos + 4 \u003e limit \u0026\u0026 !fillBuffer(4)) {\n      throw syntaxError(\"Unterminated escape sequence\");\n    }\n  char result\u003d0;\nfor (int i\u003dpos, end\u003di + 4; i \u003c end; i++) {\n  char c\u003dbuffer[i];\n  result\u003c\u003c\u003d4;\n  if (c \u003e\u003d \u00270\u0027 \u0026\u0026 c \u003c\u003d \u00279\u0027) {\n    result+\u003d(c - \u00270\u0027);\n  }\n else   if (c \u003e\u003d \u0027a\u0027 \u0026\u0026 c \u003c\u003d \u0027f\u0027) {\n    result+\u003d(c - \u0027a\u0027 + 10);\n  }\n else   if (c \u003e\u003d \u0027A\u0027 \u0026\u0026 c \u003c\u003d \u0027F\u0027) {\n    result+\u003d(c - \u0027A\u0027 + 10);\n  }\n else {\n    throw new NumberFormatException(\"\\\\u\" + new String(buffer,pos,4));\n  }\n}\npos+\u003d4;\nreturn result;\ncase \u0027t\u0027:return \u0027\\t\u0027;\ncase \u0027b\u0027:return \u0027\\b\u0027;\ncase \u0027n\u0027:return \u0027\\n\u0027;\ncase \u0027r\u0027:return \u0027\\r\u0027;\ncase \u0027f\u0027:return \u0027\\f\u0027;\ncase \u0027\\n\u0027:lineNumber++;\nlineStart\u003dpos;\ncase \u0027\\\u0027\u0027:case \u0027\"\u0027:case \u0027\\\\\u0027:default:return escaped;\n}\n}",
    "begin_line": 1504,
    "end_line": 1559,
    "comment": "/** \n * Unescapes the character identified by the character or characters that immediately follow a backslash. The backslash \u0027\\\u0027 should have already been read. This supports both unicode escapes \"u000A\" and two-character escapes \"\\n\".\n * @throws NumberFormatException if any unicode escape sequences aremalformed.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.syntaxError#1565",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.syntaxError(java.lang.String)",
    "snippet": "private IOException syntaxError(String message) throws IOException {\n  throw new MalformedJsonException(message + \" at line \" + getLineNumber()+ \" column \"+ getColumnNumber()+ \" path \"+ getPath());\n}",
    "begin_line": 1565,
    "end_line": 1568,
    "comment": "/** \n * Throws a new IO exception with the given message and a context snippet with this reader\u0027s content.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.consumeNonExecutePrefix#1573",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.consumeNonExecutePrefix()",
    "snippet": "private void consumeNonExecutePrefix() throws IOException {\n  nextNonWhitespace(true);\n  pos--;\n  if (pos + NON_EXECUTE_PREFIX.length \u003e limit \u0026\u0026 !fillBuffer(NON_EXECUTE_PREFIX.length)) {\n    return;\n  }\n  for (int i\u003d0; i \u003c NON_EXECUTE_PREFIX.length; i++) {\n    if (buffer[pos + i] !\u003d NON_EXECUTE_PREFIX[i]) {\n      return;\n    }\n  }\n  pos+\u003dNON_EXECUTE_PREFIX.length;\n}",
    "begin_line": 1573,
    "end_line": 1590,
    "comment": "/** \n * Consumes the non-execute prefix if it exists.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonReader.promoteNameToValue#1594",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonReader.java",
    "class_name": "com.google.gson.stream.JsonReader",
    "signature": "com.google.gson.stream.JsonReader.promoteNameToValue(com.google.gson.stream.JsonReader)",
    "snippet": "@Override public void promoteNameToValue(JsonReader reader) throws IOException {\n  if (reader instanceof JsonTreeReader) {\n    ((JsonTreeReader)reader).promoteNameToValue();\n    return;\n  }\n  int p\u003dreader.peeked;\n  if (p \u003d\u003d PEEKED_NONE) {\n    p\u003dreader.doPeek();\n  }\n  if (p \u003d\u003d PEEKED_DOUBLE_QUOTED_NAME) {\n    reader.peeked\u003dPEEKED_DOUBLE_QUOTED;\n  }\n else   if (p \u003d\u003d PEEKED_SINGLE_QUOTED_NAME) {\n    reader.peeked\u003dPEEKED_SINGLE_QUOTED;\n  }\n else   if (p \u003d\u003d PEEKED_UNQUOTED_NAME) {\n    reader.peeked\u003dPEEKED_UNQUOTED;\n  }\n else {\n    throw new IllegalStateException(\"Expected a name but was \" + reader.peek() + \" \"+ \" at line \"+ reader.getLineNumber()+ \" column \"+ reader.getColumnNumber()+ \" path \"+ reader.getPath());\n  }\n}",
    "begin_line": 1594,
    "end_line": 1614,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.JsonWriter#197",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.JsonWriter(java.io.Writer)",
    "snippet": "public JsonWriter(Writer out){\n  if (out \u003d\u003d null) {\n    throw new NullPointerException(\"out \u003d\u003d null\");\n  }\n  this.out\u003dout;\n}",
    "begin_line": 197,
    "end_line": 202,
    "comment": "/** \n * Creates a new instance that writes a JSON-encoded stream to  {@code out}. For best performance, ensure  {@link Writer} is buffered; wrapping in{@link java.io.BufferedWriter BufferedWriter} if necessary.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.setIndent#212",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.setIndent(java.lang.String)",
    "snippet": "public final void setIndent(String indent){\n  if (indent.length() \u003d\u003d 0) {\n    this.indent\u003dnull;\n    this.separator\u003d\":\";\n  }\n else {\n    this.indent\u003dindent;\n    this.separator\u003d\": \";\n  }\n}",
    "begin_line": 212,
    "end_line": 220,
    "comment": "/** \n * Sets the indentation string to be repeated for each level of indentation in the encoded document. If  {@code indent.isEmpty()} the encoded documentwill be compact. Otherwise the encoded document will be more human-readable.\n * @param indent a string containing only whitespace.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.setLenient#234",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.setLenient(boolean)",
    "snippet": "public final void setLenient(boolean lenient){\n  this.lenient\u003dlenient;\n}",
    "begin_line": 234,
    "end_line": 236,
    "comment": "/** \n * Configure this writer to relax its syntax rules. By default, this writer only emits well-formed JSON as specified by \u003ca href\u003d\"http://www.ietf.org/rfc/rfc7159.txt\"\u003eRFC 7159\u003c/a\u003e. Setting the writer to lenient permits the following: \u003cul\u003e \u003cli\u003eTop-level values of any type. With strict writing, the top-level value must be an object or an array. \u003cli\u003eNumbers may be  {@link Double#isNaN() NaNs} or {@link Double#isInfinite() infinities}. \u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.isLenient#241",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.isLenient()",
    "snippet": "public boolean isLenient(){\n  return lenient;\n}",
    "begin_line": 241,
    "end_line": 243,
    "comment": "/** \n * Returns true if this writer has relaxed syntax rules.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.setHtmlSafe#252",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.setHtmlSafe(boolean)",
    "snippet": "public final void setHtmlSafe(boolean htmlSafe){\n  this.htmlSafe\u003dhtmlSafe;\n}",
    "begin_line": 252,
    "end_line": 254,
    "comment": "/** \n * Configure this writer to emit JSON that\u0027s safe for direct inclusion in HTML and XML documents. This escapes the HTML characters  {@code \u003c},  {@code \u003e}, {@code \u0026} and {@code \u003d} before writing them to the stream. Without thissetting, your XML/HTML encoder should replace these characters with the corresponding escape sequences.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.isHtmlSafe#260",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.isHtmlSafe()",
    "snippet": "public final boolean isHtmlSafe(){\n  return htmlSafe;\n}",
    "begin_line": 260,
    "end_line": 262,
    "comment": "/** \n * Returns true if this writer writes JSON that\u0027s safe for inclusion in HTML and XML documents.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.setSerializeNulls#268",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.setSerializeNulls(boolean)",
    "snippet": "public final void setSerializeNulls(boolean serializeNulls){\n  this.serializeNulls\u003dserializeNulls;\n}",
    "begin_line": 268,
    "end_line": 270,
    "comment": "/** \n * Sets whether object members are serialized when their value is null. This has no impact on array elements. The default is true.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.getSerializeNulls#276",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.getSerializeNulls()",
    "snippet": "public final boolean getSerializeNulls(){\n  return serializeNulls;\n}",
    "begin_line": 276,
    "end_line": 278,
    "comment": "/** \n * Returns true if object members are serialized when their value is null. This has no impact on array elements. The default is true.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.beginArray#286",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.beginArray()",
    "snippet": "public JsonWriter beginArray() throws IOException {\n  writeDeferredName();\n  return open(EMPTY_ARRAY,\"[\");\n}",
    "begin_line": 286,
    "end_line": 289,
    "comment": "/** \n * Begins encoding a new array. Each call to this method must be paired with a call to  {@link #endArray}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.endArray#296",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.endArray()",
    "snippet": "public JsonWriter endArray() throws IOException {\n  return close(EMPTY_ARRAY,NONEMPTY_ARRAY,\"]\");\n}",
    "begin_line": 296,
    "end_line": 298,
    "comment": "/** \n * Ends encoding the current array.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.beginObject#306",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.beginObject()",
    "snippet": "public JsonWriter beginObject() throws IOException {\n  writeDeferredName();\n  return open(EMPTY_OBJECT,\"{\");\n}",
    "begin_line": 306,
    "end_line": 309,
    "comment": "/** \n * Begins encoding a new object. Each call to this method must be paired with a call to  {@link #endObject}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.endObject#316",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.endObject()",
    "snippet": "public JsonWriter endObject() throws IOException {\n  return close(EMPTY_OBJECT,NONEMPTY_OBJECT,\"}\");\n}",
    "begin_line": 316,
    "end_line": 318,
    "comment": "/** \n * Ends encoding the current object.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.open#324",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.open(int, java.lang.String)",
    "snippet": "private JsonWriter open(int empty,String openBracket) throws IOException {\n  beforeValue();\n  push(empty);\n  out.write(openBracket);\n  return this;\n}",
    "begin_line": 324,
    "end_line": 329,
    "comment": "/** \n * Enters a new scope by appending any necessary whitespace and the given bracket.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.close#335",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.close(int, int, java.lang.String)",
    "snippet": "private JsonWriter close(int empty,int nonempty,String closeBracket) throws IOException {\n  int context\u003dpeek();\n  if (context !\u003d nonempty \u0026\u0026 context !\u003d empty) {\n    throw new IllegalStateException(\"Nesting problem.\");\n  }\n  if (deferredName !\u003d null) {\n    throw new IllegalStateException(\"Dangling name: \" + deferredName);\n  }\n  stackSize--;\n  if (context \u003d\u003d nonempty) {\n    newline();\n  }\n  out.write(closeBracket);\n  return this;\n}",
    "begin_line": 335,
    "end_line": 351,
    "comment": "/** \n * Closes the current scope by appending any necessary whitespace and the given bracket.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.push#353",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.push(int)",
    "snippet": "private void push(int newTop){\n  if (stackSize \u003d\u003d stack.length) {\n    int[] newStack\u003dnew int[stackSize * 2];\n    System.arraycopy(stack,0,newStack,0,stackSize);\n    stack\u003dnewStack;\n  }\n  stack[stackSize++]\u003dnewTop;\n}",
    "begin_line": 353,
    "end_line": 360,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.peek#365",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.peek()",
    "snippet": "private int peek(){\n  if (stackSize \u003d\u003d 0) {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  return stack[stackSize - 1];\n}",
    "begin_line": 365,
    "end_line": 370,
    "comment": "/** \n * Returns the value on the top of the stack.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.replaceTop#375",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.replaceTop(int)",
    "snippet": "private void replaceTop(int topOfStack){\n  stack[stackSize - 1]\u003dtopOfStack;\n}",
    "begin_line": 375,
    "end_line": 377,
    "comment": "/** \n * Replace the value on the top of the stack with the given value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.name#385",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.name(java.lang.String)",
    "snippet": "public JsonWriter name(String name) throws IOException {\n  if (name \u003d\u003d null) {\n    throw new NullPointerException(\"name \u003d\u003d null\");\n  }\n  if (deferredName !\u003d null) {\n    throw new IllegalStateException();\n  }\n  if (stackSize \u003d\u003d 0) {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  deferredName\u003dname;\n  return this;\n}",
    "begin_line": 385,
    "end_line": 397,
    "comment": "/** \n * Encodes the property name.\n * @param name the name of the forthcoming value. May not be null.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.writeDeferredName#399",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.writeDeferredName()",
    "snippet": "private void writeDeferredName() throws IOException {\n  if (deferredName !\u003d null) {\n    beforeName();\n    string(deferredName);\n    deferredName\u003dnull;\n  }\n}",
    "begin_line": 399,
    "end_line": 405,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.value#413",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.value(java.lang.String)",
    "snippet": "public JsonWriter value(String value) throws IOException {\n  if (value \u003d\u003d null) {\n    return nullValue();\n  }\n  writeDeferredName();\n  beforeValue();\n  string(value);\n  return this;\n}",
    "begin_line": 413,
    "end_line": 421,
    "comment": "/** \n * Encodes  {@code value}.\n * @param value the literal string value, or null to encode a null literal.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.jsonValue#430",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.jsonValue(java.lang.String)",
    "snippet": "public JsonWriter jsonValue(String value) throws IOException {\n  if (value \u003d\u003d null) {\n    return nullValue();\n  }\n  writeDeferredName();\n  beforeValue();\n  out.append(value);\n  return this;\n}",
    "begin_line": 430,
    "end_line": 438,
    "comment": "/** \n * Writes  {@code value} directly to the writer without quoting orescaping.\n * @param value the literal string value, or null to encode a null literal.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.nullValue#445",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.nullValue()",
    "snippet": "public JsonWriter nullValue() throws IOException {\n  if (deferredName !\u003d null) {\n    if (serializeNulls) {\n      writeDeferredName();\n    }\n else {\n      deferredName\u003dnull;\n      return this;\n    }\n  }\n  beforeValue();\n  out.write(\"null\");\n  return this;\n}",
    "begin_line": 445,
    "end_line": 457,
    "comment": "/** \n * Encodes  {@code null}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.value#464",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.value(boolean)",
    "snippet": "public JsonWriter value(boolean value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  out.write(value ? \"true\" : \"false\");\n  return this;\n}",
    "begin_line": 464,
    "end_line": 469,
    "comment": "/** \n * Encodes  {@code value}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.value#478",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.value(double)",
    "snippet": "public JsonWriter value(double value) throws IOException {\n  if (Double.isNaN(value) || Double.isInfinite(value)) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  writeDeferredName();\n  beforeValue();\n  out.append(Double.toString(value));\n  return this;\n}",
    "begin_line": 478,
    "end_line": 486,
    "comment": "/** \n * Encodes  {@code value}.\n * @param value a finite value. May not be {@link Double#isNaN() NaNs} or{@link Double#isInfinite() infinities}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.value#493",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.value(long)",
    "snippet": "public JsonWriter value(long value) throws IOException {\n  writeDeferredName();\n  beforeValue();\n  out.write(Long.toString(value));\n  return this;\n}",
    "begin_line": 493,
    "end_line": 498,
    "comment": "/** \n * Encodes  {@code value}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.value#507",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.value(java.lang.Number)",
    "snippet": "public JsonWriter value(Number value) throws IOException {\n  if (value \u003d\u003d null) {\n    return nullValue();\n  }\n  writeDeferredName();\n  String string\u003dvalue.toString();\n  if (!lenient \u0026\u0026 (string.equals(\"-Infinity\") || string.equals(\"Infinity\") || string.equals(\"NaN\"))) {\n    throw new IllegalArgumentException(\"Numeric values must be finite, but was \" + value);\n  }\n  beforeValue();\n  out.append(string);\n  return this;\n}",
    "begin_line": 507,
    "end_line": 521,
    "comment": "/** \n * Encodes  {@code value}.\n * @param value a finite value. May not be {@link Double#isNaN() NaNs} or{@link Double#isInfinite() infinities}.\n * @return this writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.flush#527",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.flush()",
    "snippet": "public void flush() throws IOException {\n  if (stackSize \u003d\u003d 0) {\n    throw new IllegalStateException(\"JsonWriter is closed.\");\n  }\n  out.flush();\n}",
    "begin_line": 527,
    "end_line": 532,
    "comment": "/** \n * Ensures all buffered data is written to the underlying  {@link Writer}and flushes that writer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.close#539",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.close()",
    "snippet": "public void close() throws IOException {\n  out.close();\n  int size\u003dstackSize;\n  if (size \u003e 1 || size \u003d\u003d 1 \u0026\u0026 stack[size - 1] !\u003d NONEMPTY_DOCUMENT) {\n    throw new IOException(\"Incomplete document\");\n  }\n  stackSize\u003d0;\n}",
    "begin_line": 539,
    "end_line": 547,
    "comment": "/** \n * Flushes and closes this writer and the underlying  {@link Writer}.\n * @throws IOException if the JSON document is incomplete.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.string#549",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.string(java.lang.String)",
    "snippet": "private void string(String value) throws IOException {\n  String[] replacements\u003dhtmlSafe ? HTML_SAFE_REPLACEMENT_CHARS : REPLACEMENT_CHARS;\n  out.write(\"\\\"\");\n  int last\u003d0;\n  int length\u003dvalue.length();\n  for (int i\u003d0; i \u003c length; i++) {\n    char c\u003dvalue.charAt(i);\n    String replacement;\n    if (c \u003c 128) {\n      replacement\u003dreplacements[c];\n      if (replacement \u003d\u003d null) {\n        continue;\n      }\n    }\n else     if (c \u003d\u003d \u0027\\u2028\u0027) {\n      replacement\u003d\"\\\\u2028\";\n    }\n else     if (c \u003d\u003d \u0027\\u2029\u0027) {\n      replacement\u003d\"\\\\u2029\";\n    }\n else {\n      continue;\n    }\n    if (last \u003c i) {\n      out.write(value,last,i - last);\n    }\n    out.write(replacement);\n    last\u003di + 1;\n  }\n  if (last \u003c length) {\n    out.write(value,last,length - last);\n  }\n  out.write(\"\\\"\");\n}",
    "begin_line": 549,
    "end_line": 579,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.newline#581",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.newline()",
    "snippet": "private void newline() throws IOException {\n  if (indent \u003d\u003d null) {\n    return;\n  }\n  out.write(\"\\n\");\n  for (int i\u003d1, size\u003dstackSize; i \u003c size; i++) {\n    out.write(indent);\n  }\n}",
    "begin_line": 581,
    "end_line": 590,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.beforeName#596",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.beforeName()",
    "snippet": "private void beforeName() throws IOException {\n  int context\u003dpeek();\n  if (context \u003d\u003d NONEMPTY_OBJECT) {\n    out.write(\u0027,\u0027);\n  }\n else   if (context !\u003d EMPTY_OBJECT) {\n    throw new IllegalStateException(\"Nesting problem.\");\n  }\n  newline();\n  replaceTop(DANGLING_NAME);\n}",
    "begin_line": 596,
    "end_line": 605,
    "comment": "/** \n * Inserts any necessary separators and whitespace before a name. Also adjusts the stack to expect the name\u0027s value.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "JsonWriter.beforeValue#613",
    "is_bug": true,
    "src_path": "com/google/gson/stream/JsonWriter.java",
    "class_name": "com.google.gson.stream.JsonWriter",
    "signature": "com.google.gson.stream.JsonWriter.beforeValue()",
    "snippet": "@SuppressWarnings(\"fallthrough\") private void beforeValue() throws IOException {\nswitch (peek()) {\ncase NONEMPTY_DOCUMENT:    if (!lenient) {\n      throw new IllegalStateException(\"JSON must have only one top-level value.\");\n    }\ncase EMPTY_DOCUMENT:  replaceTop(NONEMPTY_DOCUMENT);\nbreak;\ncase EMPTY_ARRAY:replaceTop(NONEMPTY_ARRAY);\nnewline();\nbreak;\ncase NONEMPTY_ARRAY:out.append(\u0027,\u0027);\nnewline();\nbreak;\ncase DANGLING_NAME:out.append(separator);\nreplaceTop(NONEMPTY_OBJECT);\nbreak;\ndefault:throw new IllegalStateException(\"Nesting problem.\");\n}\n}",
    "begin_line": 613,
    "end_line": 643,
    "comment": "/** \n * Inserts any necessary separators and whitespace before a literal value, inline array, or inline object. Also adjusts the stack to expect either a closing bracket or another element.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]