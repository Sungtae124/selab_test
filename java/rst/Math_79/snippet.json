[
  {
    "name": "Cluster.Cluster#45",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/Cluster.java",
    "class_name": "org.apache.commons.math.stat.clustering.Cluster",
    "signature": "org.apache.commons.math.stat.clustering.Cluster.Cluster(T)",
    "snippet": "public Cluster(final T center){\n  this.center\u003dcenter;\n  points\u003dnew ArrayList\u003cT\u003e();\n}",
    "begin_line": 45,
    "end_line": 48,
    "comment": "/** \n * Build a cluster centered at a specified point.\n * @param center the point which is to be the center of this cluster\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Cluster.addPoint#54",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/Cluster.java",
    "class_name": "org.apache.commons.math.stat.clustering.Cluster",
    "signature": "org.apache.commons.math.stat.clustering.Cluster.addPoint(T)",
    "snippet": "public void addPoint(final T point){\n  points.add(point);\n}",
    "begin_line": 54,
    "end_line": 56,
    "comment": "/** \n * Add a point to this cluster.\n * @param point point to add\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Cluster.getPoints#62",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/Cluster.java",
    "class_name": "org.apache.commons.math.stat.clustering.Cluster",
    "signature": "org.apache.commons.math.stat.clustering.Cluster.getPoints()",
    "snippet": "public List\u003cT\u003e getPoints(){\n  return points;\n}",
    "begin_line": 62,
    "end_line": 64,
    "comment": "/** \n * Get the points contained in the cluster.\n * @return points contained in the cluster\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Cluster.getCenter#70",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/Cluster.java",
    "class_name": "org.apache.commons.math.stat.clustering.Cluster",
    "signature": "org.apache.commons.math.stat.clustering.Cluster.getCenter()",
    "snippet": "public T getCenter(){\n  return center;\n}",
    "begin_line": 70,
    "end_line": 72,
    "comment": "/** \n * Get the point chosen to be the center of this cluster.\n * @return chosen cluster center\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.EuclideanIntegerPoint#43",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.EuclideanIntegerPoint(int[])",
    "snippet": "public EuclideanIntegerPoint(final int[] point){\n  this.point\u003dpoint;\n}",
    "begin_line": 43,
    "end_line": 45,
    "comment": "/** \n * Build an instance wrapping an integer array. \u003cp\u003eThe wrapped array is referenced, it is \u003cem\u003enot\u003c/em\u003e copied.\u003c/p\u003e\n * @param point the n-dimensional point in integer space\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.getPoint#51",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.getPoint()",
    "snippet": "public int[] getPoint(){\n  return point;\n}",
    "begin_line": 51,
    "end_line": 53,
    "comment": "/** \n * Get the n-dimensional point in integer space.\n * @return a reference (not a copy!) to the wrapped array\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.distanceFrom#56",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.distanceFrom(org.apache.commons.math.stat.clustering.EuclideanIntegerPoint)",
    "snippet": "public double distanceFrom(final EuclideanIntegerPoint p){\n  return MathUtils.distance(point,p.getPoint());\n}",
    "begin_line": 56,
    "end_line": 58,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.centroidOf#61",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.centroidOf(java.util.Collection\u003corg.apache.commons.math.stat.clustering.EuclideanIntegerPoint\u003e)",
    "snippet": "public EuclideanIntegerPoint centroidOf(final Collection\u003cEuclideanIntegerPoint\u003e points){\n  int[] centroid\u003dnew int[getPoint().length];\n  for (  EuclideanIntegerPoint p : points) {\n    for (int i\u003d0; i \u003c centroid.length; i++) {\n      centroid[i]+\u003dp.getPoint()[i];\n    }\n  }\n  for (int i\u003d0; i \u003c centroid.length; i++) {\n    centroid[i]/\u003dpoints.size();\n  }\n  return new EuclideanIntegerPoint(centroid);\n}",
    "begin_line": 61,
    "end_line": 72,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.equals#76",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.equals(java.lang.Object)",
    "snippet": "@Override public boolean equals(final Object other){\n  if (!(other instanceof EuclideanIntegerPoint)) {\n    return false;\n  }\n  final int[] otherPoint\u003d((EuclideanIntegerPoint)other).getPoint();\n  if (point.length !\u003d otherPoint.length) {\n    return false;\n  }\n  for (int i\u003d0; i \u003c point.length; i++) {\n    if (point[i] !\u003d otherPoint[i]) {\n      return false;\n    }\n  }\n  return true;\n}",
    "begin_line": 76,
    "end_line": 90,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.hashCode#94",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.hashCode()",
    "snippet": "@Override public int hashCode(){\n  int hashCode\u003d0;\n  for (  Integer i : point) {\n    hashCode+\u003di.hashCode() * 13 + 7;\n  }\n  return hashCode;\n}",
    "begin_line": 94,
    "end_line": 100,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "EuclideanIntegerPoint.toString#104",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/EuclideanIntegerPoint.java",
    "class_name": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint",
    "signature": "org.apache.commons.math.stat.clustering.EuclideanIntegerPoint.toString()",
    "snippet": "@Override public String toString(){\n  final StringBuffer buff\u003dnew StringBuffer(\"(\");\n  final int[] coordinates\u003dgetPoint();\n  for (int i\u003d0; i \u003c coordinates.length; i++) {\n    buff.append(coordinates[i]);\n    if (i \u003c coordinates.length - 1) {\n      buff.append(\",\");\n    }\n  }\n  buff.append(\")\");\n  return buff.toString();\n}",
    "begin_line": 104,
    "end_line": 115,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "KMeansPlusPlusClusterer.KMeansPlusPlusClusterer#40",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java",
    "class_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer",
    "signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.KMeansPlusPlusClusterer(java.util.Random)",
    "snippet": "public KMeansPlusPlusClusterer(final Random random){\n  this.random\u003drandom;\n}",
    "begin_line": 40,
    "end_line": 42,
    "comment": "/** \n * Build a clusterer.\n * @param random random generator to use for choosing initial centers\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "KMeansPlusPlusClusterer.cluster#53",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java",
    "class_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer",
    "signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.cluster(java.util.Collection\u003cT\u003e, int, int)",
    "snippet": "public List\u003cCluster\u003cT\u003e\u003e cluster(final Collection\u003cT\u003e points,final int k,final int maxIterations){\n  List\u003cCluster\u003cT\u003e\u003e clusters\u003dchooseInitialCenters(points,k,random);\n  assignPointsToClusters(clusters,points);\n  final int max\u003d(maxIterations \u003c 0) ? Integer.MAX_VALUE : maxIterations;\n  for (int count\u003d0; count \u003c max; count++) {\n    boolean clusteringChanged\u003dfalse;\n    List\u003cCluster\u003cT\u003e\u003e newClusters\u003dnew ArrayList\u003cCluster\u003cT\u003e\u003e();\n    for (    final Cluster\u003cT\u003e cluster : clusters) {\n      final T newCenter\u003dcluster.getCenter().centroidOf(cluster.getPoints());\n      if (!newCenter.equals(cluster.getCenter())) {\n        clusteringChanged\u003dtrue;\n      }\n      newClusters.add(new Cluster\u003cT\u003e(newCenter));\n    }\n    if (!clusteringChanged) {\n      return clusters;\n    }\n    assignPointsToClusters(newClusters,points);\n    clusters\u003dnewClusters;\n  }\n  return clusters;\n}",
    "begin_line": 53,
    "end_line": 78,
    "comment": "/** \n * Runs the K-means++ clustering algorithm.\n * @param points the points to cluster\n * @param k the number of clusters to split the data into\n * @param maxIterations the maximum number of iterations to run the algorithmfor.  If negative, no maximum will be used\n * @return a list of clusters containing the points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "KMeansPlusPlusClusterer.assignPointsToClusters#88",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java",
    "class_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer",
    "signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.assignPointsToClusters(java.util.Collection\u003corg.apache.commons.math.stat.clustering.Cluster\u003cT\u003e\u003e, java.util.Collection\u003cT\u003e)",
    "snippet": "private static \u003cT extends Clusterable\u003cT\u003e\u003evoid assignPointsToClusters(final Collection\u003cCluster\u003cT\u003e\u003e clusters,final Collection\u003cT\u003e points){\n  for (  final T p : points) {\n    Cluster\u003cT\u003e cluster\u003dgetNearestCluster(clusters,p);\n    cluster.addPoint(p);\n  }\n}",
    "begin_line": 88,
    "end_line": 93,
    "comment": "/** \n * Adds the given points to the closest  {@link Cluster}.\n * @param \u003c T \u003e type of the points to cluster\n * @param clusters the {@link Cluster}s to add the points to\n * @param points the points to add to the given {@link Cluster}s\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "KMeansPlusPlusClusterer.chooseInitialCenters#105",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java",
    "class_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer",
    "signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.chooseInitialCenters(java.util.Collection\u003cT\u003e, int, java.util.Random)",
    "snippet": "private static \u003cT extends Clusterable\u003cT\u003e\u003eList\u003cCluster\u003cT\u003e\u003e chooseInitialCenters(final Collection\u003cT\u003e points,final int k,final Random random){\n  final List\u003cT\u003e pointSet\u003dnew ArrayList\u003cT\u003e(points);\n  final List\u003cCluster\u003cT\u003e\u003e resultSet\u003dnew ArrayList\u003cCluster\u003cT\u003e\u003e();\n  final T firstPoint\u003dpointSet.remove(random.nextInt(pointSet.size()));\n  resultSet.add(new Cluster\u003cT\u003e(firstPoint));\n  final double[] dx2\u003dnew double[pointSet.size()];\n  while (resultSet.size() \u003c k) {\n    int sum\u003d0;\n    for (int i\u003d0; i \u003c pointSet.size(); i++) {\n      final T p\u003dpointSet.get(i);\n      final Cluster\u003cT\u003e nearest\u003dgetNearestCluster(resultSet,p);\n      final double d\u003dp.distanceFrom(nearest.getCenter());\n      sum+\u003dd * d;\n      dx2[i]\u003dsum;\n    }\n    final double r\u003drandom.nextDouble() * sum;\n    for (int i\u003d0; i \u003c dx2.length; i++) {\n      if (dx2[i] \u003e\u003d r) {\n        final T p\u003dpointSet.remove(i);\n        resultSet.add(new Cluster\u003cT\u003e(p));\n        break;\n      }\n    }\n  }\n  return resultSet;\n}",
    "begin_line": 105,
    "end_line": 141,
    "comment": "/** \n * Use K-means++ to choose the initial centers.\n * @param \u003c T \u003e type of the points to cluster\n * @param points the points to choose the initial centers from\n * @param k the number of centers to choose\n * @param random random generator to use\n * @return the initial centers\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "KMeansPlusPlusClusterer.getNearestCluster#152",
    "is_bug": true,
    "src_path": "org/apache/commons/math/stat/clustering/KMeansPlusPlusClusterer.java",
    "class_name": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer",
    "signature": "org.apache.commons.math.stat.clustering.KMeansPlusPlusClusterer.getNearestCluster(java.util.Collection\u003corg.apache.commons.math.stat.clustering.Cluster\u003cT\u003e\u003e, T)",
    "snippet": "private static \u003cT extends Clusterable\u003cT\u003e\u003eCluster\u003cT\u003e getNearestCluster(final Collection\u003cCluster\u003cT\u003e\u003e clusters,final T point){\n  double minDistance\u003dDouble.MAX_VALUE;\n  Cluster\u003cT\u003e minCluster\u003dnull;\n  for (  final Cluster\u003cT\u003e c : clusters) {\n    final double distance\u003dpoint.distanceFrom(c.getCenter());\n    if (distance \u003c minDistance) {\n      minDistance\u003ddistance;\n      minCluster\u003dc;\n    }\n  }\n  return minCluster;\n}",
    "begin_line": 152,
    "end_line": 163,
    "comment": "/** \n * Returns the nearest  {@link Cluster} to the given point\n * @param \u003c T \u003e type of the points to cluster\n * @param clusters the {@link Cluster}s to search\n * @param point the point to find the nearest {@link Cluster} for\n * @return the nearest {@link Cluster} to the given point\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.MathUtils#81",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.MathUtils()",
    "snippet": "private MathUtils(){\n  super();\n}",
    "begin_line": 81,
    "end_line": 83,
    "comment": "/** \n * Private Constructor\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.addAndCheck#95",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.addAndCheck(int, int)",
    "snippet": "public static int addAndCheck(int x,int y){\n  long s\u003d(long)x + (long)y;\n  if (s \u003c Integer.MIN_VALUE || s \u003e Integer.MAX_VALUE) {\n    throw new ArithmeticException(\"overflow: add\");\n  }\n  return (int)s;\n}",
    "begin_line": 95,
    "end_line": 101,
    "comment": "/** \n * Add two integers, checking for overflow.\n * @param x an addend\n * @param y an addend\n * @return the sum \u003ccode\u003ex+y\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anint\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.addAndCheck#113",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.addAndCheck(long, long)",
    "snippet": "public static long addAndCheck(long a,long b){\n  return addAndCheck(a,b,\"overflow: add\");\n}",
    "begin_line": 113,
    "end_line": 115,
    "comment": "/** \n * Add two long integers, checking for overflow.\n * @param a an addend\n * @param b an addend\n * @return the sum \u003ccode\u003ea+b\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anlong\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.addAndCheck#128",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.addAndCheck(long, long, java.lang.String)",
    "snippet": "private static long addAndCheck(long a,long b,String msg){\n  long ret;\n  if (a \u003e b) {\n    ret\u003daddAndCheck(b,a,msg);\n  }\n else {\n    if (a \u003c 0) {\n      if (b \u003c 0) {\n        if (Long.MIN_VALUE - b \u003c\u003d a) {\n          ret\u003da + b;\n        }\n else {\n          throw new ArithmeticException(msg);\n        }\n      }\n else {\n        ret\u003da + b;\n      }\n    }\n else {\n      if (a \u003c\u003d Long.MAX_VALUE - b) {\n        ret\u003da + b;\n      }\n else {\n        throw new ArithmeticException(msg);\n      }\n    }\n  }\n  return ret;\n}",
    "begin_line": 128,
    "end_line": 161,
    "comment": "/** \n * Add two long integers, checking for overflow.\n * @param a an addend\n * @param b an addend\n * @param msg the message to use for any thrown exception.\n * @return the sum \u003ccode\u003ea+b\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anlong\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.binomialCoefficient#188",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.binomialCoefficient(int, int)",
    "snippet": "public static long binomialCoefficient(final int n,final int k){\n  checkBinomial(n,k);\n  if ((n \u003d\u003d k) || (k \u003d\u003d 0)) {\n    return 1;\n  }\n  if ((k \u003d\u003d 1) || (k \u003d\u003d n - 1)) {\n    return n;\n  }\n  if (k \u003e n / 2)   return binomialCoefficient(n,n - k);\n  long result\u003d1;\n  if (n \u003c\u003d 61) {\n    int i\u003dn - k + 1;\n    for (int j\u003d1; j \u003c\u003d k; j++) {\n      result\u003dresult * i / j;\n      i++;\n    }\n  }\n else   if (n \u003c\u003d 66) {\n    int i\u003dn - k + 1;\n    for (int j\u003d1; j \u003c\u003d k; j++) {\n      final long d\u003dgcd(i,j);\n      result\u003d(result / (j / d)) * (i / d);\n      i++;\n    }\n  }\n else {\n    int i\u003dn - k + 1;\n    for (int j\u003d1; j \u003c\u003d k; j++) {\n      final long d\u003dgcd(i,j);\n      result\u003dmulAndCheck(result / (j / d),i / d);\n      i++;\n    }\n  }\n  return result;\n}",
    "begin_line": 188,
    "end_line": 240,
    "comment": "/** \n * Returns an exact representation of the \u003ca href\u003d\"http://mathworld.wolfram.com/BinomialCoefficient.html\"\u003e Binomial Coefficient\u003c/a\u003e, \"\u003ccode\u003en choose k\u003c/code\u003e\", the number of \u003ccode\u003ek\u003c/code\u003e-element subsets that can be selected from an \u003ccode\u003en\u003c/code\u003e-element set. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e \u003ccode\u003e0 \u003c\u003d k \u003c\u003d n \u003c/code\u003e (otherwise \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown)\u003c/li\u003e \u003cli\u003e The result is small enough to fit into a \u003ccode\u003elong\u003c/code\u003e. The largest value of \u003ccode\u003en\u003c/code\u003e for which all coefficients are \u003ccode\u003e \u003c Long.MAX_VALUE\u003c/code\u003e is 66. If the computed value exceeds \u003ccode\u003eLong.MAX_VALUE\u003c/code\u003e an \u003ccode\u003eArithMeticException\u003c/code\u003e is thrown.\u003c/li\u003e \u003c/ul\u003e\u003c/p\u003e\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return \u003ccode\u003en choose k\u003c/code\u003e\n * @throws IllegalArgumentException if preconditions are not met.\n * @throws ArithmeticException if the result is too large to be representedby a long integer.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.binomialCoefficientDouble#264",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.binomialCoefficientDouble(int, int)",
    "snippet": "public static double binomialCoefficientDouble(final int n,final int k){\n  checkBinomial(n,k);\n  if ((n \u003d\u003d k) || (k \u003d\u003d 0)) {\n    return 1d;\n  }\n  if ((k \u003d\u003d 1) || (k \u003d\u003d n - 1)) {\n    return n;\n  }\n  if (k \u003e n / 2) {\n    return binomialCoefficientDouble(n,n - k);\n  }\n  if (n \u003c 67) {\n    return binomialCoefficient(n,k);\n  }\n  double result\u003d1d;\n  for (int i\u003d1; i \u003c\u003d k; i++) {\n    result*\u003d(double)(n - k + i) / (double)i;\n  }\n  return Math.floor(result + 0.5);\n}",
    "begin_line": 264,
    "end_line": 285,
    "comment": "/** \n * Returns a \u003ccode\u003edouble\u003c/code\u003e representation of the \u003ca href\u003d\"http://mathworld.wolfram.com/BinomialCoefficient.html\"\u003e Binomial Coefficient\u003c/a\u003e, \"\u003ccode\u003en choose k\u003c/code\u003e\", the number of \u003ccode\u003ek\u003c/code\u003e-element subsets that can be selected from an \u003ccode\u003en\u003c/code\u003e-element set. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e \u003ccode\u003e0 \u003c\u003d k \u003c\u003d n \u003c/code\u003e (otherwise \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown)\u003c/li\u003e \u003cli\u003e The result is small enough to fit into a \u003ccode\u003edouble\u003c/code\u003e. The largest value of \u003ccode\u003en\u003c/code\u003e for which all coefficients are \u003c Double.MAX_VALUE is 1029. If the computed value exceeds Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned\u003c/li\u003e \u003c/ul\u003e\u003c/p\u003e\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return \u003ccode\u003en choose k\u003c/code\u003e\n * @throws IllegalArgumentException if preconditions are not met.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.binomialCoefficientLog#305",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.binomialCoefficientLog(int, int)",
    "snippet": "public static double binomialCoefficientLog(final int n,final int k){\n  checkBinomial(n,k);\n  if ((n \u003d\u003d k) || (k \u003d\u003d 0)) {\n    return 0;\n  }\n  if ((k \u003d\u003d 1) || (k \u003d\u003d n - 1)) {\n    return Math.log(n);\n  }\n  if (n \u003c 67) {\n    return Math.log(binomialCoefficient(n,k));\n  }\n  if (n \u003c 1030) {\n    return Math.log(binomialCoefficientDouble(n,k));\n  }\n  if (k \u003e n / 2) {\n    return binomialCoefficientLog(n,n - k);\n  }\n  double logSum\u003d0;\n  for (int i\u003dn - k + 1; i \u003c\u003d n; i++) {\n    logSum+\u003dMath.log(i);\n  }\n  for (int i\u003d2; i \u003c\u003d k; i++) {\n    logSum-\u003dMath.log(i);\n  }\n  return logSum;\n}",
    "begin_line": 305,
    "end_line": 350,
    "comment": "/** \n * Returns the natural \u003ccode\u003elog\u003c/code\u003e of the \u003ca href\u003d\"http://mathworld.wolfram.com/BinomialCoefficient.html\"\u003e Binomial Coefficient\u003c/a\u003e, \"\u003ccode\u003en choose k\u003c/code\u003e\", the number of \u003ccode\u003ek\u003c/code\u003e-element subsets that can be selected from an \u003ccode\u003en\u003c/code\u003e-element set. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e \u003ccode\u003e0 \u003c\u003d k \u003c\u003d n \u003c/code\u003e (otherwise \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown)\u003c/li\u003e \u003c/ul\u003e\u003c/p\u003e\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @return \u003ccode\u003en choose k\u003c/code\u003e\n * @throws IllegalArgumentException if preconditions are not met.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.checkBinomial#358",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.checkBinomial(int, int)",
    "snippet": "private static void checkBinomial(final int n,final int k) throws IllegalArgumentException {\n  if (n \u003c k) {\n    throw MathRuntimeException.createIllegalArgumentException(\"must have n \u003e\u003d k for binomial coefficient (n,k), got n \u003d {0}, k \u003d {1}\",n,k);\n  }\n  if (n \u003c 0) {\n    throw MathRuntimeException.createIllegalArgumentException(\"must have n \u003e\u003d 0 for binomial coefficient (n,k), got n \u003d {0}\",n);\n  }\n}",
    "begin_line": 358,
    "end_line": 370,
    "comment": "/** \n * Check binomial preconditions.\n * @param n the size of the set\n * @param k the size of the subsets to be counted\n * @exception IllegalArgumentException if preconditions are not met.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.compareTo#382",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.compareTo(double, double, double)",
    "snippet": "public static int compareTo(double x,double y,double eps){\n  if (equals(x,y,eps)) {\n    return 0;\n  }\n else   if (x \u003c y) {\n    return -1;\n  }\n  return 1;\n}",
    "begin_line": 382,
    "end_line": 389,
    "comment": "/** \n * Compares two numbers given some amount of allowed error.\n * @param x the first number\n * @param y the second number\n * @param eps the amount of error to allow when checking for equality\n * @return \u003cul\u003e\u003cli\u003e0 if  {@link #equals(double,double,double) equals(x, y, eps)}\u003c/li\u003e \u003cli\u003e\u0026lt; 0 if ! {@link #equals(double,double,double) equals(x, y, eps)} \u0026amp;\u0026amp; x \u0026lt; y\u003c/li\u003e\u003cli\u003e\u003e 0 if ! {@link #equals(double,double,double) equals(x, y, eps)} \u0026amp;\u0026amp; x \u003e y\u003c/li\u003e\u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.cosh#398",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.cosh(double)",
    "snippet": "public static double cosh(double x){\n  return (Math.exp(x) + Math.exp(-x)) / 2.0;\n}",
    "begin_line": 398,
    "end_line": 400,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/HyperbolicCosine.html\"\u003e hyperbolic cosine\u003c/a\u003e of x.\n * @param x double value for which to find the hyperbolic cosine\n * @return hyperbolic cosine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#410",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double, double)",
    "snippet": "public static boolean equals(double x,double y){\n  return (Double.isNaN(x) \u0026\u0026 Double.isNaN(y)) || x \u003d\u003d y;\n}",
    "begin_line": 410,
    "end_line": 412,
    "comment": "/** \n * Returns true iff both arguments are NaN or neither is NaN and they are equal\n * @param x first value\n * @param y second value\n * @return true if the values are equal or both are NaN\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#426",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double, double, double)",
    "snippet": "public static boolean equals(double x,double y,double eps){\n  return equals(x,y) || (Math.abs(y - x) \u003c\u003d eps);\n}",
    "begin_line": 426,
    "end_line": 428,
    "comment": "/** \n * Returns true iff both arguments are equal or within the range of allowed error (inclusive). \u003cp\u003e Two NaNs are considered equals, as are two infinities with same sign. \u003c/p\u003e\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow\n * @return true if the values are equal or within range of each other\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#444",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double, double, int)",
    "snippet": "public static boolean equals(double x,double y,int maxUlps){\n  assert maxUlps \u003e 0 \u0026\u0026 maxUlps \u003c NAN_GAP;\n  long xInt\u003dDouble.doubleToLongBits(x);\n  long yInt\u003dDouble.doubleToLongBits(y);\n  if (xInt \u003c 0) {\n    xInt\u003dSGN_MASK - xInt;\n  }\n  if (yInt \u003c 0) {\n    yInt\u003dSGN_MASK - yInt;\n  }\n  return Math.abs(xInt - yInt) \u003c\u003d maxUlps;\n}",
    "begin_line": 444,
    "end_line": 461,
    "comment": "/** \n * Returns true iff both arguments are equal or within the range of allowed error (inclusive). Adapted from \u003ca href\u003d\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"\u003e Bruce Dawson\u003c/a\u003e\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if there are less than {@code maxUlps} floatingpoint values between  {@code x} and {@code y}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.equals#473",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.equals(double[], double[])",
    "snippet": "public static boolean equals(double[] x,double[] y){\n  if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n    return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n  }\n  if (x.length !\u003d y.length) {\n    return false;\n  }\n  for (int i\u003d0; i \u003c x.length; ++i) {\n    if (!equals(x[i],y[i])) {\n      return false;\n    }\n  }\n  return true;\n}",
    "begin_line": 473,
    "end_line": 486,
    "comment": "/** \n * Returns true iff both arguments are null or have same dimensions and all their elements are  {@link #equals(double,double) equals}\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimensionand equal elements\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.factorial#510",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.factorial(int)",
    "snippet": "public static long factorial(final int n){\n  if (n \u003c 0) {\n    throw MathRuntimeException.createIllegalArgumentException(\"must have n \u003e\u003d 0 for n!, got n \u003d {0}\",n);\n  }\n  if (n \u003e 20) {\n    throw new ArithmeticException(\"factorial value is too large to fit in a long\");\n  }\n  return FACTORIALS[n];\n}",
    "begin_line": 510,
    "end_line": 521,
    "comment": "/** \n * Returns n!. Shorthand for \u003ccode\u003en\u003c/code\u003e \u003ca href\u003d\"http://mathworld.wolfram.com/Factorial.html\"\u003e Factorial\u003c/a\u003e, the product of the numbers \u003ccode\u003e1,...,n\u003c/code\u003e. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e \u003ccode\u003en \u003e\u003d 0\u003c/code\u003e (otherwise \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown)\u003c/li\u003e \u003cli\u003e The result is small enough to fit into a \u003ccode\u003elong\u003c/code\u003e. The largest value of \u003ccode\u003en\u003c/code\u003e for which \u003ccode\u003en!\u003c/code\u003e \u003c Long.MAX_VALUE\u003c/code\u003e is 20. If the computed value exceeds \u003ccode\u003eLong.MAX_VALUE\u003c/code\u003e an \u003ccode\u003eArithMeticException \u003c/code\u003e is thrown.\u003c/li\u003e \u003c/ul\u003e \u003c/p\u003e\n * @param n argument\n * @return \u003ccode\u003en!\u003c/code\u003e\n * @throws ArithmeticException if the result is too large to be representedby a long integer.\n * @throws IllegalArgumentException if n \u003c 0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.factorialDouble#543",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.factorialDouble(int)",
    "snippet": "public static double factorialDouble(final int n){\n  if (n \u003c 0) {\n    throw MathRuntimeException.createIllegalArgumentException(\"must have n \u003e\u003d 0 for n!, got n \u003d {0}\",n);\n  }\n  if (n \u003c 21) {\n    return factorial(n);\n  }\n  return Math.floor(Math.exp(factorialLog(n)) + 0.5);\n}",
    "begin_line": 543,
    "end_line": 553,
    "comment": "/** \n * Returns n!. Shorthand for \u003ccode\u003en\u003c/code\u003e \u003ca href\u003d\"http://mathworld.wolfram.com/Factorial.html\"\u003e Factorial\u003c/a\u003e, the product of the numbers \u003ccode\u003e1,...,n\u003c/code\u003e as a \u003ccode\u003edouble\u003c/code\u003e. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e \u003ccode\u003en \u003e\u003d 0\u003c/code\u003e (otherwise \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown)\u003c/li\u003e \u003cli\u003e The result is small enough to fit into a \u003ccode\u003edouble\u003c/code\u003e. The largest value of \u003ccode\u003en\u003c/code\u003e for which \u003ccode\u003en!\u003c/code\u003e \u003c Double.MAX_VALUE\u003c/code\u003e is 170. If the computed value exceeds Double.MAX_VALUE, Double.POSITIVE_INFINITY is returned\u003c/li\u003e \u003c/ul\u003e \u003c/p\u003e\n * @param n argument\n * @return \u003ccode\u003en!\u003c/code\u003e\n * @throws IllegalArgumentException if n \u003c 0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.factorialLog#568",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.factorialLog(int)",
    "snippet": "public static double factorialLog(final int n){\n  if (n \u003c 0) {\n    throw MathRuntimeException.createIllegalArgumentException(\"must have n \u003e\u003d 0 for n!, got n \u003d {0}\",n);\n  }\n  if (n \u003c 21) {\n    return Math.log(factorial(n));\n  }\n  double logSum\u003d0;\n  for (int i\u003d2; i \u003c\u003d n; i++) {\n    logSum+\u003dMath.log(i);\n  }\n  return logSum;\n}",
    "begin_line": 568,
    "end_line": 582,
    "comment": "/** \n * Returns the natural logarithm of n!. \u003cp\u003e \u003cStrong\u003ePreconditions\u003c/strong\u003e: \u003cul\u003e \u003cli\u003e \u003ccode\u003en \u003e\u003d 0\u003c/code\u003e (otherwise \u003ccode\u003eIllegalArgumentException\u003c/code\u003e is thrown)\u003c/li\u003e \u003c/ul\u003e\u003c/p\u003e\n * @param n argument\n * @return \u003ccode\u003en!\u003c/code\u003e\n * @throws IllegalArgumentException if preconditions are not met.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.gcd#614",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.gcd(int, int)",
    "snippet": "public static int gcd(final int p,final int q){\n  int u\u003dp;\n  int v\u003dq;\n  if ((u \u003d\u003d 0) || (v \u003d\u003d 0)) {\n    if ((u \u003d\u003d Integer.MIN_VALUE) || (v \u003d\u003d Integer.MIN_VALUE)) {\n      throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\",p,q);\n    }\n    return Math.abs(u) + Math.abs(v);\n  }\n  if (u \u003e 0) {\n    u\u003d-u;\n  }\n  if (v \u003e 0) {\n    v\u003d-v;\n  }\n  int k\u003d0;\n  while ((u \u0026 1) \u003d\u003d 0 \u0026\u0026 (v \u0026 1) \u003d\u003d 0 \u0026\u0026 k \u003c 31) {\n    u/\u003d2;\n    v/\u003d2;\n    k++;\n  }\n  if (k \u003d\u003d 31) {\n    throw MathRuntimeException.createArithmeticException(\"overflow: gcd({0}, {1}) is 2^31\",p,q);\n  }\n  int t\u003d((u \u0026 1) \u003d\u003d 1) ? v : -(u / 2);\n  do {\n    while ((t \u0026 1) \u003d\u003d 0) {\n      t/\u003d2;\n    }\n    if (t \u003e 0) {\n      u\u003d-t;\n    }\n else {\n      v\u003dt;\n    }\n    t\u003d(v - u) / 2;\n  }\n while (t !\u003d 0);\n  return -u * (1 \u003c\u003c k);\n}",
    "begin_line": 614,
    "end_line": 672,
    "comment": "/** \n * \u003cp\u003e Gets the greatest common divisor of the absolute value of two numbers, using the \"binary gcd\" method which avoids division and modulo operations. See Knuth 4.5.2 algorithm B. This algorithm is due to Josef Stein (1961). \u003c/p\u003e Special cases: \u003cul\u003e \u003cli\u003eThe invocations \u003ccode\u003egcd(Integer.MIN_VALUE, Integer.MIN_VALUE)\u003c/code\u003e, \u003ccode\u003egcd(Integer.MIN_VALUE, 0)\u003c/code\u003e and \u003ccode\u003egcd(0, Integer.MIN_VALUE)\u003c/code\u003e throw an \u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which is too large for an int value.\u003c/li\u003e \u003cli\u003eThe result of \u003ccode\u003egcd(x, x)\u003c/code\u003e, \u003ccode\u003egcd(0, x)\u003c/code\u003e and \u003ccode\u003egcd(x, 0)\u003c/code\u003e is the absolute value of \u003ccode\u003ex\u003c/code\u003e, except for the special cases above. \u003cli\u003eThe invocation \u003ccode\u003egcd(0, 0)\u003c/code\u003e is the only one which returns \u003ccode\u003e0\u003c/code\u003e.\u003c/li\u003e \u003c/ul\u003e\n * @param p any number\n * @param q any number\n * @return the greatest common divisor, never negative\n * @throws ArithmeticException if the result cannot be represented as a nonnegative int value\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.hash#680",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.hash(double)",
    "snippet": "public static int hash(double value){\n  return new Double(value).hashCode();\n}",
    "begin_line": 680,
    "end_line": 682,
    "comment": "/** \n * Returns an integer hash code representing the given double value.\n * @param value the value to be hashed\n * @return the hash code\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.hash#691",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.hash(double[])",
    "snippet": "public static int hash(double[] value){\n  return Arrays.hashCode(value);\n}",
    "begin_line": 691,
    "end_line": 693,
    "comment": "/** \n * Returns an integer hash code representing the given double array.\n * @param value the value to be hashed (may be null)\n * @return the hash code\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#702",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(byte)",
    "snippet": "public static byte indicator(final byte x){\n  return (x \u003e\u003d ZB) ? PB : NB;\n}",
    "begin_line": 702,
    "end_line": 704,
    "comment": "/** \n * For a byte value x, this method returns (byte)(+1) if x \u003e\u003d 0 and (byte)(-1) if x \u003c 0.\n * @param x the value, a byte\n * @return (byte)(+1) or (byte)(-1), depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#714",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(double)",
    "snippet": "public static double indicator(final double x){\n  if (Double.isNaN(x)) {\n    return Double.NaN;\n  }\n  return (x \u003e\u003d 0.0) ? 1.0 : -1.0;\n}",
    "begin_line": 714,
    "end_line": 719,
    "comment": "/** \n * For a double precision value x, this method returns +1.0 if x \u003e\u003d 0 and -1.0 if x \u003c 0. Returns \u003ccode\u003eNaN\u003c/code\u003e if \u003ccode\u003ex\u003c/code\u003e is \u003ccode\u003eNaN\u003c/code\u003e.\n * @param x the value, a double\n * @return +1.0 or -1.0, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#728",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(float)",
    "snippet": "public static float indicator(final float x){\n  if (Float.isNaN(x)) {\n    return Float.NaN;\n  }\n  return (x \u003e\u003d 0.0F) ? 1.0F : -1.0F;\n}",
    "begin_line": 728,
    "end_line": 733,
    "comment": "/** \n * For a float value x, this method returns +1.0F if x \u003e\u003d 0 and -1.0F if x \u003c 0. Returns \u003ccode\u003eNaN\u003c/code\u003e if \u003ccode\u003ex\u003c/code\u003e is \u003ccode\u003eNaN\u003c/code\u003e.\n * @param x the value, a float\n * @return +1.0F or -1.0F, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#741",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(int)",
    "snippet": "public static int indicator(final int x){\n  return (x \u003e\u003d 0) ? 1 : -1;\n}",
    "begin_line": 741,
    "end_line": 743,
    "comment": "/** \n * For an int value x, this method returns +1 if x \u003e\u003d 0 and -1 if x \u003c 0.\n * @param x the value, an int\n * @return +1 or -1, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#751",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(long)",
    "snippet": "public static long indicator(final long x){\n  return (x \u003e\u003d 0L) ? 1L : -1L;\n}",
    "begin_line": 751,
    "end_line": 753,
    "comment": "/** \n * For a long value x, this method returns +1L if x \u003e\u003d 0 and -1L if x \u003c 0.\n * @param x the value, a long\n * @return +1L or -1L, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.indicator#762",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.indicator(short)",
    "snippet": "public static short indicator(final short x){\n  return (x \u003e\u003d ZS) ? PS : NS;\n}",
    "begin_line": 762,
    "end_line": 764,
    "comment": "/** \n * For a short value x, this method returns (short)(+1) if x \u003e\u003d 0 and (short)(-1) if x \u003c 0.\n * @param x the value, a short\n * @return (short)(+1) or (short)(-1), depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.lcm#789",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.lcm(int, int)",
    "snippet": "public static int lcm(int a,int b){\n  if (a \u003d\u003d 0 || b \u003d\u003d 0) {\n    return 0;\n  }\n  int lcm\u003dMath.abs(mulAndCheck(a / gcd(a,b),b));\n  if (lcm \u003d\u003d Integer.MIN_VALUE) {\n    throw new ArithmeticException(\"overflow: lcm is 2^31\");\n  }\n  return lcm;\n}",
    "begin_line": 789,
    "end_line": 798,
    "comment": "/** \n * \u003cp\u003e Returns the least common multiple of the absolute value of two numbers, using the formula \u003ccode\u003elcm(a,b) \u003d (a / gcd(a,b)) * b\u003c/code\u003e. \u003c/p\u003e Special cases: \u003cul\u003e \u003cli\u003eThe invocations \u003ccode\u003elcm(Integer.MIN_VALUE, n)\u003c/code\u003e and \u003ccode\u003elcm(n, Integer.MIN_VALUE)\u003c/code\u003e, where \u003ccode\u003eabs(n)\u003c/code\u003e is a power of 2, throw an \u003ccode\u003eArithmeticException\u003c/code\u003e, because the result would be 2^31, which is too large for an int value.\u003c/li\u003e \u003cli\u003eThe result of \u003ccode\u003elcm(0, x)\u003c/code\u003e and \u003ccode\u003elcm(x, 0)\u003c/code\u003e is \u003ccode\u003e0\u003c/code\u003e for any \u003ccode\u003ex\u003c/code\u003e. \u003c/ul\u003e\n * @param a any number\n * @param b any number\n * @return the least common multiple, never negative\n * @throws ArithmeticException if the result cannot be represented as a nonnegative int value\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.log#816",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.log(double, double)",
    "snippet": "public static double log(double base,double x){\n  return Math.log(x) / Math.log(base);\n}",
    "begin_line": 816,
    "end_line": 818,
    "comment": "/** \n * \u003cp\u003eReturns the \u003ca href\u003d\"http://mathworld.wolfram.com/Logarithm.html\"\u003elogarithm\u003c/a\u003e for base \u003ccode\u003eb\u003c/code\u003e of \u003ccode\u003ex\u003c/code\u003e. \u003c/p\u003e \u003cp\u003eReturns \u003ccode\u003eNaN\u003ccode\u003e if either argument is negative.  If \u003ccode\u003ebase\u003c/code\u003e is 0 and \u003ccode\u003ex\u003c/code\u003e is positive, 0 is returned. If \u003ccode\u003ebase\u003c/code\u003e is positive and \u003ccode\u003ex\u003c/code\u003e is 0, \u003ccode\u003eDouble.NEGATIVE_INFINITY\u003c/code\u003e is returned.  If both arguments are 0, the result is \u003ccode\u003eNaN\u003c/code\u003e.\u003c/p\u003e\n * @param base the base of the logarithm, must be greater than 0\n * @param x argument, must be greater than 0\n * @return the value of the logarithm - the number y such that base^y \u003d x.\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.mulAndCheck#830",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.mulAndCheck(int, int)",
    "snippet": "public static int mulAndCheck(int x,int y){\n  long m\u003d((long)x) * ((long)y);\n  if (m \u003c Integer.MIN_VALUE || m \u003e Integer.MAX_VALUE) {\n    throw new ArithmeticException(\"overflow: mul\");\n  }\n  return (int)m;\n}",
    "begin_line": 830,
    "end_line": 836,
    "comment": "/** \n * Multiply two integers, checking for overflow.\n * @param x a factor\n * @param y a factor\n * @return the product \u003ccode\u003ex*y\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anint\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.mulAndCheck#848",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.mulAndCheck(long, long)",
    "snippet": "public static long mulAndCheck(long a,long b){\n  long ret;\n  String msg\u003d\"overflow: multiply\";\n  if (a \u003e b) {\n    ret\u003dmulAndCheck(b,a);\n  }\n else {\n    if (a \u003c 0) {\n      if (b \u003c 0) {\n        if (a \u003e\u003d Long.MAX_VALUE / b) {\n          ret\u003da * b;\n        }\n else {\n          throw new ArithmeticException(msg);\n        }\n      }\n else       if (b \u003e 0) {\n        if (Long.MIN_VALUE / b \u003c\u003d a) {\n          ret\u003da * b;\n        }\n else {\n          throw new ArithmeticException(msg);\n        }\n      }\n else {\n        ret\u003d0;\n      }\n    }\n else     if (a \u003e 0) {\n      if (a \u003c\u003d Long.MAX_VALUE / b) {\n        ret\u003da * b;\n      }\n else {\n        throw new ArithmeticException(msg);\n      }\n    }\n else {\n      ret\u003d0;\n    }\n  }\n  return ret;\n}",
    "begin_line": 848,
    "end_line": 891,
    "comment": "/** \n * Multiply two long integers, checking for overflow.\n * @param a first value\n * @param b second value\n * @return the product \u003ccode\u003ea * b\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anlong\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.nextAfter#910",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.nextAfter(double, double)",
    "snippet": "public static double nextAfter(double d,double direction){\n  if (Double.isNaN(d) || Double.isInfinite(d)) {\n    return d;\n  }\n else   if (d \u003d\u003d 0) {\n    return (direction \u003c 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n  }\n  long bits\u003dDouble.doubleToLongBits(d);\n  long sign\u003dbits \u0026 0x8000000000000000L;\n  long exponent\u003dbits \u0026 0x7ff0000000000000L;\n  long mantissa\u003dbits \u0026 0x000fffffffffffffL;\n  if (d * (direction - d) \u003e\u003d 0) {\n    if (mantissa \u003d\u003d 0x000fffffffffffffL) {\n      return Double.longBitsToDouble(sign | (exponent + 0x0010000000000000L));\n    }\n else {\n      return Double.longBitsToDouble(sign | exponent | (mantissa + 1));\n    }\n  }\n else {\n    if (mantissa \u003d\u003d 0L) {\n      return Double.longBitsToDouble(sign | (exponent - 0x0010000000000000L) | 0x000fffffffffffffL);\n    }\n else {\n      return Double.longBitsToDouble(sign | exponent | (mantissa - 1));\n    }\n  }\n}",
    "begin_line": 910,
    "end_line": 948,
    "comment": "/** \n * Get the next machine representable number after a number, moving in the direction of another number. \u003cp\u003e If \u003ccode\u003edirection\u003c/code\u003e is greater than or equal to\u003ccode\u003ed\u003c/code\u003e, the smallest machine representable number strictly greater than \u003ccode\u003ed\u003c/code\u003e is returned; otherwise the largest representable number strictly less than \u003ccode\u003ed\u003c/code\u003e is returned.\u003c/p\u003e \u003cp\u003e If \u003ccode\u003ed\u003c/code\u003e is NaN or Infinite, it is returned unchanged.\u003c/p\u003e\n * @param d base number\n * @param direction (the only important thing is whetherdirection is greater or smaller than d)\n * @return the next machine representable number in the specified direction\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.scalb#959",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.scalb(double, int)",
    "snippet": "public static double scalb(final double d,final int scaleFactor){\n  if ((d \u003d\u003d 0) || Double.isNaN(d) || Double.isInfinite(d)) {\n    return d;\n  }\n  final long bits\u003dDouble.doubleToLongBits(d);\n  final long exponent\u003dbits \u0026 0x7ff0000000000000L;\n  final long rest\u003dbits \u0026 0x800fffffffffffffL;\n  final long newBits\u003drest | (exponent + (((long)scaleFactor) \u003c\u003c 52));\n  return Double.longBitsToDouble(newBits);\n}",
    "begin_line": 959,
    "end_line": 975,
    "comment": "/** \n * Scale a number by 2\u003csup\u003escaleFactor\u003c/sup\u003e. \u003cp\u003eIf \u003ccode\u003ed\u003c/code\u003e is 0 or NaN or Infinite, it is returned unchanged.\u003c/p\u003e\n * @param d base number\n * @param scaleFactor power of two by which d sould be multiplied\n * @return d \u0026times; 2\u003csup\u003escaleFactor\u003c/sup\u003e\n * @since 2.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.normalizeAngle#996",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.normalizeAngle(double, double)",
    "snippet": "public static double normalizeAngle(double a,double center){\n  return a - TWO_PI * Math.floor((a + Math.PI - center) / TWO_PI);\n}",
    "begin_line": 996,
    "end_line": 998,
    "comment": "/** \n * Normalize an angle in a 2\u0026pi wide interval around a center value. \u003cp\u003eThis method has three main uses:\u003c/p\u003e \u003cul\u003e \u003cli\u003enormalize an angle between 0 and 2\u0026pi;:\u003cbr/\u003e \u003ccode\u003ea \u003d MathUtils.normalizeAngle(a, Math.PI);\u003c/code\u003e\u003c/li\u003e \u003cli\u003enormalize an angle between -\u0026pi; and +\u0026pi;\u003cbr/\u003e \u003ccode\u003ea \u003d MathUtils.normalizeAngle(a, 0.0);\u003c/code\u003e\u003c/li\u003e \u003cli\u003ecompute the angle between two defining angular positions:\u003cbr\u003e \u003ccode\u003eangle \u003d MathUtils.normalizeAngle(end, start) - start;\u003c/code\u003e\u003c/li\u003e \u003c/ul\u003e \u003cp\u003eNote that due to numerical accuracy and since \u0026pi; cannot be represented exactly, the result interval is \u003cem\u003eclosed\u003c/em\u003e, it cannot be half-closed as would be more satisfactory in a purely mathematical view.\u003c/p\u003e\n * @param a angle to normalize\n * @param center center of the desired 2\u0026pi; interval for the result\n * @return a-2k\u0026pi; with integer k and center-\u0026pi; \u0026lt;\u003d a-2k\u0026pi; \u0026lt;\u003d center+\u0026pi;\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.normalizeArray#1020",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.normalizeArray(double[], double)",
    "snippet": "public static double[] normalizeArray(double[] values,double normalizedSum) throws ArithmeticException, IllegalArgumentException {\n  if (Double.isInfinite(normalizedSum)) {\n    throw MathRuntimeException.createIllegalArgumentException(\"Cannot normalize to an infinite value\");\n  }\n  if (Double.isNaN(normalizedSum)) {\n    throw MathRuntimeException.createIllegalArgumentException(\"Cannot normalize to NaN\");\n  }\n  double sum\u003d0d;\n  final int len\u003dvalues.length;\n  double[] out\u003dnew double[len];\n  for (int i\u003d0; i \u003c len; i++) {\n    if (Double.isInfinite(values[i])) {\n      throw MathRuntimeException.createArithmeticException(\"Array contains an infinite element, {0} at index {1}\",values[i],i);\n    }\n    if (!Double.isNaN(values[i])) {\n      sum+\u003dvalues[i];\n    }\n  }\n  if (sum \u003d\u003d 0) {\n    throw MathRuntimeException.createArithmeticException(\"Array sums to zero\");\n  }\n  for (int i\u003d0; i \u003c len; i++) {\n    if (Double.isNaN(values[i])) {\n      out[i]\u003dDouble.NaN;\n    }\n else {\n      out[i]\u003dvalues[i] * normalizedSum / sum;\n    }\n  }\n  return out;\n}",
    "begin_line": 1020,
    "end_line": 1054,
    "comment": "/** \n * \u003cp\u003eNormalizes an array to make it sum to a specified value. Returns the result of the transformation \u003cpre\u003e x |-\u003e x * normalizedSum / sum \u003c/pre\u003e applied to each non-NaN element x of the input array, where sum is the sum of the non-NaN entries in the input array.\u003c/p\u003e \u003cp\u003eThrows IllegalArgumentException if \u003ccode\u003enormalizedSum\u003c/code\u003e is infinite or NaN and ArithmeticException if the input array contains any infinite elements or sums to 0\u003c/p\u003e \u003cp\u003eIgnores (i.e., copies unchanged to the output array) NaNs in the input array.\u003c/p\u003e\n * @param values input array to be normalized\n * @param normalizedSum target sum for the normalized array\n * @return normalized array\n * @throws ArithmeticException if the input array contains infinite elements or sums to zero\n * @throws IllegalArgumentException if the target sum is infinite or NaN\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.round#1065",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.round(double, int)",
    "snippet": "public static double round(double x,int scale){\n  return round(x,scale,BigDecimal.ROUND_HALF_UP);\n}",
    "begin_line": 1065,
    "end_line": 1067,
    "comment": "/** \n * Round the given value to the specified number of decimal places. The value is rounded using the  {@link BigDecimal#ROUND_HALF_UP} method.\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.round#1081",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.round(double, int, int)",
    "snippet": "public static double round(double x,int scale,int roundingMethod){\n  try {\n    return (new BigDecimal(Double.toString(x)).setScale(scale,roundingMethod)).doubleValue();\n  }\n catch (  NumberFormatException ex) {\n    if (Double.isInfinite(x)) {\n      return x;\n    }\n else {\n      return Double.NaN;\n    }\n  }\n}",
    "begin_line": 1081,
    "end_line": 1094,
    "comment": "/** \n * Round the given value to the specified number of decimal places. The value is rounded using the given method which is any method defined in {@link BigDecimal}.\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @param roundingMethod the rounding method as defined in{@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.round#1105",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.round(float, int)",
    "snippet": "public static float round(float x,int scale){\n  return round(x,scale,BigDecimal.ROUND_HALF_UP);\n}",
    "begin_line": 1105,
    "end_line": 1107,
    "comment": "/** \n * Round the given value to the specified number of decimal places. The value is rounding using the  {@link BigDecimal#ROUND_HALF_UP} method.\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.round#1121",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.round(float, int, int)",
    "snippet": "public static float round(float x,int scale,int roundingMethod){\n  float sign\u003dindicator(x);\n  float factor\u003d(float)Math.pow(10.0f,scale) * sign;\n  return (float)roundUnscaled(x * factor,sign,roundingMethod) / factor;\n}",
    "begin_line": 1121,
    "end_line": 1125,
    "comment": "/** \n * Round the given value to the specified number of decimal places. The value is rounded using the given method which is any method defined in {@link BigDecimal}.\n * @param x the value to round.\n * @param scale the number of digits to the right of the decimal point.\n * @param roundingMethod the rounding method as defined in{@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.roundUnscaled#1139",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.roundUnscaled(double, double, int)",
    "snippet": "private static double roundUnscaled(double unscaled,double sign,int roundingMethod){\nswitch (roundingMethod) {\ncase BigDecimal.ROUND_CEILING:    if (sign \u003d\u003d -1) {\n      unscaled\u003dMath.floor(nextAfter(unscaled,Double.NEGATIVE_INFINITY));\n    }\n else {\n      unscaled\u003dMath.ceil(nextAfter(unscaled,Double.POSITIVE_INFINITY));\n    }\n  break;\ncase BigDecimal.ROUND_DOWN:unscaled\u003dMath.floor(nextAfter(unscaled,Double.NEGATIVE_INFINITY));\nbreak;\ncase BigDecimal.ROUND_FLOOR:if (sign \u003d\u003d -1) {\nunscaled\u003dMath.ceil(nextAfter(unscaled,Double.POSITIVE_INFINITY));\n}\n else {\nunscaled\u003dMath.floor(nextAfter(unscaled,Double.NEGATIVE_INFINITY));\n}\nbreak;\ncase BigDecimal.ROUND_HALF_DOWN:{\nunscaled\u003dnextAfter(unscaled,Double.NEGATIVE_INFINITY);\ndouble fraction\u003dunscaled - Math.floor(unscaled);\nif (fraction \u003e 0.5) {\nunscaled\u003dMath.ceil(unscaled);\n}\n else {\nunscaled\u003dMath.floor(unscaled);\n}\nbreak;\n}\ncase BigDecimal.ROUND_HALF_EVEN:{\ndouble fraction\u003dunscaled - Math.floor(unscaled);\nif (fraction \u003e 0.5) {\nunscaled\u003dMath.ceil(unscaled);\n}\n else if (fraction \u003c 0.5) {\nunscaled\u003dMath.floor(unscaled);\n}\n else {\nif (Math.floor(unscaled) / 2.0 \u003d\u003d Math.floor(Math.floor(unscaled) / 2.0)) {\nunscaled\u003dMath.floor(unscaled);\n}\n else {\nunscaled\u003dMath.ceil(unscaled);\n}\n}\nbreak;\n}\ncase BigDecimal.ROUND_HALF_UP:{\nunscaled\u003dnextAfter(unscaled,Double.POSITIVE_INFINITY);\ndouble fraction\u003dunscaled - Math.floor(unscaled);\nif (fraction \u003e\u003d 0.5) {\nunscaled\u003dMath.ceil(unscaled);\n}\n else {\nunscaled\u003dMath.floor(unscaled);\n}\nbreak;\n}\ncase BigDecimal.ROUND_UNNECESSARY:if (unscaled !\u003d Math.floor(unscaled)) {\nthrow new ArithmeticException(\"Inexact result from rounding\");\n}\nbreak;\ncase BigDecimal.ROUND_UP:unscaled\u003dMath.ceil(nextAfter(unscaled,Double.POSITIVE_INFINITY));\nbreak;\ndefault:throw MathRuntimeException.createIllegalArgumentException(\"invalid rounding method {0}, valid methods: {1} ({2}), {3} ({4}),\" + \" {5} ({6}), {7} ({8}), {9} ({10}), {11} ({12}), {13} ({14}), {15} ({16})\",roundingMethod,\"ROUND_CEILING\",BigDecimal.ROUND_CEILING,\"ROUND_DOWN\",BigDecimal.ROUND_DOWN,\"ROUND_FLOOR\",BigDecimal.ROUND_FLOOR,\"ROUND_HALF_DOWN\",BigDecimal.ROUND_HALF_DOWN,\"ROUND_HALF_EVEN\",BigDecimal.ROUND_HALF_EVEN,\"ROUND_HALF_UP\",BigDecimal.ROUND_HALF_UP,\"ROUND_UNNECESSARY\",BigDecimal.ROUND_UNNECESSARY,\"ROUND_UP\",BigDecimal.ROUND_UP);\n}\nreturn unscaled;\n}",
    "begin_line": 1139,
    "end_line": 1219,
    "comment": "/** \n * Round the given non-negative, value to the \"nearest\" integer. Nearest is determined by the rounding method specified. Rounding methods are defined in  {@link BigDecimal}.\n * @param unscaled the value to round.\n * @param sign the sign of the original, scaled value.\n * @param roundingMethod the rounding method as defined in{@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1231",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(byte)",
    "snippet": "public static byte sign(final byte x){\n  return (x \u003d\u003d ZB) ? ZB : (x \u003e ZB) ? PB : NB;\n}",
    "begin_line": 1231,
    "end_line": 1233,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for byte value \u003ccode\u003ex\u003c/code\u003e. \u003cp\u003e For a byte value x, this method returns (byte)(+1) if x \u003e 0, (byte)(0) if x \u003d 0, and (byte)(-1) if x \u003c 0.\u003c/p\u003e\n * @param x the value, a byte\n * @return (byte)(+1), (byte)(0), or (byte)(-1), depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1247",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(double)",
    "snippet": "public static double sign(final double x){\n  if (Double.isNaN(x)) {\n    return Double.NaN;\n  }\n  return (x \u003d\u003d 0.0) ? 0.0 : (x \u003e 0.0) ? 1.0 : -1.0;\n}",
    "begin_line": 1247,
    "end_line": 1252,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for double precision \u003ccode\u003ex\u003c/code\u003e. \u003cp\u003e For a double value \u003ccode\u003ex\u003c/code\u003e, this method returns \u003ccode\u003e+1.0\u003c/code\u003e if \u003ccode\u003ex \u003e 0\u003c/code\u003e, \u003ccode\u003e0.0\u003c/code\u003e if \u003ccode\u003ex \u003d 0.0\u003c/code\u003e, and \u003ccode\u003e-1.0\u003c/code\u003e if \u003ccode\u003ex \u003c 0\u003c/code\u003e. Returns \u003ccode\u003eNaN\u003c/code\u003e if \u003ccode\u003ex\u003c/code\u003e is \u003ccode\u003eNaN\u003c/code\u003e.\u003c/p\u003e\n * @param x the value, a double\n * @return +1.0, 0.0, or -1.0, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1265",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(float)",
    "snippet": "public static float sign(final float x){\n  if (Float.isNaN(x)) {\n    return Float.NaN;\n  }\n  return (x \u003d\u003d 0.0F) ? 0.0F : (x \u003e 0.0F) ? 1.0F : -1.0F;\n}",
    "begin_line": 1265,
    "end_line": 1270,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for float value \u003ccode\u003ex\u003c/code\u003e. \u003cp\u003e For a float value x, this method returns +1.0F if x \u003e 0, 0.0F if x \u003d 0.0F, and -1.0F if x \u003c 0. Returns \u003ccode\u003eNaN\u003c/code\u003e if \u003ccode\u003ex\u003c/code\u003e is \u003ccode\u003eNaN\u003c/code\u003e.\u003c/p\u003e\n * @param x the value, a float\n * @return +1.0F, 0.0F, or -1.0F, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1282",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(int)",
    "snippet": "public static int sign(final int x){\n  return (x \u003d\u003d 0) ? 0 : (x \u003e 0) ? 1 : -1;\n}",
    "begin_line": 1282,
    "end_line": 1284,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for int value \u003ccode\u003ex\u003c/code\u003e. \u003cp\u003e For an int value x, this method returns +1 if x \u003e 0, 0 if x \u003d 0, and -1 if x \u003c 0.\u003c/p\u003e\n * @param x the value, an int\n * @return +1, 0, or -1, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1296",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(long)",
    "snippet": "public static long sign(final long x){\n  return (x \u003d\u003d 0L) ? 0L : (x \u003e 0L) ? 1L : -1L;\n}",
    "begin_line": 1296,
    "end_line": 1298,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for long value \u003ccode\u003ex\u003c/code\u003e. \u003cp\u003e For a long value x, this method returns +1L if x \u003e 0, 0L if x \u003d 0, and -1L if x \u003c 0.\u003c/p\u003e\n * @param x the value, a long\n * @return +1L, 0L, or -1L, depending on the sign of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sign#1311",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sign(short)",
    "snippet": "public static short sign(final short x){\n  return (x \u003d\u003d ZS) ? ZS : (x \u003e ZS) ? PS : NS;\n}",
    "begin_line": 1311,
    "end_line": 1313,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/Sign.html\"\u003e sign\u003c/a\u003e for short value \u003ccode\u003ex\u003c/code\u003e. \u003cp\u003e For a short value x, this method returns (short)(+1) if x \u003e 0, (short)(0) if x \u003d 0, and (short)(-1) if x \u003c 0.\u003c/p\u003e\n * @param x the value, a short\n * @return (short)(+1), (short)(0), or (short)(-1), depending on the sign ofx\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.sinh#1322",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.sinh(double)",
    "snippet": "public static double sinh(double x){\n  return (Math.exp(x) - Math.exp(-x)) / 2.0;\n}",
    "begin_line": 1322,
    "end_line": 1324,
    "comment": "/** \n * Returns the \u003ca href\u003d\"http://mathworld.wolfram.com/HyperbolicSine.html\"\u003e hyperbolic sine\u003c/a\u003e of x.\n * @param x double value for which to find the hyperbolic sine\n * @return hyperbolic sine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.subAndCheck#1336",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.subAndCheck(int, int)",
    "snippet": "public static int subAndCheck(int x,int y){\n  long s\u003d(long)x - (long)y;\n  if (s \u003c Integer.MIN_VALUE || s \u003e Integer.MAX_VALUE) {\n    throw new ArithmeticException(\"overflow: subtract\");\n  }\n  return (int)s;\n}",
    "begin_line": 1336,
    "end_line": 1342,
    "comment": "/** \n * Subtract two integers, checking for overflow.\n * @param x the minuend\n * @param y the subtrahend\n * @return the difference \u003ccode\u003ex-y\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anint\n * @since 1.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.subAndCheck#1354",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.subAndCheck(long, long)",
    "snippet": "public static long subAndCheck(long a,long b){\n  long ret;\n  String msg\u003d\"overflow: subtract\";\n  if (b \u003d\u003d Long.MIN_VALUE) {\n    if (a \u003c 0) {\n      ret\u003da - b;\n    }\n else {\n      throw new ArithmeticException(msg);\n    }\n  }\n else {\n    ret\u003daddAndCheck(a,-b,msg);\n  }\n  return ret;\n}",
    "begin_line": 1354,
    "end_line": 1368,
    "comment": "/** \n * Subtract two long integers, checking for overflow.\n * @param a first value\n * @param b second value\n * @return the difference \u003ccode\u003ea-b\u003c/code\u003e\n * @throws ArithmeticException if the result can not be represented as anlong\n * @since 1.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1377",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(int, int)",
    "snippet": "public static int pow(final int k,int e) throws IllegalArgumentException {\n  if (e \u003c 0) {\n    throw MathRuntimeException.createIllegalArgumentException(\"cannot raise an integral value to a negative power ({0}^{1})\",k,e);\n  }\n  int result\u003d1;\n  int k2p\u003dk;\n  while (e !\u003d 0) {\n    if ((e \u0026 0x1) !\u003d 0) {\n      result*\u003dk2p;\n    }\n    k2p*\u003dk2p;\n    e\u003de \u003e\u003e 1;\n  }\n  return result;\n}",
    "begin_line": 1377,
    "end_line": 1398,
    "comment": "/** \n * Raise an int to an int power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1407",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(int, long)",
    "snippet": "public static int pow(final int k,long e) throws IllegalArgumentException {\n  if (e \u003c 0) {\n    throw MathRuntimeException.createIllegalArgumentException(\"cannot raise an integral value to a negative power ({0}^{1})\",k,e);\n  }\n  int result\u003d1;\n  int k2p\u003dk;\n  while (e !\u003d 0) {\n    if ((e \u0026 0x1) !\u003d 0) {\n      result*\u003dk2p;\n    }\n    k2p*\u003dk2p;\n    e\u003de \u003e\u003e 1;\n  }\n  return result;\n}",
    "begin_line": 1407,
    "end_line": 1428,
    "comment": "/** \n * Raise an int to a long power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1437",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(long, int)",
    "snippet": "public static long pow(final long k,int e) throws IllegalArgumentException {\n  if (e \u003c 0) {\n    throw MathRuntimeException.createIllegalArgumentException(\"cannot raise an integral value to a negative power ({0}^{1})\",k,e);\n  }\n  long result\u003d1l;\n  long k2p\u003dk;\n  while (e !\u003d 0) {\n    if ((e \u0026 0x1) !\u003d 0) {\n      result*\u003dk2p;\n    }\n    k2p*\u003dk2p;\n    e\u003de \u003e\u003e 1;\n  }\n  return result;\n}",
    "begin_line": 1437,
    "end_line": 1458,
    "comment": "/** \n * Raise a long to an int power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1467",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(long, long)",
    "snippet": "public static long pow(final long k,long e) throws IllegalArgumentException {\n  if (e \u003c 0) {\n    throw MathRuntimeException.createIllegalArgumentException(\"cannot raise an integral value to a negative power ({0}^{1})\",k,e);\n  }\n  long result\u003d1l;\n  long k2p\u003dk;\n  while (e !\u003d 0) {\n    if ((e \u0026 0x1) !\u003d 0) {\n      result*\u003dk2p;\n    }\n    k2p*\u003dk2p;\n    e\u003de \u003e\u003e 1;\n  }\n  return result;\n}",
    "begin_line": 1467,
    "end_line": 1488,
    "comment": "/** \n * Raise a long to a long power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1497",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(java.math.BigInteger, int)",
    "snippet": "public static BigInteger pow(final BigInteger k,int e) throws IllegalArgumentException {\n  if (e \u003c 0) {\n    throw MathRuntimeException.createIllegalArgumentException(\"cannot raise an integral value to a negative power ({0}^{1})\",k,e);\n  }\n  return k.pow(e);\n}",
    "begin_line": 1497,
    "end_line": 1508,
    "comment": "/** \n * Raise a BigInteger to an int power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1517",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(java.math.BigInteger, long)",
    "snippet": "public static BigInteger pow(final BigInteger k,long e) throws IllegalArgumentException {\n  if (e \u003c 0) {\n    throw MathRuntimeException.createIllegalArgumentException(\"cannot raise an integral value to a negative power ({0}^{1})\",k,e);\n  }\n  BigInteger result\u003dBigInteger.ONE;\n  BigInteger k2p\u003dk;\n  while (e !\u003d 0) {\n    if ((e \u0026 0x1) !\u003d 0) {\n      result\u003dresult.multiply(k2p);\n    }\n    k2p\u003dk2p.multiply(k2p);\n    e\u003de \u003e\u003e 1;\n  }\n  return result;\n}",
    "begin_line": 1517,
    "end_line": 1538,
    "comment": "/** \n * Raise a BigInteger to a long power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.pow#1547",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.pow(java.math.BigInteger, java.math.BigInteger)",
    "snippet": "public static BigInteger pow(final BigInteger k,BigInteger e) throws IllegalArgumentException {\n  if (e.compareTo(BigInteger.ZERO) \u003c 0) {\n    throw MathRuntimeException.createIllegalArgumentException(\"cannot raise an integral value to a negative power ({0}^{1})\",k,e);\n  }\n  BigInteger result\u003dBigInteger.ONE;\n  BigInteger k2p\u003dk;\n  while (!BigInteger.ZERO.equals(e)) {\n    if (e.testBit(0)) {\n      result\u003dresult.multiply(k2p);\n    }\n    k2p\u003dk2p.multiply(k2p);\n    e\u003de.shiftRight(1);\n  }\n  return result;\n}",
    "begin_line": 1547,
    "end_line": 1568,
    "comment": "/** \n * Raise a BigInteger to a BigInteger power.\n * @param k number to raise\n * @param e exponent (must be positive or null)\n * @return k\u003csup\u003ee\u003c/sup\u003e\n * @exception IllegalArgumentException if e is negative\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distance1#1577",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distance1(double[], double[])",
    "snippet": "public static double distance1(double[] p1,double[] p2){\n  double sum\u003d0;\n  for (int i\u003d0; i \u003c p1.length; i++) {\n    sum+\u003dMath.abs(p1[i] - p2[i]);\n  }\n  return sum;\n}",
    "begin_line": 1577,
    "end_line": 1583,
    "comment": "/** \n * Calculates the L\u003csub\u003e1\u003c/sub\u003e (sum of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e1\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distance1#1592",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distance1(int[], int[])",
    "snippet": "public static int distance1(int[] p1,int[] p2){\n  int sum\u003d0;\n  for (int i\u003d0; i \u003c p1.length; i++) {\n    sum+\u003dMath.abs(p1[i] - p2[i]);\n  }\n  return sum;\n}",
    "begin_line": 1592,
    "end_line": 1598,
    "comment": "/** \n * Calculates the L\u003csub\u003e1\u003c/sub\u003e (sum of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e1\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distance#1607",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distance(double[], double[])",
    "snippet": "public static double distance(double[] p1,double[] p2){\n  double sum\u003d0;\n  for (int i\u003d0; i \u003c p1.length; i++) {\n    final double dp\u003dp1[i] - p2[i];\n    sum+\u003ddp * dp;\n  }\n  return Math.sqrt(sum);\n}",
    "begin_line": 1607,
    "end_line": 1614,
    "comment": "/** \n * Calculates the L\u003csub\u003e2\u003c/sub\u003e (Euclidean) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e2\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distance#1623",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distance(int[], int[])",
    "snippet": "public static double distance(int[] p1,int[] p2){\n  int sum\u003d0;\n  for (int i\u003d0; i \u003c p1.length; i++) {\n    final int dp\u003dp1[i] - p2[i];\n    sum+\u003ddp * dp;\n  }\n  return Math.sqrt(sum);\n}",
    "begin_line": 1623,
    "end_line": 1630,
    "comment": "/** \n * Calculates the L\u003csub\u003e2\u003c/sub\u003e (Euclidean) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e2\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distanceInf#1639",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distanceInf(double[], double[])",
    "snippet": "public static double distanceInf(double[] p1,double[] p2){\n  double max\u003d0;\n  for (int i\u003d0; i \u003c p1.length; i++) {\n    max\u003dMath.max(max,Math.abs(p1[i] - p2[i]));\n  }\n  return max;\n}",
    "begin_line": 1639,
    "end_line": 1645,
    "comment": "/** \n * Calculates the L\u003csub\u003e\u0026infin;\u003c/sub\u003e (max of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e\u0026infin;\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathUtils.distanceInf#1654",
    "is_bug": true,
    "src_path": "org/apache/commons/math/util/MathUtils.java",
    "class_name": "org.apache.commons.math.util.MathUtils",
    "signature": "org.apache.commons.math.util.MathUtils.distanceInf(int[], int[])",
    "snippet": "public static int distanceInf(int[] p1,int[] p2){\n  int max\u003d0;\n  for (int i\u003d0; i \u003c p1.length; i++) {\n    max\u003dMath.max(max,Math.abs(p1[i] - p2[i]));\n  }\n  return max;\n}",
    "begin_line": 1654,
    "end_line": 1660,
    "comment": "/** \n * Calculates the L\u003csub\u003e\u0026infin;\u003c/sub\u003e (max of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e\u0026infin;\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]