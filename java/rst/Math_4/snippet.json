[
  {
    "name": "IntervalsSet.IntervalsSet#36",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet()",
    "snippet": "public IntervalsSet(){\n  super();\n}",
    "begin_line": 36,
    "end_line": 38,
    "comment": "/** \n * Build an intervals set representing the whole real line.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.IntervalsSet#46",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet(double, double)",
    "snippet": "public IntervalsSet(final double lower,final double upper){\n  super(buildTree(lower,upper));\n}",
    "begin_line": 46,
    "end_line": 48,
    "comment": "/** \n * Build an intervals set corresponding to a single interval.\n * @param lower lower bound of the interval, must be lesser or equalto  {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n * @param upper upper bound of the interval, must be greater or equalto  {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.IntervalsSet#59",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet(org.apache.commons.math3.geometry.partitioning.BSPTree\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public IntervalsSet(final BSPTree\u003cEuclidean1D\u003e tree){\n  super(tree);\n}",
    "begin_line": 59,
    "end_line": 61,
    "comment": "/** \n * Build an intervals set from an inside/outside BSP tree. \u003cp\u003eThe leaf nodes of the BSP tree \u003cem\u003emust\u003c/em\u003e have a {@code Boolean} attribute representing the inside status ofthe corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants {@code Boolean.TRUE} and {@code Boolean.FALSE}\u003c/p\u003e\n * @param tree inside/outside BSP tree representing the intervals set\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.IntervalsSet#82",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.IntervalsSet(java.util.Collection\u003corg.apache.commons.math3.geometry.partitioning.SubHyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e\u003e)",
    "snippet": "public IntervalsSet(final Collection\u003cSubHyperplane\u003cEuclidean1D\u003e\u003e boundary){\n  super(boundary);\n}",
    "begin_line": 82,
    "end_line": 84,
    "comment": "/** \n * Build an intervals set from a Boundary REPresentation (B-rep). \u003cp\u003eThe boundary is provided as a collection of  {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side.\u003c/p\u003e \u003cp\u003eThe boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoints polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the  {@link org.apache.commons.math3.geometry.partitioning.Region#checkPoint(org.apache.commons.math3.geometry.Vector) checkPoint} method will not be meaningful anymore.\u003c/p\u003e\u003cp\u003eIf the boundary is empty, the region will represent the whole space.\u003c/p\u003e\n * @param boundary collection of boundary elements\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.buildTree#93",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.buildTree(double, double)",
    "snippet": "private static BSPTree\u003cEuclidean1D\u003e buildTree(final double lower,final double upper){\n  if (Double.isInfinite(lower) \u0026\u0026 (lower \u003c 0)) {\n    if (Double.isInfinite(upper) \u0026\u0026 (upper \u003e 0)) {\n      return new BSPTree\u003cEuclidean1D\u003e(Boolean.TRUE);\n    }\n    final SubHyperplane\u003cEuclidean1D\u003e upperCut\u003dnew OrientedPoint(new Vector1D(upper),true).wholeHyperplane();\n    return new BSPTree\u003cEuclidean1D\u003e(upperCut,new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE),new BSPTree\u003cEuclidean1D\u003e(Boolean.TRUE),null);\n  }\n  final SubHyperplane\u003cEuclidean1D\u003e lowerCut\u003dnew OrientedPoint(new Vector1D(lower),false).wholeHyperplane();\n  if (Double.isInfinite(upper) \u0026\u0026 (upper \u003e 0)) {\n    return new BSPTree\u003cEuclidean1D\u003e(lowerCut,new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE),new BSPTree\u003cEuclidean1D\u003e(Boolean.TRUE),null);\n  }\n  final SubHyperplane\u003cEuclidean1D\u003e upperCut\u003dnew OrientedPoint(new Vector1D(upper),true).wholeHyperplane();\n  return new BSPTree\u003cEuclidean1D\u003e(lowerCut,new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE),new BSPTree\u003cEuclidean1D\u003e(upperCut,new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE),new BSPTree\u003cEuclidean1D\u003e(Boolean.TRUE),null),null);\n}",
    "begin_line": 93,
    "end_line": 128,
    "comment": "/** \n * Build an inside/outside tree representing a single interval.\n * @param lower lower bound of the interval, must be lesser or equalto  {@code upper} (may be {@code Double.NEGATIVE_INFINITY})\n * @param upper upper bound of the interval, must be greater or equalto  {@code lower} (may be {@code Double.POSITIVE_INFINITY})\n * @return the built tree\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.buildNew#132",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.buildNew(org.apache.commons.math3.geometry.partitioning.BSPTree\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "@Override public IntervalsSet buildNew(final BSPTree\u003cEuclidean1D\u003e tree){\n  return new IntervalsSet(tree);\n}",
    "begin_line": 132,
    "end_line": 134,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.computeGeometricalProperties#138",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.computeGeometricalProperties()",
    "snippet": "@Override protected void computeGeometricalProperties(){\n  if (getTree(false).getCut() \u003d\u003d null) {\n    setBarycenter(Vector1D.NaN);\n    setSize(((Boolean)getTree(false).getAttribute()) ? Double.POSITIVE_INFINITY : 0);\n  }\n else {\n    double size\u003d0.0;\n    double sum\u003d0.0;\n    for (    final Interval interval : asList()) {\n      size+\u003dinterval.getSize();\n      sum+\u003dinterval.getSize() * interval.getBarycenter();\n    }\n    setSize(size);\n    if (Double.isInfinite(size)) {\n      setBarycenter(Vector1D.NaN);\n    }\n else     if (size \u003e\u003d Precision.SAFE_MIN) {\n      setBarycenter(new Vector1D(sum / size));\n    }\n else {\n      setBarycenter(((OrientedPoint)getTree(false).getCut().getHyperplane()).getLocation());\n    }\n  }\n}",
    "begin_line": 138,
    "end_line": 158,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.getInf#166",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.getInf()",
    "snippet": "public double getInf(){\n  BSPTree\u003cEuclidean1D\u003e node\u003dgetTree(false);\n  double inf\u003dDouble.POSITIVE_INFINITY;\n  while (node.getCut() !\u003d null) {\n    final OrientedPoint op\u003d(OrientedPoint)node.getCut().getHyperplane();\n    inf\u003dop.getLocation().getX();\n    node\u003dop.isDirect() ? node.getMinus() : node.getPlus();\n  }\n  return ((Boolean)node.getAttribute()) ? Double.NEGATIVE_INFINITY : inf;\n}",
    "begin_line": 166,
    "end_line": 175,
    "comment": "/** \n * Get the lowest value belonging to the instance.\n * @return lowest value belonging to the instance( {@code Double.NEGATIVE_INFINITY} if the instance doesn\u0027thave any low bound,  {@code Double.POSITIVE_INFINITY} if theinstance is empty)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.getSup#183",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.getSup()",
    "snippet": "public double getSup(){\n  BSPTree\u003cEuclidean1D\u003e node\u003dgetTree(false);\n  double sup\u003dDouble.NEGATIVE_INFINITY;\n  while (node.getCut() !\u003d null) {\n    final OrientedPoint op\u003d(OrientedPoint)node.getCut().getHyperplane();\n    sup\u003dop.getLocation().getX();\n    node\u003dop.isDirect() ? node.getPlus() : node.getMinus();\n  }\n  return ((Boolean)node.getAttribute()) ? Double.POSITIVE_INFINITY : sup;\n}",
    "begin_line": 183,
    "end_line": 192,
    "comment": "/** \n * Get the highest value belonging to the instance.\n * @return highest value belonging to the instance( {@code Double.POSITIVE_INFINITY} if the instance doesn\u0027thave any high bound,  {@code Double.NEGATIVE_INFINITY} if theinstance is empty)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.asList#207",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.asList()",
    "snippet": "public List\u003cInterval\u003e asList(){\n  final List\u003cInterval\u003e list\u003dnew ArrayList\u003cInterval\u003e();\n  recurseList(getTree(false),list,Double.NEGATIVE_INFINITY,Double.POSITIVE_INFINITY);\n  return list;\n}",
    "begin_line": 207,
    "end_line": 212,
    "comment": "/** \n * Build an ordered list of intervals representing the instance. \u003cp\u003eThis method builds this intervals set as an ordered list of {@link Interval Interval} elements. If the intervals set has nolower limit, the first interval will have its low bound equal to {@code Double.NEGATIVE_INFINITY}. If the intervals set has no upper limit, the last interval will have its upper bound equal to  {@code Double.POSITIVE_INFINITY}. An empty tree will build an empty list while a tree representing the whole real line will build a one element list with both bounds beeing infinite.\u003c/p\u003e\n * @return a new ordered list containing {@link Interval Interval}elements\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "IntervalsSet.recurseList#220",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/IntervalsSet.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet.recurseList(org.apache.commons.math3.geometry.partitioning.BSPTree\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e, java.util.List\u003corg.apache.commons.math3.geometry.euclidean.oned.Interval\u003e, double, double)",
    "snippet": "private void recurseList(final BSPTree\u003cEuclidean1D\u003e node,final List\u003cInterval\u003e list,final double lower,final double upper){\n  if (node.getCut() \u003d\u003d null) {\n    if ((Boolean)node.getAttribute()) {\n      list.add(new Interval(lower,upper));\n    }\n  }\n else {\n    final OrientedPoint op\u003d(OrientedPoint)node.getCut().getHyperplane();\n    final Vector1D loc\u003dop.getLocation();\n    double x\u003dloc.getX();\n    final BSPTree\u003cEuclidean1D\u003e low\u003dop.isDirect() ? node.getMinus() : node.getPlus();\n    final BSPTree\u003cEuclidean1D\u003e high\u003dop.isDirect() ? node.getPlus() : node.getMinus();\n    recurseList(low,list,lower,x);\n    if ((checkPoint(low,loc) \u003d\u003d Location.INSIDE) \u0026\u0026 (checkPoint(high,loc) \u003d\u003d Location.INSIDE)) {\n      x\u003dlist.remove(list.size() - 1).getInf();\n    }\n    recurseList(high,list,x,upper);\n  }\n}",
    "begin_line": 220,
    "end_line": 250,
    "comment": "/** \n * Update an intervals list.\n * @param node current node\n * @param list list to update\n * @param lower lower bound of the current convex cell\n * @param upper upper bound of the current convex cell\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.OrientedPoint#42",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.OrientedPoint(org.apache.commons.math3.geometry.euclidean.oned.Vector1D, boolean)",
    "snippet": "public OrientedPoint(final Vector1D location,final boolean direct){\n  this.location\u003dlocation;\n  this.direct\u003ddirect;\n}",
    "begin_line": 42,
    "end_line": 45,
    "comment": "/** \n * Simple constructor.\n * @param location location of the hyperplane\n * @param direct if true, the plus side of the hyperplane is towardsabscissas greater than  {@code location}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.copySelf#52",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.copySelf()",
    "snippet": "public OrientedPoint copySelf(){\n  return this;\n}",
    "begin_line": 52,
    "end_line": 54,
    "comment": "/** \n * Copy the instance. \u003cp\u003eSince instances are immutable, this method directly returns the instance.\u003c/p\u003e\n * @return the instance itself\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.getOffset#57",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.getOffset(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public double getOffset(final Vector\u003cEuclidean1D\u003e point){\n  final double delta\u003d((Vector1D)point).getX() - location.getX();\n  return direct ? delta : -delta;\n}",
    "begin_line": 57,
    "end_line": 60,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.wholeHyperplane#73",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.wholeHyperplane()",
    "snippet": "public SubOrientedPoint wholeHyperplane(){\n  return new SubOrientedPoint(this,null);\n}",
    "begin_line": 73,
    "end_line": 75,
    "comment": "/** \n * Build a region covering the whole hyperplane. \u003cp\u003eSince this class represent zero dimension spaces which does not have lower dimension sub-spaces, this method returns a dummy implementation of a  {@link org.apache.commons.math3.geometry.partitioning.SubHyperplane SubHyperplane}. This implementation is only used to allow the  {@link org.apache.commons.math3.geometry.partitioning.SubHyperplane SubHyperplane} class implementation to work properly, it should\u003cem\u003enot\u003c/em\u003e be used otherwise.\u003c/p\u003e\n * @return a dummy sub hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.wholeSpace#81",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.wholeSpace()",
    "snippet": "public IntervalsSet wholeSpace(){\n  return new IntervalsSet();\n}",
    "begin_line": 81,
    "end_line": 83,
    "comment": "/** \n * Build a region covering the whole space.\n * @return a region containing the instance (really an {@link IntervalsSet IntervalsSet} instance)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.sameOrientationAs#86",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.sameOrientationAs(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public boolean sameOrientationAs(final Hyperplane\u003cEuclidean1D\u003e other){\n  return !(direct ^ ((OrientedPoint)other).direct);\n}",
    "begin_line": 86,
    "end_line": 88,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.getLocation#93",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.getLocation()",
    "snippet": "public Vector1D getLocation(){\n  return location;\n}",
    "begin_line": 93,
    "end_line": 95,
    "comment": "/** \n * Get the hyperplane location on the real line.\n * @return the hyperplane location\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.isDirect#101",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.isDirect()",
    "snippet": "public boolean isDirect(){\n  return direct;\n}",
    "begin_line": 101,
    "end_line": 103,
    "comment": "/** \n * Check if the hyperplane orientation is direct.\n * @return true if the plus side of the hyperplane is towardsabscissae greater than hyperplane location\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "OrientedPoint.revertSelf#107",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/OrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.OrientedPoint.revertSelf()",
    "snippet": "public void revertSelf(){\n  direct\u003d!direct;\n}",
    "begin_line": 107,
    "end_line": 109,
    "comment": "/** \n * Revert the instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubOrientedPoint.SubOrientedPoint#37",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.SubOrientedPoint(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e, org.apache.commons.math3.geometry.partitioning.Region\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public SubOrientedPoint(final Hyperplane\u003cEuclidean1D\u003e hyperplane,final Region\u003cEuclidean1D\u003e remainingRegion){\n  super(hyperplane,remainingRegion);\n}",
    "begin_line": 37,
    "end_line": 40,
    "comment": "/** \n * Simple constructor.\n * @param hyperplane underlying hyperplane\n * @param remainingRegion remaining region of the hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubOrientedPoint.getSize#44",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.getSize()",
    "snippet": "@Override public double getSize(){\n  return 0;\n}",
    "begin_line": 44,
    "end_line": 46,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubOrientedPoint.buildNew#50",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.buildNew(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e, org.apache.commons.math3.geometry.partitioning.Region\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "@Override protected AbstractSubHyperplane\u003cEuclidean1D,Euclidean1D\u003e buildNew(final Hyperplane\u003cEuclidean1D\u003e hyperplane,final Region\u003cEuclidean1D\u003e remainingRegion){\n  return new SubOrientedPoint(hyperplane,remainingRegion);\n}",
    "begin_line": 50,
    "end_line": 53,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubOrientedPoint.side#57",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.side(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "@Override public Side side(final Hyperplane\u003cEuclidean1D\u003e hyperplane){\n  final double global\u003dhyperplane.getOffset(((OrientedPoint)getHyperplane()).getLocation());\n  return (global \u003c -1.0e-10) ? Side.MINUS : ((global \u003e 1.0e-10) ? Side.PLUS : Side.HYPER);\n}",
    "begin_line": 57,
    "end_line": 60,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubOrientedPoint.split#64",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/SubOrientedPoint.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.SubOrientedPoint.split(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "@Override public SplitSubHyperplane\u003cEuclidean1D\u003e split(final Hyperplane\u003cEuclidean1D\u003e hyperplane){\n  final double global\u003dhyperplane.getOffset(((OrientedPoint)getHyperplane()).getLocation());\n  return (global \u003c -1.0e-10) ? new SplitSubHyperplane\u003cEuclidean1D\u003e(null,this) : new SplitSubHyperplane\u003cEuclidean1D\u003e(this,null);\n}",
    "begin_line": 64,
    "end_line": 69,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.Vector1D#65",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double)",
    "snippet": "public Vector1D(double x){\n  this.x\u003dx;\n}",
    "begin_line": 65,
    "end_line": 67,
    "comment": "/** \n * Simple constructor. Build a vector from its coordinates\n * @param x abscissa\n * @see #getX()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.Vector1D#75",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public Vector1D(double a,Vector1D u){\n  this.x\u003da * u.x;\n}",
    "begin_line": 75,
    "end_line": 77,
    "comment": "/** \n * Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u\n * @param a scale factor\n * @param u base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.Vector1D#87",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public Vector1D(double a1,Vector1D u1,double a2,Vector1D u2){\n  this.x\u003da1 * u1.x + a2 * u2.x;\n}",
    "begin_line": 87,
    "end_line": 89,
    "comment": "/** \n * Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.Vector1D#101",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public Vector1D(double a1,Vector1D u1,double a2,Vector1D u2,double a3,Vector1D u3){\n  this.x\u003da1 * u1.x + a2 * u2.x + a3 * u3.x;\n}",
    "begin_line": 101,
    "end_line": 104,
    "comment": "/** \n * Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n * @param a3 third scale factor\n * @param u3 third base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.Vector1D#118",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.Vector1D(double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public Vector1D(double a1,Vector1D u1,double a2,Vector1D u2,double a3,Vector1D u3,double a4,Vector1D u4){\n  this.x\u003da1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n}",
    "begin_line": 118,
    "end_line": 121,
    "comment": "/** \n * Linear constructor Build a vector from four other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n * @param a3 third scale factor\n * @param u3 third base (unscaled) vector\n * @param a4 fourth scale factor\n * @param u4 fourth base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getX#127",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getX()",
    "snippet": "public double getX(){\n  return x;\n}",
    "begin_line": 127,
    "end_line": 129,
    "comment": "/** \n * Get the abscissa of the vector.\n * @return abscissa of the vector\n * @see #Vector1D(double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getSpace#132",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getSpace()",
    "snippet": "public Space getSpace(){\n  return Euclidean1D.getInstance();\n}",
    "begin_line": 132,
    "end_line": 134,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getZero#137",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getZero()",
    "snippet": "public Vector1D getZero(){\n  return ZERO;\n}",
    "begin_line": 137,
    "end_line": 139,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getNorm1#142",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getNorm1()",
    "snippet": "public double getNorm1(){\n  return FastMath.abs(x);\n}",
    "begin_line": 142,
    "end_line": 144,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getNorm#147",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getNorm()",
    "snippet": "public double getNorm(){\n  return FastMath.abs(x);\n}",
    "begin_line": 147,
    "end_line": 149,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getNormSq#152",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getNormSq()",
    "snippet": "public double getNormSq(){\n  return x * x;\n}",
    "begin_line": 152,
    "end_line": 154,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.getNormInf#157",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.getNormInf()",
    "snippet": "public double getNormInf(){\n  return FastMath.abs(x);\n}",
    "begin_line": 157,
    "end_line": 159,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.add#162",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.add(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public Vector1D add(Vector\u003cEuclidean1D\u003e v){\n  Vector1D v1\u003d(Vector1D)v;\n  return new Vector1D(x + v1.getX());\n}",
    "begin_line": 162,
    "end_line": 165,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.add#168",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.add(double, org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public Vector1D add(double factor,Vector\u003cEuclidean1D\u003e v){\n  Vector1D v1\u003d(Vector1D)v;\n  return new Vector1D(x + factor * v1.getX());\n}",
    "begin_line": 168,
    "end_line": 171,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.subtract#174",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.subtract(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public Vector1D subtract(Vector\u003cEuclidean1D\u003e p){\n  Vector1D p3\u003d(Vector1D)p;\n  return new Vector1D(x - p3.x);\n}",
    "begin_line": 174,
    "end_line": 177,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.subtract#180",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.subtract(double, org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public Vector1D subtract(double factor,Vector\u003cEuclidean1D\u003e v){\n  Vector1D v1\u003d(Vector1D)v;\n  return new Vector1D(x - factor * v1.getX());\n}",
    "begin_line": 180,
    "end_line": 183,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.normalize#186",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.normalize()",
    "snippet": "public Vector1D normalize() throws MathArithmeticException {\n  double s\u003dgetNorm();\n  if (s \u003d\u003d 0) {\n    throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n  }\n  return scalarMultiply(1 / s);\n}",
    "begin_line": 186,
    "end_line": 192,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.negate#194",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.negate()",
    "snippet": "public Vector1D negate(){\n  return new Vector1D(-x);\n}",
    "begin_line": 194,
    "end_line": 196,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.scalarMultiply#199",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.scalarMultiply(double)",
    "snippet": "public Vector1D scalarMultiply(double a){\n  return new Vector1D(a * x);\n}",
    "begin_line": 199,
    "end_line": 201,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.isNaN#204",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.isNaN()",
    "snippet": "public boolean isNaN(){\n  return Double.isNaN(x);\n}",
    "begin_line": 204,
    "end_line": 206,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.isInfinite#209",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.isInfinite()",
    "snippet": "public boolean isInfinite(){\n  return !isNaN() \u0026\u0026 Double.isInfinite(x);\n}",
    "begin_line": 209,
    "end_line": 211,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distance1#214",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distance1(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public double distance1(Vector\u003cEuclidean1D\u003e p){\n  Vector1D p3\u003d(Vector1D)p;\n  final double dx\u003dFastMath.abs(p3.x - x);\n  return dx;\n}",
    "begin_line": 214,
    "end_line": 218,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distance#221",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distance(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public double distance(Vector\u003cEuclidean1D\u003e p){\n  Vector1D p3\u003d(Vector1D)p;\n  final double dx\u003dp3.x - x;\n  return FastMath.abs(dx);\n}",
    "begin_line": 221,
    "end_line": 225,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distanceInf#228",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distanceInf(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public double distanceInf(Vector\u003cEuclidean1D\u003e p){\n  Vector1D p3\u003d(Vector1D)p;\n  final double dx\u003dFastMath.abs(p3.x - x);\n  return dx;\n}",
    "begin_line": 228,
    "end_line": 232,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distanceSq#235",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distanceSq(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public double distanceSq(Vector\u003cEuclidean1D\u003e p){\n  Vector1D p3\u003d(Vector1D)p;\n  final double dx\u003dp3.x - x;\n  return dx * dx;\n}",
    "begin_line": 235,
    "end_line": 239,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.dotProduct#242",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.dotProduct(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public double dotProduct(final Vector\u003cEuclidean1D\u003e v){\n  final Vector1D v1\u003d(Vector1D)v;\n  return x * v1.x;\n}",
    "begin_line": 242,
    "end_line": 245,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distance#255",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distance(org.apache.commons.math3.geometry.euclidean.oned.Vector1D, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public static double distance(Vector1D p1,Vector1D p2){\n  return p1.distance(p2);\n}",
    "begin_line": 255,
    "end_line": 257,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e2\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ep1.subtract(p2).getNorm()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L\u003csub\u003e2\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distanceInf#267",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distanceInf(org.apache.commons.math3.geometry.euclidean.oned.Vector1D, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public static double distanceInf(Vector1D p1,Vector1D p2){\n  return p1.distanceInf(p2);\n}",
    "begin_line": 267,
    "end_line": 269,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e\u0026infin;\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ep1.subtract(p2).getNormInf()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L\u003csub\u003e\u0026infin;\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.distanceSq#279",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.distanceSq(org.apache.commons.math3.geometry.euclidean.oned.Vector1D, org.apache.commons.math3.geometry.euclidean.oned.Vector1D)",
    "snippet": "public static double distanceSq(Vector1D p1,Vector1D p2){\n  return p1.distanceSq(p2);\n}",
    "begin_line": 279,
    "end_line": 281,
    "comment": "/** \n * Compute the square of the distance between two vectors. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ep1.subtract(p2).getNormSq()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param p1 first vector\n * @param p2 second vector\n * @return the square of the distance between p1 and p2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.equals#303",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.equals(java.lang.Object)",
    "snippet": "@Override public boolean equals(Object other){\n  if (this \u003d\u003d other) {\n    return true;\n  }\n  if (other instanceof Vector1D) {\n    final Vector1D rhs\u003d(Vector1D)other;\n    if (rhs.isNaN()) {\n      return this.isNaN();\n    }\n    return x \u003d\u003d rhs.x;\n  }\n  return false;\n}",
    "begin_line": 303,
    "end_line": 318,
    "comment": "/** \n * Test for the equality of two 1D vectors. \u003cp\u003e If all coordinates of two 1D vectors are exactly the same, and none are \u003ccode\u003eDouble.NaN\u003c/code\u003e, the two 1D vectors are considered to be equal. \u003c/p\u003e \u003cp\u003e \u003ccode\u003eNaN\u003c/code\u003e coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the 1D vector are equal to \u003ccode\u003eDouble.NaN\u003c/code\u003e, the 1D vector is equal to {@link #NaN}. \u003c/p\u003e\n * @param other Object to test for equality to this\n * @return true if two 1D vector objects are equal, false ifobject is null, not an instance of Vector1D, or not equal to this Vector1D instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.hashCode#328",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.hashCode()",
    "snippet": "@Override public int hashCode(){\n  if (isNaN()) {\n    return 7785;\n  }\n  return 997 * MathUtils.hash(x);\n}",
    "begin_line": 328,
    "end_line": 333,
    "comment": "/** \n * Get a hashCode for the 1D vector. \u003cp\u003e All NaN values have the same hash code.\u003c/p\u003e\n * @return a hash code value for this object\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.toString#339",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.toString()",
    "snippet": "@Override public String toString(){\n  return Vector1DFormat.getInstance().format(this);\n}",
    "begin_line": 339,
    "end_line": 341,
    "comment": "/** \n * Get a string representation of this vector.\n * @return a string representation of this vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector1D.toString#344",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/oned/Vector1D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D",
    "signature": "org.apache.commons.math3.geometry.euclidean.oned.Vector1D.toString(java.text.NumberFormat)",
    "snippet": "public String toString(final NumberFormat format){\n  return new Vector1DFormat(format).format(this);\n}",
    "begin_line": 344,
    "end_line": 346,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.Line#54",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.Line(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public Line(final Vector3D p1,final Vector3D p2) throws MathIllegalArgumentException {\n  reset(p1,p2);\n}",
    "begin_line": 54,
    "end_line": 56,
    "comment": "/** \n * Build a line from two points.\n * @param p1 first point belonging to the line (this can be any point)\n * @param p2 second point belonging to the line (this can be any point, different from p1)\n * @exception MathIllegalArgumentException if the points are equal\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.Line#63",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.Line(org.apache.commons.math3.geometry.euclidean.threed.Line)",
    "snippet": "public Line(final Line line){\n  this.direction\u003dline.direction;\n  this.zero\u003dline.zero;\n}",
    "begin_line": 63,
    "end_line": 66,
    "comment": "/** \n * Copy constructor. \u003cp\u003eThe created instance is completely independent from the original instance, it is a deep copy.\u003c/p\u003e\n * @param line line to copy\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.reset#73",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.reset(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public void reset(final Vector3D p1,final Vector3D p2) throws MathIllegalArgumentException {\n  final Vector3D delta\u003dp2.subtract(p1);\n  final double norm2\u003ddelta.getNormSq();\n  if (norm2 \u003d\u003d 0.0) {\n    throw new MathIllegalArgumentException(LocalizedFormats.ZERO_NORM);\n  }\n  this.direction\u003dnew Vector3D(1.0 / FastMath.sqrt(norm2),delta);\n  zero\u003dnew Vector3D(1.0,p1,-p1.dotProduct(delta) / norm2,delta);\n}",
    "begin_line": 73,
    "end_line": 81,
    "comment": "/** \n * Reset the instance as if built from two points.\n * @param p1 first point belonging to the line (this can be any point)\n * @param p2 second point belonging to the line (this can be any point, different from p1)\n * @exception MathIllegalArgumentException if the points are equal\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.revert#86",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.revert()",
    "snippet": "public Line revert(){\n  final Line reverted\u003dnew Line(this);\n  reverted.direction\u003dreverted.direction.negate();\n  return reverted;\n}",
    "begin_line": 86,
    "end_line": 90,
    "comment": "/** \n * Get a line with reversed direction.\n * @return a new instance, with reversed direction\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getDirection#95",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.getDirection()",
    "snippet": "public Vector3D getDirection(){\n  return direction;\n}",
    "begin_line": 95,
    "end_line": 97,
    "comment": "/** \n * Get the normalized direction vector.\n * @return normalized direction vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getOrigin#102",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.getOrigin()",
    "snippet": "public Vector3D getOrigin(){\n  return zero;\n}",
    "begin_line": 102,
    "end_line": 104,
    "comment": "/** \n * Get the line point closest to the origin.\n * @return line point closest to the origin\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getAbscissa#113",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.getAbscissa(org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public double getAbscissa(final Vector3D point){\n  return point.subtract(zero).dotProduct(direction);\n}",
    "begin_line": 113,
    "end_line": 115,
    "comment": "/** \n * Get the abscissa of a point with respect to the line. \u003cp\u003eThe abscissa is 0 if the projection of the point and the projection of the frame origin on the line are the same point.\u003c/p\u003e\n * @param point point to check\n * @return abscissa of the point\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.pointAt#121",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.pointAt(double)",
    "snippet": "public Vector3D pointAt(final double abscissa){\n  return new Vector3D(1.0,zero,abscissa,direction);\n}",
    "begin_line": 121,
    "end_line": 123,
    "comment": "/** \n * Get one point from the line.\n * @param abscissa desired abscissa for the point\n * @return one point belonging to the line, at specified abscissa\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.toSubSpace#128",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.toSubSpace(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public Vector1D toSubSpace(final Vector\u003cEuclidean3D\u003e point){\n  return new Vector1D(getAbscissa((Vector3D)point));\n}",
    "begin_line": 128,
    "end_line": 130,
    "comment": "/** \n * {@inheritDoc}\n * @see #getAbscissa(Vector3D)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.toSpace#135",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.toSpace(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public Vector3D toSpace(final Vector\u003cEuclidean1D\u003e point){\n  return pointAt(((Vector1D)point).getX());\n}",
    "begin_line": 135,
    "end_line": 137,
    "comment": "/** \n * {@inheritDoc}\n * @see #pointAt(double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.isSimilarTo#146",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.isSimilarTo(org.apache.commons.math3.geometry.euclidean.threed.Line)",
    "snippet": "public boolean isSimilarTo(final Line line){\n  final double angle\u003dVector3D.angle(direction,line.direction);\n  return ((angle \u003c 1.0e-10) || (angle \u003e (FastMath.PI - 1.0e-10))) \u0026\u0026 contains(line.zero);\n}",
    "begin_line": 146,
    "end_line": 149,
    "comment": "/** \n * Check if the instance is similar to another line. \u003cp\u003eLines are considered similar if they contain the same points. This does not mean they are equal since they can have opposite directions.\u003c/p\u003e\n * @param line line to which instance should be compared\n * @return true if the lines are similar\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.contains#155",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.contains(org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public boolean contains(final Vector3D p){\n  return distance(p) \u003c 1.0e-10;\n}",
    "begin_line": 155,
    "end_line": 157,
    "comment": "/** \n * Check if the instance contains a point.\n * @param p point to check\n * @return true if p belongs to the line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.distance#163",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.distance(org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public double distance(final Vector3D p){\n  final Vector3D d\u003dp.subtract(zero);\n  final Vector3D n\u003dnew Vector3D(1.0,d,-d.dotProduct(direction),direction);\n  return n.getNorm();\n}",
    "begin_line": 163,
    "end_line": 167,
    "comment": "/** \n * Compute the distance between the instance and a point.\n * @param p to check\n * @return distance between the instance and the point\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.distance#173",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.distance(org.apache.commons.math3.geometry.euclidean.threed.Line)",
    "snippet": "public double distance(final Line line){\n  final Vector3D normal\u003dVector3D.crossProduct(direction,line.direction);\n  final double n\u003dnormal.getNorm();\n  if (n \u003c Precision.SAFE_MIN) {\n    return distance(line.zero);\n  }\n  final double offset\u003dline.zero.subtract(zero).dotProduct(normal) / n;\n  return FastMath.abs(offset);\n}",
    "begin_line": 173,
    "end_line": 187,
    "comment": "/** \n * Compute the shortest distance between the instance and another line.\n * @param line line to check against the instance\n * @return shortest distance between the instance and the line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.closestPoint#193",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.closestPoint(org.apache.commons.math3.geometry.euclidean.threed.Line)",
    "snippet": "public Vector3D closestPoint(final Line line){\n  final double cos\u003ddirection.dotProduct(line.direction);\n  final double n\u003d1 - cos * cos;\n  if (n \u003c Precision.EPSILON) {\n    return zero;\n  }\n  final Vector3D delta0\u003dline.zero.subtract(zero);\n  final double a\u003ddelta0.dotProduct(direction);\n  final double b\u003ddelta0.dotProduct(line.direction);\n  return new Vector3D(1,zero,(a - b * cos) / n,direction);\n}",
    "begin_line": 193,
    "end_line": 208,
    "comment": "/** \n * Compute the point of the instance closest to another line.\n * @param line line to check against the instance\n * @return point of the instance closest to another line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.intersection#215",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.intersection(org.apache.commons.math3.geometry.euclidean.threed.Line)",
    "snippet": "public Vector3D intersection(final Line line){\n  final Vector3D closest\u003dclosestPoint(line);\n  return line.contains(closest) ? closest : null;\n}",
    "begin_line": 215,
    "end_line": 218,
    "comment": "/** \n * Get the intersection point of the instance and another line.\n * @param line other line\n * @return intersection point of the instance and the other lineor null if there are no intersection points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.wholeLine#223",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Line.wholeLine()",
    "snippet": "public SubLine wholeLine(){\n  return new SubLine(this,new IntervalsSet());\n}",
    "begin_line": 223,
    "end_line": 225,
    "comment": "/** \n * Build a sub-line covering the whole line.\n * @return a sub-line covering the whole line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.SubLine#44",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.threed.Line, org.apache.commons.math3.geometry.euclidean.oned.IntervalsSet)",
    "snippet": "public SubLine(final Line line,final IntervalsSet remainingRegion){\n  this.line\u003dline;\n  this.remainingRegion\u003dremainingRegion;\n}",
    "begin_line": 44,
    "end_line": 47,
    "comment": "/** \n * Simple constructor.\n * @param line underlying line\n * @param remainingRegion remaining region of the line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.SubLine#54",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public SubLine(final Vector3D start,final Vector3D end) throws MathIllegalArgumentException {\n  this(new Line(start,end),buildIntervalSet(start,end));\n}",
    "begin_line": 54,
    "end_line": 57,
    "comment": "/** \n * Create a sub-line from two endpoints.\n * @param start start point\n * @param end end point\n * @exception MathIllegalArgumentException if the points are equal\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.SubLine#63",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.threed.Segment)",
    "snippet": "public SubLine(final Segment segment) throws MathIllegalArgumentException {\n  this(segment.getLine(),buildIntervalSet(segment.getStart(),segment.getEnd()));\n}",
    "begin_line": 63,
    "end_line": 65,
    "comment": "/** \n * Create a sub-line from a segment.\n * @param segment single segment forming the sub-line\n * @exception MathIllegalArgumentException if the segment endpoints are equal\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.getSegments#81",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.getSegments()",
    "snippet": "public List\u003cSegment\u003e getSegments(){\n  final List\u003cInterval\u003e list\u003dremainingRegion.asList();\n  final List\u003cSegment\u003e segments\u003dnew ArrayList\u003cSegment\u003e();\n  for (  final Interval interval : list) {\n    final Vector3D start\u003dline.toSpace(new Vector1D(interval.getInf()));\n    final Vector3D end\u003dline.toSpace(new Vector1D(interval.getSup()));\n    segments.add(new Segment(start,end,line));\n  }\n  return segments;\n}",
    "begin_line": 81,
    "end_line": 94,
    "comment": "/** \n * Get the endpoints of the sub-line. \u003cp\u003e A subline may be any arbitrary number of disjoints segments, so the endpoints are provided as a list of endpoint pairs. Each element of the list represents one segment, and each segment contains a start point at index 0 and an end point at index 1. If the sub-line is unbounded in the negative infinity direction, the start point of the first segment will have infinite coordinates. If the sub-line is unbounded in the positive infinity direction, the end point of the last segment will have infinite coordinates. So a sub-line covering the whole line will contain just one row and both elements of this row will have infinite coordinates. If the sub-line is empty, the returned list will contain 0 segments. \u003c/p\u003e\n * @return list of segments endpoints\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.intersection#110",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.intersection(org.apache.commons.math3.geometry.euclidean.threed.SubLine, boolean)",
    "snippet": "public Vector3D intersection(final SubLine subLine,final boolean includeEndPoints){\n  Vector3D v1D\u003dline.intersection(subLine.line);\n  Location loc1\u003dremainingRegion.checkPoint(line.toSubSpace(v1D));\n  Location loc2\u003dsubLine.remainingRegion.checkPoint(subLine.line.toSubSpace(v1D));\n  if (includeEndPoints) {\n    return ((loc1 !\u003d Location.OUTSIDE) \u0026\u0026 (loc2 !\u003d Location.OUTSIDE)) ? v1D : null;\n  }\n else {\n    return ((loc1 \u003d\u003d Location.INSIDE) \u0026\u0026 (loc2 \u003d\u003d Location.INSIDE)) ? v1D : null;\n  }\n}",
    "begin_line": 110,
    "end_line": 127,
    "comment": "/** \n * Get the intersection of the instance and another sub-line. \u003cp\u003e This method is related to the  {@link Line#intersection(Line) intersection} method in the {@link Line Line} class, but in additionto compute the point along infinite lines, it also checks the point lies on both sub-line ranges. \u003c/p\u003e\n * @param subLine other sub-line which may intersect instance\n * @param includeEndPoints if true, endpoints are considered to belong toinstance (i.e. they are closed sets) and may be returned, otherwise endpoints are considered to not belong to instance (i.e. they are open sets) and intersection occurring on endpoints lead to null being returned\n * @return the intersection point if there is one, null if the sub-lines don\u0027t intersect\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.buildIntervalSet#135",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.SubLine.buildIntervalSet(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "private static IntervalsSet buildIntervalSet(final Vector3D start,final Vector3D end) throws MathIllegalArgumentException {\n  final Line line\u003dnew Line(start,end);\n  return new IntervalsSet(line.toSubSpace(start).getX(),line.toSubSpace(end).getX());\n}",
    "begin_line": 135,
    "end_line": 140,
    "comment": "/** \n * Build an interval set from two points.\n * @param start start point\n * @param end end point\n * @return an interval set\n * @exception MathIllegalArgumentException if the points are equal\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#95",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, double, double)",
    "snippet": "public Vector3D(double x,double y,double z){\n  this.x\u003dx;\n  this.y\u003dy;\n  this.z\u003dz;\n}",
    "begin_line": 95,
    "end_line": 99,
    "comment": "/** \n * Simple constructor. Build a vector from its coordinates\n * @param x abscissa\n * @param y ordinate\n * @param z height\n * @see #getX()\n * @see #getY()\n * @see #getZ()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#107",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double[])",
    "snippet": "public Vector3D(double[] v) throws DimensionMismatchException {\n  if (v.length !\u003d 3) {\n    throw new DimensionMismatchException(v.length,3);\n  }\n  this.x\u003dv[0];\n  this.y\u003dv[1];\n  this.z\u003dv[2];\n}",
    "begin_line": 107,
    "end_line": 114,
    "comment": "/** \n * Simple constructor. Build a vector from its coordinates\n * @param v coordinates array\n * @exception DimensionMismatchException if array does not have 3 elements\n * @see #toArray()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#124",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, double)",
    "snippet": "public Vector3D(double alpha,double delta){\n  double cosDelta\u003dFastMath.cos(delta);\n  this.x\u003dFastMath.cos(alpha) * cosDelta;\n  this.y\u003dFastMath.sin(alpha) * cosDelta;\n  this.z\u003dFastMath.sin(delta);\n}",
    "begin_line": 124,
    "end_line": 129,
    "comment": "/** \n * Simple constructor. Build a vector from its azimuthal coordinates\n * @param alpha azimuth (\u0026alpha;) around Z(0 is +X, \u0026pi;/2 is +Y, \u0026pi; is -X and 3\u0026pi;/2 is -Y)\n * @param delta elevation (\u0026delta;) above (XY) plane, from -\u0026pi;/2 to +\u0026pi;/2\n * @see #getAlpha()\n * @see #getDelta()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#137",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public Vector3D(double a,Vector3D u){\n  this.x\u003da * u.x;\n  this.y\u003da * u.y;\n  this.z\u003da * u.z;\n}",
    "begin_line": 137,
    "end_line": 141,
    "comment": "/** \n * Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u\n * @param a scale factor\n * @param u base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#151",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public Vector3D(double a1,Vector3D u1,double a2,Vector3D u2){\n  this.x\u003dMathArrays.linearCombination(a1,u1.x,a2,u2.x);\n  this.y\u003dMathArrays.linearCombination(a1,u1.y,a2,u2.y);\n  this.z\u003dMathArrays.linearCombination(a1,u1.z,a2,u2.z);\n}",
    "begin_line": 151,
    "end_line": 155,
    "comment": "/** \n * Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#167",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public Vector3D(double a1,Vector3D u1,double a2,Vector3D u2,double a3,Vector3D u3){\n  this.x\u003dMathArrays.linearCombination(a1,u1.x,a2,u2.x,a3,u3.x);\n  this.y\u003dMathArrays.linearCombination(a1,u1.y,a2,u2.y,a3,u3.y);\n  this.z\u003dMathArrays.linearCombination(a1,u1.z,a2,u2.z,a3,u3.z);\n}",
    "begin_line": 167,
    "end_line": 172,
    "comment": "/** \n * Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n * @param a3 third scale factor\n * @param u3 third base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.Vector3D#186",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.Vector3D(double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D, double, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public Vector3D(double a1,Vector3D u1,double a2,Vector3D u2,double a3,Vector3D u3,double a4,Vector3D u4){\n  this.x\u003dMathArrays.linearCombination(a1,u1.x,a2,u2.x,a3,u3.x,a4,u4.x);\n  this.y\u003dMathArrays.linearCombination(a1,u1.y,a2,u2.y,a3,u3.y,a4,u4.y);\n  this.z\u003dMathArrays.linearCombination(a1,u1.z,a2,u2.z,a3,u3.z,a4,u4.z);\n}",
    "begin_line": 186,
    "end_line": 191,
    "comment": "/** \n * Linear constructor Build a vector from four other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n * @param a3 third scale factor\n * @param u3 third base (unscaled) vector\n * @param a4 fourth scale factor\n * @param u4 fourth base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getX#197",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getX()",
    "snippet": "public double getX(){\n  return x;\n}",
    "begin_line": 197,
    "end_line": 199,
    "comment": "/** \n * Get the abscissa of the vector.\n * @return abscissa of the vector\n * @see #Vector3D(double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getY#205",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getY()",
    "snippet": "public double getY(){\n  return y;\n}",
    "begin_line": 205,
    "end_line": 207,
    "comment": "/** \n * Get the ordinate of the vector.\n * @return ordinate of the vector\n * @see #Vector3D(double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getZ#213",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getZ()",
    "snippet": "public double getZ(){\n  return z;\n}",
    "begin_line": 213,
    "end_line": 215,
    "comment": "/** \n * Get the height of the vector.\n * @return height of the vector\n * @see #Vector3D(double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.toArray#221",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.toArray()",
    "snippet": "public double[] toArray(){\n  return new double[]{x,y,z};\n}",
    "begin_line": 221,
    "end_line": 223,
    "comment": "/** \n * Get the vector coordinates as a dimension 3 array.\n * @return vector coordinates\n * @see #Vector3D(double[])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getSpace#226",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getSpace()",
    "snippet": "public Space getSpace(){\n  return Euclidean3D.getInstance();\n}",
    "begin_line": 226,
    "end_line": 228,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getZero#231",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getZero()",
    "snippet": "public Vector3D getZero(){\n  return ZERO;\n}",
    "begin_line": 231,
    "end_line": 233,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getNorm1#236",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNorm1()",
    "snippet": "public double getNorm1(){\n  return FastMath.abs(x) + FastMath.abs(y) + FastMath.abs(z);\n}",
    "begin_line": 236,
    "end_line": 238,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getNorm#241",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNorm()",
    "snippet": "public double getNorm(){\n  return FastMath.sqrt(x * x + y * y + z * z);\n}",
    "begin_line": 241,
    "end_line": 244,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getNormSq#247",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNormSq()",
    "snippet": "public double getNormSq(){\n  return x * x + y * y + z * z;\n}",
    "begin_line": 247,
    "end_line": 250,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getNormInf#253",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getNormInf()",
    "snippet": "public double getNormInf(){\n  return FastMath.max(FastMath.max(FastMath.abs(x),FastMath.abs(y)),FastMath.abs(z));\n}",
    "begin_line": 253,
    "end_line": 255,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getAlpha#261",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getAlpha()",
    "snippet": "public double getAlpha(){\n  return FastMath.atan2(y,x);\n}",
    "begin_line": 261,
    "end_line": 263,
    "comment": "/** \n * Get the azimuth of the vector.\n * @return azimuth (\u0026alpha;) of the vector, between -\u0026pi; and +\u0026pi;\n * @see #Vector3D(double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.getDelta#269",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.getDelta()",
    "snippet": "public double getDelta(){\n  return FastMath.asin(z / getNorm());\n}",
    "begin_line": 269,
    "end_line": 271,
    "comment": "/** \n * Get the elevation of the vector.\n * @return elevation (\u0026delta;) of the vector, between -\u0026pi;/2 and +\u0026pi;/2\n * @see #Vector3D(double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.add#274",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.add(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public Vector3D add(final Vector\u003cEuclidean3D\u003e v){\n  final Vector3D v3\u003d(Vector3D)v;\n  return new Vector3D(x + v3.x,y + v3.y,z + v3.z);\n}",
    "begin_line": 274,
    "end_line": 277,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.add#280",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.add(double, org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public Vector3D add(double factor,final Vector\u003cEuclidean3D\u003e v){\n  return new Vector3D(1,this,factor,(Vector3D)v);\n}",
    "begin_line": 280,
    "end_line": 282,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.subtract#285",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.subtract(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public Vector3D subtract(final Vector\u003cEuclidean3D\u003e v){\n  final Vector3D v3\u003d(Vector3D)v;\n  return new Vector3D(x - v3.x,y - v3.y,z - v3.z);\n}",
    "begin_line": 285,
    "end_line": 288,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.subtract#291",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.subtract(double, org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public Vector3D subtract(final double factor,final Vector\u003cEuclidean3D\u003e v){\n  return new Vector3D(1,this,-factor,(Vector3D)v);\n}",
    "begin_line": 291,
    "end_line": 293,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.normalize#296",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.normalize()",
    "snippet": "public Vector3D normalize() throws MathArithmeticException {\n  double s\u003dgetNorm();\n  if (s \u003d\u003d 0) {\n    throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n  }\n  return scalarMultiply(1 / s);\n}",
    "begin_line": 296,
    "end_line": 302,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.orthogonal#319",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.orthogonal()",
    "snippet": "public Vector3D orthogonal() throws MathArithmeticException {\n  double threshold\u003d0.6 * getNorm();\n  if (threshold \u003d\u003d 0) {\n    throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n  }\n  if (FastMath.abs(x) \u003c\u003d threshold) {\n    double inverse\u003d1 / FastMath.sqrt(y * y + z * z);\n    return new Vector3D(0,inverse * z,-inverse * y);\n  }\n else   if (FastMath.abs(y) \u003c\u003d threshold) {\n    double inverse\u003d1 / FastMath.sqrt(x * x + z * z);\n    return new Vector3D(-inverse * z,0,inverse * x);\n  }\n  double inverse\u003d1 / FastMath.sqrt(x * x + y * y);\n  return new Vector3D(inverse * y,-inverse * x,0);\n}",
    "begin_line": 319,
    "end_line": 336,
    "comment": "/** \n * Get a vector orthogonal to the instance. \u003cp\u003eThere are an infinite number of normalized vectors orthogonal to the instance. This method picks up one of them almost arbitrarily. It is useful when one needs to compute a reference frame with one of the axes in a predefined direction. The following example shows how to build a frame having the k axis aligned with the known vector u : \u003cpre\u003e\u003ccode\u003e Vector3D k \u003d u.normalize(); Vector3D i \u003d k.orthogonal(); Vector3D j \u003d Vector3D.crossProduct(k, i); \u003c/code\u003e\u003c/pre\u003e\u003c/p\u003e\n * @return a new normalized vector orthogonal to the instance\n * @exception MathArithmeticException if the norm of the instance is null\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.angle#349",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.angle(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static double angle(Vector3D v1,Vector3D v2) throws MathArithmeticException {\n  double normProduct\u003dv1.getNorm() * v2.getNorm();\n  if (normProduct \u003d\u003d 0) {\n    throw new MathArithmeticException(LocalizedFormats.ZERO_NORM);\n  }\n  double dot\u003dv1.dotProduct(v2);\n  double threshold\u003dnormProduct * 0.9999;\n  if ((dot \u003c -threshold) || (dot \u003e threshold)) {\n    Vector3D v3\u003dcrossProduct(v1,v2);\n    if (dot \u003e\u003d 0) {\n      return FastMath.asin(v3.getNorm() / normProduct);\n    }\n    return FastMath.PI - FastMath.asin(v3.getNorm() / normProduct);\n  }\n  return FastMath.acos(dot / normProduct);\n}",
    "begin_line": 349,
    "end_line": 370,
    "comment": "/** \n * Compute the angular separation between two vectors. \u003cp\u003eThis method computes the angular separation between two vectors using the dot product for well separated vectors and the cross product for almost aligned vectors. This allows to have a good accuracy in all cases, even for vectors very close to each other.\u003c/p\u003e\n * @param v1 first vector\n * @param v2 second vector\n * @return angular separation between v1 and v2\n * @exception MathArithmeticException if either vector has a null norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.negate#373",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.negate()",
    "snippet": "public Vector3D negate(){\n  return new Vector3D(-x,-y,-z);\n}",
    "begin_line": 373,
    "end_line": 375,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.scalarMultiply#378",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.scalarMultiply(double)",
    "snippet": "public Vector3D scalarMultiply(double a){\n  return new Vector3D(a * x,a * y,a * z);\n}",
    "begin_line": 378,
    "end_line": 380,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.isNaN#383",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.isNaN()",
    "snippet": "public boolean isNaN(){\n  return Double.isNaN(x) || Double.isNaN(y) || Double.isNaN(z);\n}",
    "begin_line": 383,
    "end_line": 385,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.isInfinite#388",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.isInfinite()",
    "snippet": "public boolean isInfinite(){\n  return !isNaN() \u0026\u0026 (Double.isInfinite(x) || Double.isInfinite(y) || Double.isInfinite(z));\n}",
    "begin_line": 388,
    "end_line": 390,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.equals#412",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.equals(java.lang.Object)",
    "snippet": "@Override public boolean equals(Object other){\n  if (this \u003d\u003d other) {\n    return true;\n  }\n  if (other instanceof Vector3D) {\n    final Vector3D rhs\u003d(Vector3D)other;\n    if (rhs.isNaN()) {\n      return this.isNaN();\n    }\n    return (x \u003d\u003d rhs.x) \u0026\u0026 (y \u003d\u003d rhs.y) \u0026\u0026 (z \u003d\u003d rhs.z);\n  }\n  return false;\n}",
    "begin_line": 412,
    "end_line": 427,
    "comment": "/** \n * Test for the equality of two 3D vectors. \u003cp\u003e If all coordinates of two 3D vectors are exactly the same, and none are \u003ccode\u003eDouble.NaN\u003c/code\u003e, the two 3D vectors are considered to be equal. \u003c/p\u003e \u003cp\u003e \u003ccode\u003eNaN\u003c/code\u003e coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the 3D vector are equal to \u003ccode\u003eDouble.NaN\u003c/code\u003e, the 3D vector is equal to {@link #NaN}. \u003c/p\u003e\n * @param other Object to test for equality to this\n * @return true if two 3D vector objects are equal, false ifobject is null, not an instance of Vector3D, or not equal to this Vector3D instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.hashCode#437",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.hashCode()",
    "snippet": "@Override public int hashCode(){\n  if (isNaN()) {\n    return 642;\n  }\n  return 643 * (164 * MathUtils.hash(x) + 3 * MathUtils.hash(y) + MathUtils.hash(z));\n}",
    "begin_line": 437,
    "end_line": 442,
    "comment": "/** \n * Get a hashCode for the 3D vector. \u003cp\u003e All NaN values have the same hash code.\u003c/p\u003e\n * @return a hash code value for this object\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.dotProduct#452",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.dotProduct(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public double dotProduct(final Vector\u003cEuclidean3D\u003e v){\n  final Vector3D v3\u003d(Vector3D)v;\n  return MathArrays.linearCombination(x,v3.x,y,v3.y,z,v3.z);\n}",
    "begin_line": 452,
    "end_line": 455,
    "comment": "/** \n * {@inheritDoc}\u003cp\u003e The implementation uses specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It should be very accurate even for nearly orthogonal vectors. \u003c/p\u003e\n * @see MathArrays#linearCombination(double,double,double,double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.crossProduct#461",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.crossProduct(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public Vector3D crossProduct(final Vector\u003cEuclidean3D\u003e v){\n  final Vector3D v3\u003d(Vector3D)v;\n  return new Vector3D(MathArrays.linearCombination(y,v3.z,-z,v3.y),MathArrays.linearCombination(z,v3.x,-x,v3.z),MathArrays.linearCombination(x,v3.y,-y,v3.x));\n}",
    "begin_line": 461,
    "end_line": 466,
    "comment": "/** \n * Compute the cross-product of the instance with another vector.\n * @param v other vector\n * @return the cross product this ^ v as a new Vector3D\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distance1#469",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distance1(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public double distance1(Vector\u003cEuclidean3D\u003e v){\n  final Vector3D v3\u003d(Vector3D)v;\n  final double dx\u003dFastMath.abs(v3.x - x);\n  final double dy\u003dFastMath.abs(v3.y - y);\n  final double dz\u003dFastMath.abs(v3.z - z);\n  return dx + dy + dz;\n}",
    "begin_line": 469,
    "end_line": 475,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distance#478",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distance(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public double distance(Vector\u003cEuclidean3D\u003e v){\n  final Vector3D v3\u003d(Vector3D)v;\n  final double dx\u003dv3.x - x;\n  final double dy\u003dv3.y - y;\n  final double dz\u003dv3.z - z;\n  return FastMath.sqrt(dx * dx + dy * dy + dz * dz);\n}",
    "begin_line": 478,
    "end_line": 484,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distanceInf#487",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distanceInf(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public double distanceInf(Vector\u003cEuclidean3D\u003e v){\n  final Vector3D v3\u003d(Vector3D)v;\n  final double dx\u003dFastMath.abs(v3.x - x);\n  final double dy\u003dFastMath.abs(v3.y - y);\n  final double dz\u003dFastMath.abs(v3.z - z);\n  return FastMath.max(FastMath.max(dx,dy),dz);\n}",
    "begin_line": 487,
    "end_line": 493,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distanceSq#496",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distanceSq(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.threed.Euclidean3D\u003e)",
    "snippet": "public double distanceSq(Vector\u003cEuclidean3D\u003e v){\n  final Vector3D v3\u003d(Vector3D)v;\n  final double dx\u003dv3.x - x;\n  final double dy\u003dv3.y - y;\n  final double dz\u003dv3.z - z;\n  return dx * dx + dy * dy + dz * dz;\n}",
    "begin_line": 496,
    "end_line": 502,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.dotProduct#509",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.dotProduct(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static double dotProduct(Vector3D v1,Vector3D v2){\n  return v1.dotProduct(v2);\n}",
    "begin_line": 509,
    "end_line": 511,
    "comment": "/** \n * Compute the dot-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the dot product v1.v2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.crossProduct#518",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.crossProduct(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static Vector3D crossProduct(final Vector3D v1,final Vector3D v2){\n  return v1.crossProduct(v2);\n}",
    "begin_line": 518,
    "end_line": 520,
    "comment": "/** \n * Compute the cross-product of two vectors.\n * @param v1 first vector\n * @param v2 second vector\n * @return the cross product v1 ^ v2 as a new Vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distance1#530",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distance1(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static double distance1(Vector3D v1,Vector3D v2){\n  return v1.distance1(v2);\n}",
    "begin_line": 530,
    "end_line": 532,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e1\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ev1.subtract(v2).getNorm1()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L\u003csub\u003e1\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distance#542",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distance(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static double distance(Vector3D v1,Vector3D v2){\n  return v1.distance(v2);\n}",
    "begin_line": 542,
    "end_line": 544,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e2\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ev1.subtract(v2).getNorm()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L\u003csub\u003e2\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distanceInf#554",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distanceInf(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static double distanceInf(Vector3D v1,Vector3D v2){\n  return v1.distanceInf(v2);\n}",
    "begin_line": 554,
    "end_line": 556,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e\u0026infin;\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ev1.subtract(v2).getNormInf()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param v1 first vector\n * @param v2 second vector\n * @return the distance between v1 and v2 according to the L\u003csub\u003e\u0026infin;\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.distanceSq#566",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.distanceSq(org.apache.commons.math3.geometry.euclidean.threed.Vector3D, org.apache.commons.math3.geometry.euclidean.threed.Vector3D)",
    "snippet": "public static double distanceSq(Vector3D v1,Vector3D v2){\n  return v1.distanceSq(v2);\n}",
    "begin_line": 566,
    "end_line": 568,
    "comment": "/** \n * Compute the square of the distance between two vectors. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ev1.subtract(v2).getNormSq()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param v1 first vector\n * @param v2 second vector\n * @return the square of the distance between v1 and v2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.toString#574",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.toString()",
    "snippet": "@Override public String toString(){\n  return Vector3DFormat.getInstance().format(this);\n}",
    "begin_line": 574,
    "end_line": 576,
    "comment": "/** \n * Get a string representation of this vector.\n * @return a string representation of this vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector3D.toString#579",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/threed/Vector3D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D",
    "signature": "org.apache.commons.math3.geometry.euclidean.threed.Vector3D.toString(java.text.NumberFormat)",
    "snippet": "public String toString(final NumberFormat format){\n  return new Vector3DFormat(format).format(this);\n}",
    "begin_line": 579,
    "end_line": 581,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.Line#81",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.Line(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public Line(final Vector2D p1,final Vector2D p2){\n  reset(p1,p2);\n}",
    "begin_line": 81,
    "end_line": 83,
    "comment": "/** \n * Build a line from two points. \u003cp\u003eThe line is oriented from p1 to p2\u003c/p\u003e\n * @param p1 first point\n * @param p2 second point\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.Line#89",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.Line(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double)",
    "snippet": "public Line(final Vector2D p,final double angle){\n  reset(p,angle);\n}",
    "begin_line": 89,
    "end_line": 91,
    "comment": "/** \n * Build a line from a point and an angle.\n * @param p point belonging to the line\n * @param angle angle of the line with respect to abscissa axis\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.Line#99",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.Line(double, double, double, double)",
    "snippet": "private Line(final double angle,final double cos,final double sin,final double originOffset){\n  this.angle\u003dangle;\n  this.cos\u003dcos;\n  this.sin\u003dsin;\n  this.originOffset\u003doriginOffset;\n}",
    "begin_line": 99,
    "end_line": 104,
    "comment": "/** \n * Build a line from its internal characteristics.\n * @param angle angle of the line with respect to abscissa axis\n * @param cos cosine of the angle\n * @param sin sine of the angle\n * @param originOffset offset of the origin\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.Line#111",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.Line(org.apache.commons.math3.geometry.euclidean.twod.Line)",
    "snippet": "public Line(final Line line){\n  angle\u003dMathUtils.normalizeAngle(line.angle,FastMath.PI);\n  cos\u003dFastMath.cos(angle);\n  sin\u003dFastMath.sin(angle);\n  originOffset\u003dline.originOffset;\n}",
    "begin_line": 111,
    "end_line": 116,
    "comment": "/** \n * Copy constructor. \u003cp\u003eThe created instance is completely independent from the original instance, it is a deep copy.\u003c/p\u003e\n * @param line line to copy\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.copySelf#119",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.copySelf()",
    "snippet": "public Line copySelf(){\n  return new Line(this);\n}",
    "begin_line": 119,
    "end_line": 121,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.reset#128",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.reset(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public void reset(final Vector2D p1,final Vector2D p2){\n  final double dx\u003dp2.getX() - p1.getX();\n  final double dy\u003dp2.getY() - p1.getY();\n  final double d\u003dFastMath.hypot(dx,dy);\n  if (d \u003d\u003d 0.0) {\n    angle\u003d0.0;\n    cos\u003d1.0;\n    sin\u003d0.0;\n    originOffset\u003dp1.getY();\n  }\n else {\n    angle\u003dFastMath.PI + FastMath.atan2(-dy,-dx);\n    cos\u003dFastMath.cos(angle);\n    sin\u003dFastMath.sin(angle);\n    originOffset\u003d(p2.getX() * p1.getY() - p1.getX() * p2.getY()) / d;\n  }\n}",
    "begin_line": 128,
    "end_line": 143,
    "comment": "/** \n * Reset the instance as if built from two points. \u003cp\u003eThe line is oriented from p1 to p2\u003c/p\u003e\n * @param p1 first point\n * @param p2 second point\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.reset#149",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.reset(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double)",
    "snippet": "public void reset(final Vector2D p,final double alpha){\n  this.angle\u003dMathUtils.normalizeAngle(alpha,FastMath.PI);\n  cos\u003dFastMath.cos(this.angle);\n  sin\u003dFastMath.sin(this.angle);\n  originOffset\u003dcos * p.getY() - sin * p.getX();\n}",
    "begin_line": 149,
    "end_line": 154,
    "comment": "/** \n * Reset the instance as if built from a line and an angle.\n * @param p point belonging to the line\n * @param alpha angle of the line with respect to abscissa axis\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.revertSelf#158",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.revertSelf()",
    "snippet": "public void revertSelf(){\n  if (angle \u003c FastMath.PI) {\n    angle+\u003dFastMath.PI;\n  }\n else {\n    angle-\u003dFastMath.PI;\n  }\n  cos\u003d-cos;\n  sin\u003d-sin;\n  originOffset\u003d-originOffset;\n}",
    "begin_line": 158,
    "end_line": 167,
    "comment": "/** \n * Revert the instance.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getReverse#174",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getReverse()",
    "snippet": "public Line getReverse(){\n  return new Line((angle \u003c FastMath.PI) ? (angle + FastMath.PI) : (angle - FastMath.PI),-cos,-sin,-originOffset);\n}",
    "begin_line": 174,
    "end_line": 177,
    "comment": "/** \n * Get the reverse of the instance. \u003cp\u003eGet a line with reversed orientation with respect to the instance. A new object is built, the instance is untouched.\u003c/p\u003e\n * @return a new line, with orientation opposite to the instance orientation\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.toSubSpace#180",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.toSubSpace(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Vector1D toSubSpace(final Vector\u003cEuclidean2D\u003e point){\n  Vector2D p2\u003d(Vector2D)point;\n  return new Vector1D(cos * p2.getX() + sin * p2.getY());\n}",
    "begin_line": 180,
    "end_line": 183,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.toSpace#186",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.toSpace(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public Vector2D toSpace(final Vector\u003cEuclidean1D\u003e point){\n  final double abscissa\u003d((Vector1D)point).getX();\n  return new Vector2D(abscissa * cos - originOffset * sin,abscissa * sin + originOffset * cos);\n}",
    "begin_line": 186,
    "end_line": 190,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.intersection#197",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.intersection(org.apache.commons.math3.geometry.euclidean.twod.Line)",
    "snippet": "public Vector2D intersection(final Line other){\n  final double d\u003dsin * other.cos - other.sin * cos;\n  if (FastMath.abs(d) \u003c 1.0e-10) {\n    return null;\n  }\n  return new Vector2D((cos * other.originOffset - other.cos * originOffset) / d,(sin * other.originOffset - other.sin * originOffset) / d);\n}",
    "begin_line": 197,
    "end_line": 204,
    "comment": "/** \n * Get the intersection point of the instance and another line.\n * @param other other line\n * @return intersection point of the instance and the other lineor null if there are no intersection points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.wholeHyperplane#207",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.wholeHyperplane()",
    "snippet": "public SubLine wholeHyperplane(){\n  return new SubLine(this,new IntervalsSet());\n}",
    "begin_line": 207,
    "end_line": 209,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.wholeSpace#215",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.wholeSpace()",
    "snippet": "public PolygonsSet wholeSpace(){\n  return new PolygonsSet();\n}",
    "begin_line": 215,
    "end_line": 217,
    "comment": "/** \n * Build a region covering the whole space.\n * @return a region containing the instance (really a {@link PolygonsSet PolygonsSet} instance)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getOffset#229",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getOffset(org.apache.commons.math3.geometry.euclidean.twod.Line)",
    "snippet": "public double getOffset(final Line line){\n  return originOffset + ((cos * line.cos + sin * line.sin \u003e 0) ? -line.originOffset : line.originOffset);\n}",
    "begin_line": 229,
    "end_line": 232,
    "comment": "/** \n * Get the offset (oriented distance) of a parallel line. \u003cp\u003eThis method should be called only for parallel lines otherwise the result is not meaningful.\u003c/p\u003e \u003cp\u003eThe offset is 0 if both lines are the same, it is positive if the line is on the right side of the instance and negative if it is on the left side, according to its natural orientation.\u003c/p\u003e\n * @param line line to check\n * @return offset of the line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getOffset#235",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getOffset(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public double getOffset(final Vector\u003cEuclidean2D\u003e point){\n  Vector2D p2\u003d(Vector2D)point;\n  return sin * p2.getX() - cos * p2.getY() + originOffset;\n}",
    "begin_line": 235,
    "end_line": 238,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.sameOrientationAs#241",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.sameOrientationAs(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public boolean sameOrientationAs(final Hyperplane\u003cEuclidean2D\u003e other){\n  final Line otherL\u003d(Line)other;\n  return (sin * otherL.sin + cos * otherL.cos) \u003e\u003d 0.0;\n}",
    "begin_line": 241,
    "end_line": 244,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getPointAt#252",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getPointAt(org.apache.commons.math3.geometry.euclidean.oned.Vector1D, double)",
    "snippet": "public Vector2D getPointAt(final Vector1D abscissa,final double offset){\n  final double x\u003dabscissa.getX();\n  final double dOffset\u003doffset - originOffset;\n  return new Vector2D(x * cos + dOffset * sin,x * sin - dOffset * cos);\n}",
    "begin_line": 252,
    "end_line": 256,
    "comment": "/** \n * Get one point from the plane.\n * @param abscissa desired abscissa for the point\n * @param offset desired offset for the point\n * @return one point in the plane, with given abscissa and offsetrelative to the line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.contains#262",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.contains(org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public boolean contains(final Vector2D p){\n  return FastMath.abs(getOffset(p)) \u003c 1.0e-10;\n}",
    "begin_line": 262,
    "end_line": 264,
    "comment": "/** \n * Check if the line contains a point.\n * @param p point to check\n * @return true if p belongs to the line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.distance#275",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.distance(org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public double distance(final Vector2D p){\n  return FastMath.abs(getOffset(p));\n}",
    "begin_line": 275,
    "end_line": 277,
    "comment": "/** \n * Compute the distance between the instance and a point. \u003cp\u003eThis is a shortcut for invoking FastMath.abs(getOffset(p)), and provides consistency with what is in the org.apache.commons.math3.geometry.euclidean.threed.Line class.\u003c/p\u003e\n * @param p to check\n * @return distance between the instance and the point\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.isParallelTo#284",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.isParallelTo(org.apache.commons.math3.geometry.euclidean.twod.Line)",
    "snippet": "public boolean isParallelTo(final Line line){\n  return FastMath.abs(sin * line.cos - cos * line.sin) \u003c 1.0e-10;\n}",
    "begin_line": 284,
    "end_line": 286,
    "comment": "/** \n * Check the instance is parallel to another line.\n * @param line other line to check\n * @return true if the instance is parallel to the other line(they can have either the same or opposite orientations)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.translateToPoint#291",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.translateToPoint(org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public void translateToPoint(final Vector2D p){\n  originOffset\u003dcos * p.getY() - sin * p.getX();\n}",
    "begin_line": 291,
    "end_line": 293,
    "comment": "/** \n * Translate the line to force it passing by a point.\n * @param p point by which the line should pass\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getAngle#298",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getAngle()",
    "snippet": "public double getAngle(){\n  return MathUtils.normalizeAngle(angle,FastMath.PI);\n}",
    "begin_line": 298,
    "end_line": 300,
    "comment": "/** \n * Get the angle of the line.\n * @return the angle of the line with respect to the abscissa axis\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.setAngle#305",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.setAngle(double)",
    "snippet": "public void setAngle(final double angle){\n  this.angle\u003dMathUtils.normalizeAngle(angle,FastMath.PI);\n  cos\u003dFastMath.cos(this.angle);\n  sin\u003dFastMath.sin(this.angle);\n}",
    "begin_line": 305,
    "end_line": 309,
    "comment": "/** \n * Set the angle of the line.\n * @param angle new angle of the line with respect to the abscissa axis\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getOriginOffset#314",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getOriginOffset()",
    "snippet": "public double getOriginOffset(){\n  return originOffset;\n}",
    "begin_line": 314,
    "end_line": 316,
    "comment": "/** \n * Get the offset of the origin.\n * @return the offset of the origin\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.setOriginOffset#321",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.setOriginOffset(double)",
    "snippet": "public void setOriginOffset(final double offset){\n  originOffset\u003doffset;\n}",
    "begin_line": 321,
    "end_line": 323,
    "comment": "/** \n * Set the offset of the origin.\n * @param offset offset of the origin\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Line.getTransform#338",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.getTransform(java.awt.geom.AffineTransform)",
    "snippet": "public static Transform\u003cEuclidean2D,Euclidean1D\u003e getTransform(final AffineTransform transform) throws MathIllegalArgumentException {\n  return new LineTransform(transform);\n}",
    "begin_line": 338,
    "end_line": 341,
    "comment": "/** \n * Get a  {@link org.apache.commons.math3.geometry.partitioning.Transform Transform} embedding an affine transform.\n * @param transform affine transform to embed (must be inversibleotherwise the  {@link org.apache.commons.math3.geometry.partitioning.Transform#apply(Hyperplane) apply(Hyperplane)} method would work only for some lines, andfail for other ones)\n * @return a new transform that can be applied to either {@link Vector2D Vector2D},  {@link Line Line} or {@link org.apache.commons.math3.geometry.partitioning.SubHyperplane SubHyperplane} instances\n * @exception MathIllegalArgumentException if the transform is non invertible\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LineTransform.LineTransform#371",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.LineTransform(java.awt.geom.AffineTransform)",
    "snippet": "public LineTransform(final AffineTransform transform) throws MathIllegalArgumentException {\n  final double[] m\u003dnew double[6];\n  transform.getMatrix(m);\n  cXX\u003dm[0];\n  cXY\u003dm[2];\n  cX1\u003dm[4];\n  cYX\u003dm[1];\n  cYY\u003dm[3];\n  cY1\u003dm[5];\n  c1Y\u003dcXY * cY1 - cYY * cX1;\n  c1X\u003dcXX * cY1 - cYX * cX1;\n  c11\u003dcXX * cYY - cYX * cXY;\n  if (FastMath.abs(c11) \u003c 1.0e-20) {\n    throw new MathIllegalArgumentException(LocalizedFormats.NON_INVERTIBLE_TRANSFORM);\n  }\n}",
    "begin_line": 371,
    "end_line": 390,
    "comment": "/** \n * Build an affine line transform from a n  {@code AffineTransform}.\n * @param transform transform to use (must be invertible otherwisethe  {@link LineTransform#apply(Hyperplane)} method would workonly for some lines, and fail for other ones)\n * @exception MathIllegalArgumentException if the transform is non invertible\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LineTransform.apply#393",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.apply(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Vector2D apply(final Vector\u003cEuclidean2D\u003e point){\n  final Vector2D p2D\u003d(Vector2D)point;\n  final double x\u003dp2D.getX();\n  final double y\u003dp2D.getY();\n  return new Vector2D(cXX * x + cXY * y + cX1,cYX * x + cYY * y + cY1);\n}",
    "begin_line": 393,
    "end_line": 399,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LineTransform.apply#402",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.apply(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Line apply(final Hyperplane\u003cEuclidean2D\u003e hyperplane){\n  final Line line\u003d(Line)hyperplane;\n  final double rOffset\u003dc1X * line.cos + c1Y * line.sin + c11 * line.originOffset;\n  final double rCos\u003dcXX * line.cos + cXY * line.sin;\n  final double rSin\u003dcYX * line.cos + cYY * line.sin;\n  final double inv\u003d1.0 / FastMath.sqrt(rSin * rSin + rCos * rCos);\n  return new Line(FastMath.PI + FastMath.atan2(-rSin,-rCos),inv * rCos,inv * rSin,inv * rOffset);\n}",
    "begin_line": 402,
    "end_line": 411,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LineTransform.apply#414",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Line.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Line",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Line.apply(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e, org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e, org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public SubHyperplane\u003cEuclidean1D\u003e apply(final SubHyperplane\u003cEuclidean1D\u003e sub,final Hyperplane\u003cEuclidean2D\u003e original,final Hyperplane\u003cEuclidean2D\u003e transformed){\n  final OrientedPoint op\u003d(OrientedPoint)sub.getHyperplane();\n  final Line originalLine\u003d(Line)original;\n  final Line transformedLine\u003d(Line)transformed;\n  final Vector1D newLoc\u003dtransformedLine.toSubSpace(apply(originalLine.toSpace(op.getLocation())));\n  return new OrientedPoint(newLoc,op.isDirect()).wholeHyperplane();\n}",
    "begin_line": 414,
    "end_line": 423,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.SubLine#46",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.SubLine(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e, org.apache.commons.math3.geometry.partitioning.Region\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "public SubLine(final Hyperplane\u003cEuclidean2D\u003e hyperplane,final Region\u003cEuclidean1D\u003e remainingRegion){\n  super(hyperplane,remainingRegion);\n}",
    "begin_line": 46,
    "end_line": 49,
    "comment": "/** \n * Simple constructor.\n * @param hyperplane underlying hyperplane\n * @param remainingRegion remaining region of the hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.SubLine#55",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public SubLine(final Vector2D start,final Vector2D end){\n  super(new Line(start,end),buildIntervalSet(start,end));\n}",
    "begin_line": 55,
    "end_line": 57,
    "comment": "/** \n * Create a sub-line from two endpoints.\n * @param start start point\n * @param end end point\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.SubLine#62",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.SubLine(org.apache.commons.math3.geometry.euclidean.twod.Segment)",
    "snippet": "public SubLine(final Segment segment){\n  super(segment.getLine(),buildIntervalSet(segment.getStart(),segment.getEnd()));\n}",
    "begin_line": 62,
    "end_line": 64,
    "comment": "/** \n * Create a sub-line from a segment.\n * @param segment single segment forming the sub-line\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.getSegments#80",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.getSegments()",
    "snippet": "public List\u003cSegment\u003e getSegments(){\n  final Line line\u003d(Line)getHyperplane();\n  final List\u003cInterval\u003e list\u003d((IntervalsSet)getRemainingRegion()).asList();\n  final List\u003cSegment\u003e segments\u003dnew ArrayList\u003cSegment\u003e();\n  for (  final Interval interval : list) {\n    final Vector2D start\u003dline.toSpace(new Vector1D(interval.getInf()));\n    final Vector2D end\u003dline.toSpace(new Vector1D(interval.getSup()));\n    segments.add(new Segment(start,end,line));\n  }\n  return segments;\n}",
    "begin_line": 80,
    "end_line": 94,
    "comment": "/** \n * Get the endpoints of the sub-line. \u003cp\u003e A subline may be any arbitrary number of disjoints segments, so the endpoints are provided as a list of endpoint pairs. Each element of the list represents one segment, and each segment contains a start point at index 0 and an end point at index 1. If the sub-line is unbounded in the negative infinity direction, the start point of the first segment will have infinite coordinates. If the sub-line is unbounded in the positive infinity direction, the end point of the last segment will have infinite coordinates. So a sub-line covering the whole line will contain just one row and both elements of this row will have infinite coordinates. If the sub-line is empty, the returned list will contain 0 segments. \u003c/p\u003e\n * @return list of segments endpoints\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.intersection#110",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.intersection(org.apache.commons.math3.geometry.euclidean.twod.SubLine, boolean)",
    "snippet": "public Vector2D intersection(final SubLine subLine,final boolean includeEndPoints){\n  Line line1\u003d(Line)getHyperplane();\n  Line line2\u003d(Line)subLine.getHyperplane();\n  Vector2D v2D\u003dline1.intersection(line2);\n  Location loc1\u003dgetRemainingRegion().checkPoint(line1.toSubSpace(v2D));\n  Location loc2\u003dsubLine.getRemainingRegion().checkPoint(line2.toSubSpace(v2D));\n  if (includeEndPoints) {\n    return ((loc1 !\u003d Location.OUTSIDE) \u0026\u0026 (loc2 !\u003d Location.OUTSIDE)) ? v2D : null;\n  }\n else {\n    return ((loc1 \u003d\u003d Location.INSIDE) \u0026\u0026 (loc2 \u003d\u003d Location.INSIDE)) ? v2D : null;\n  }\n}",
    "begin_line": 110,
    "end_line": 131,
    "comment": "/** \n * Get the intersection of the instance and another sub-line. \u003cp\u003e This method is related to the  {@link Line#intersection(Line) intersection} method in the {@link Line Line} class, but in additionto compute the point along infinite lines, it also checks the point lies on both sub-line ranges. \u003c/p\u003e\n * @param subLine other sub-line which may intersect instance\n * @param includeEndPoints if true, endpoints are considered to belong toinstance (i.e. they are closed sets) and may be returned, otherwise endpoints are considered to not belong to instance (i.e. they are open sets) and intersection occurring on endpoints lead to null being returned\n * @return the intersection point if there is one, null if the sub-lines don\u0027t intersect\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.buildIntervalSet#138",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.buildIntervalSet(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "private static IntervalsSet buildIntervalSet(final Vector2D start,final Vector2D end){\n  final Line line\u003dnew Line(start,end);\n  return new IntervalsSet(line.toSubSpace(start).getX(),line.toSubSpace(end).getX());\n}",
    "begin_line": 138,
    "end_line": 142,
    "comment": "/** \n * Build an interval set from two points.\n * @param start start point\n * @param end end point\n * @return an interval set\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.buildNew#146",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.buildNew(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e, org.apache.commons.math3.geometry.partitioning.Region\u003corg.apache.commons.math3.geometry.euclidean.oned.Euclidean1D\u003e)",
    "snippet": "@Override protected AbstractSubHyperplane\u003cEuclidean2D,Euclidean1D\u003e buildNew(final Hyperplane\u003cEuclidean2D\u003e hyperplane,final Region\u003cEuclidean1D\u003e remainingRegion){\n  return new SubLine(hyperplane,remainingRegion);\n}",
    "begin_line": 146,
    "end_line": 149,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.side#153",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.side(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "@Override public Side side(final Hyperplane\u003cEuclidean2D\u003e hyperplane){\n  final Line thisLine\u003d(Line)getHyperplane();\n  final Line otherLine\u003d(Line)hyperplane;\n  final Vector2D crossing\u003dthisLine.intersection(otherLine);\n  if (crossing \u003d\u003d null) {\n    final double global\u003dotherLine.getOffset(thisLine);\n    return (global \u003c -1.0e-10) ? Side.MINUS : ((global \u003e 1.0e-10) ? Side.PLUS : Side.HYPER);\n  }\n  final boolean direct\u003dFastMath.sin(thisLine.getAngle() - otherLine.getAngle()) \u003c 0;\n  final Vector1D x\u003dthisLine.toSubSpace(crossing);\n  return getRemainingRegion().side(new OrientedPoint(x,direct));\n}",
    "begin_line": 153,
    "end_line": 170,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "SubLine.split#174",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/SubLine.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.SubLine",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.SubLine.split(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "@Override public SplitSubHyperplane\u003cEuclidean2D\u003e split(final Hyperplane\u003cEuclidean2D\u003e hyperplane){\n  final Line thisLine\u003d(Line)getHyperplane();\n  final Line otherLine\u003d(Line)hyperplane;\n  final Vector2D crossing\u003dthisLine.intersection(otherLine);\n  if (crossing \u003d\u003d null) {\n    final double global\u003dotherLine.getOffset(thisLine);\n    return (global \u003c -1.0e-10) ? new SplitSubHyperplane\u003cEuclidean2D\u003e(null,this) : new SplitSubHyperplane\u003cEuclidean2D\u003e(this,null);\n  }\n  final boolean direct\u003dFastMath.sin(thisLine.getAngle() - otherLine.getAngle()) \u003c 0;\n  final Vector1D x\u003dthisLine.toSubSpace(crossing);\n  final SubHyperplane\u003cEuclidean1D\u003e subPlus\u003dnew OrientedPoint(x,!direct).wholeHyperplane();\n  final SubHyperplane\u003cEuclidean1D\u003e subMinus\u003dnew OrientedPoint(x,direct).wholeHyperplane();\n  final BSPTree\u003cEuclidean1D\u003e splitTree\u003dgetRemainingRegion().getTree(false).split(subMinus);\n  final BSPTree\u003cEuclidean1D\u003e plusTree\u003dgetRemainingRegion().isEmpty(splitTree.getPlus()) ? new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE) : new BSPTree\u003cEuclidean1D\u003e(subPlus,new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE),splitTree.getPlus(),null);\n  final BSPTree\u003cEuclidean1D\u003e minusTree\u003dgetRemainingRegion().isEmpty(splitTree.getMinus()) ? new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE) : new BSPTree\u003cEuclidean1D\u003e(subMinus,new BSPTree\u003cEuclidean1D\u003e(Boolean.FALSE),splitTree.getMinus(),null);\n  return new SplitSubHyperplane\u003cEuclidean2D\u003e(new SubLine(thisLine.copySelf(),new IntervalsSet(plusTree)),new SubLine(thisLine.copySelf(),new IntervalsSet(minusTree)));\n}",
    "begin_line": 174,
    "end_line": 207,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.Vector2D#68",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double, double)",
    "snippet": "public Vector2D(double x,double y){\n  this.x\u003dx;\n  this.y\u003dy;\n}",
    "begin_line": 68,
    "end_line": 71,
    "comment": "/** \n * Simple constructor. Build a vector from its coordinates\n * @param x abscissa\n * @param y ordinate\n * @see #getX()\n * @see #getY()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.Vector2D#79",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double[])",
    "snippet": "public Vector2D(double[] v) throws DimensionMismatchException {\n  if (v.length !\u003d 2) {\n    throw new DimensionMismatchException(v.length,2);\n  }\n  this.x\u003dv[0];\n  this.y\u003dv[1];\n}",
    "begin_line": 79,
    "end_line": 85,
    "comment": "/** \n * Simple constructor. Build a vector from its coordinates\n * @param v coordinates array\n * @exception DimensionMismatchException if array does not have 2 elements\n * @see #toArray()\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.Vector2D#93",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public Vector2D(double a,Vector2D u){\n  this.x\u003da * u.x;\n  this.y\u003da * u.y;\n}",
    "begin_line": 93,
    "end_line": 96,
    "comment": "/** \n * Multiplicative constructor Build a vector from another one and a scale factor. The vector built will be a * u\n * @param a scale factor\n * @param u base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.Vector2D#106",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public Vector2D(double a1,Vector2D u1,double a2,Vector2D u2){\n  this.x\u003da1 * u1.x + a2 * u2.x;\n  this.y\u003da1 * u1.y + a2 * u2.y;\n}",
    "begin_line": 106,
    "end_line": 109,
    "comment": "/** \n * Linear constructor Build a vector from two other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.Vector2D#121",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public Vector2D(double a1,Vector2D u1,double a2,Vector2D u2,double a3,Vector2D u3){\n  this.x\u003da1 * u1.x + a2 * u2.x + a3 * u3.x;\n  this.y\u003da1 * u1.y + a2 * u2.y + a3 * u3.y;\n}",
    "begin_line": 121,
    "end_line": 125,
    "comment": "/** \n * Linear constructor Build a vector from three other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n * @param a3 third scale factor\n * @param u3 third base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.Vector2D#139",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.Vector2D(double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D, double, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public Vector2D(double a1,Vector2D u1,double a2,Vector2D u2,double a3,Vector2D u3,double a4,Vector2D u4){\n  this.x\u003da1 * u1.x + a2 * u2.x + a3 * u3.x + a4 * u4.x;\n  this.y\u003da1 * u1.y + a2 * u2.y + a3 * u3.y + a4 * u4.y;\n}",
    "begin_line": 139,
    "end_line": 143,
    "comment": "/** \n * Linear constructor Build a vector from four other ones and corresponding scale factors. The vector built will be a1 * u1 + a2 * u2 + a3 * u3 + a4 * u4\n * @param a1 first scale factor\n * @param u1 first base (unscaled) vector\n * @param a2 second scale factor\n * @param u2 second base (unscaled) vector\n * @param a3 third scale factor\n * @param u3 third base (unscaled) vector\n * @param a4 fourth scale factor\n * @param u4 fourth base (unscaled) vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getX#149",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getX()",
    "snippet": "public double getX(){\n  return x;\n}",
    "begin_line": 149,
    "end_line": 151,
    "comment": "/** \n * Get the abscissa of the vector.\n * @return abscissa of the vector\n * @see #Vector2D(double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getY#157",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getY()",
    "snippet": "public double getY(){\n  return y;\n}",
    "begin_line": 157,
    "end_line": 159,
    "comment": "/** \n * Get the ordinate of the vector.\n * @return ordinate of the vector\n * @see #Vector2D(double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.toArray#165",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.toArray()",
    "snippet": "public double[] toArray(){\n  return new double[]{x,y};\n}",
    "begin_line": 165,
    "end_line": 167,
    "comment": "/** \n * Get the vector coordinates as a dimension 2 array.\n * @return vector coordinates\n * @see #Vector2D(double[])\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getSpace#170",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getSpace()",
    "snippet": "public Space getSpace(){\n  return Euclidean2D.getInstance();\n}",
    "begin_line": 170,
    "end_line": 172,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getZero#175",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getZero()",
    "snippet": "public Vector2D getZero(){\n  return ZERO;\n}",
    "begin_line": 175,
    "end_line": 177,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getNorm1#180",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getNorm1()",
    "snippet": "public double getNorm1(){\n  return FastMath.abs(x) + FastMath.abs(y);\n}",
    "begin_line": 180,
    "end_line": 182,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getNorm#185",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getNorm()",
    "snippet": "public double getNorm(){\n  return FastMath.sqrt(x * x + y * y);\n}",
    "begin_line": 185,
    "end_line": 187,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getNormSq#190",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getNormSq()",
    "snippet": "public double getNormSq(){\n  return x * x + y * y;\n}",
    "begin_line": 190,
    "end_line": 192,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.getNormInf#195",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.getNormInf()",
    "snippet": "public double getNormInf(){\n  return FastMath.max(FastMath.abs(x),FastMath.abs(y));\n}",
    "begin_line": 195,
    "end_line": 197,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.add#200",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.add(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Vector2D add(Vector\u003cEuclidean2D\u003e v){\n  Vector2D v2\u003d(Vector2D)v;\n  return new Vector2D(x + v2.getX(),y + v2.getY());\n}",
    "begin_line": 200,
    "end_line": 203,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.add#206",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.add(double, org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Vector2D add(double factor,Vector\u003cEuclidean2D\u003e v){\n  Vector2D v2\u003d(Vector2D)v;\n  return new Vector2D(x + factor * v2.getX(),y + factor * v2.getY());\n}",
    "begin_line": 206,
    "end_line": 209,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.subtract#212",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.subtract(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Vector2D subtract(Vector\u003cEuclidean2D\u003e p){\n  Vector2D p3\u003d(Vector2D)p;\n  return new Vector2D(x - p3.x,y - p3.y);\n}",
    "begin_line": 212,
    "end_line": 215,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.subtract#218",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.subtract(double, org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public Vector2D subtract(double factor,Vector\u003cEuclidean2D\u003e v){\n  Vector2D v2\u003d(Vector2D)v;\n  return new Vector2D(x - factor * v2.getX(),y - factor * v2.getY());\n}",
    "begin_line": 218,
    "end_line": 221,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.normalize#224",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.normalize()",
    "snippet": "public Vector2D normalize() throws MathArithmeticException {\n  double s\u003dgetNorm();\n  if (s \u003d\u003d 0) {\n    throw new MathArithmeticException(LocalizedFormats.CANNOT_NORMALIZE_A_ZERO_NORM_VECTOR);\n  }\n  return scalarMultiply(1 / s);\n}",
    "begin_line": 224,
    "end_line": 230,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.negate#232",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.negate()",
    "snippet": "public Vector2D negate(){\n  return new Vector2D(-x,-y);\n}",
    "begin_line": 232,
    "end_line": 234,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.scalarMultiply#237",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.scalarMultiply(double)",
    "snippet": "public Vector2D scalarMultiply(double a){\n  return new Vector2D(a * x,a * y);\n}",
    "begin_line": 237,
    "end_line": 239,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.isNaN#242",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.isNaN()",
    "snippet": "public boolean isNaN(){\n  return Double.isNaN(x) || Double.isNaN(y);\n}",
    "begin_line": 242,
    "end_line": 244,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.isInfinite#247",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.isInfinite()",
    "snippet": "public boolean isInfinite(){\n  return !isNaN() \u0026\u0026 (Double.isInfinite(x) || Double.isInfinite(y));\n}",
    "begin_line": 247,
    "end_line": 249,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distance1#252",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distance1(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public double distance1(Vector\u003cEuclidean2D\u003e p){\n  Vector2D p3\u003d(Vector2D)p;\n  final double dx\u003dFastMath.abs(p3.x - x);\n  final double dy\u003dFastMath.abs(p3.y - y);\n  return dx + dy;\n}",
    "begin_line": 252,
    "end_line": 257,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distance#260",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distance(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public double distance(Vector\u003cEuclidean2D\u003e p){\n  Vector2D p3\u003d(Vector2D)p;\n  final double dx\u003dp3.x - x;\n  final double dy\u003dp3.y - y;\n  return FastMath.sqrt(dx * dx + dy * dy);\n}",
    "begin_line": 260,
    "end_line": 265,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distanceInf#268",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distanceInf(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public double distanceInf(Vector\u003cEuclidean2D\u003e p){\n  Vector2D p3\u003d(Vector2D)p;\n  final double dx\u003dFastMath.abs(p3.x - x);\n  final double dy\u003dFastMath.abs(p3.y - y);\n  return FastMath.max(dx,dy);\n}",
    "begin_line": 268,
    "end_line": 273,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distanceSq#276",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distanceSq(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public double distanceSq(Vector\u003cEuclidean2D\u003e p){\n  Vector2D p3\u003d(Vector2D)p;\n  final double dx\u003dp3.x - x;\n  final double dy\u003dp3.y - y;\n  return dx * dx + dy * dy;\n}",
    "begin_line": 276,
    "end_line": 281,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.dotProduct#284",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.dotProduct(org.apache.commons.math3.geometry.Vector\u003corg.apache.commons.math3.geometry.euclidean.twod.Euclidean2D\u003e)",
    "snippet": "public double dotProduct(final Vector\u003cEuclidean2D\u003e v){\n  final Vector2D v2\u003d(Vector2D)v;\n  return x * v2.x + y * v2.y;\n}",
    "begin_line": 284,
    "end_line": 287,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distance#297",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distance(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public static double distance(Vector2D p1,Vector2D p2){\n  return p1.distance(p2);\n}",
    "begin_line": 297,
    "end_line": 299,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e2\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ep1.subtract(p2).getNorm()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L\u003csub\u003e2\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distanceInf#309",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distanceInf(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public static double distanceInf(Vector2D p1,Vector2D p2){\n  return p1.distanceInf(p2);\n}",
    "begin_line": 309,
    "end_line": 311,
    "comment": "/** \n * Compute the distance between two vectors according to the L\u003csub\u003e\u0026infin;\u003c/sub\u003e norm. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ep1.subtract(p2).getNormInf()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param p1 first vector\n * @param p2 second vector\n * @return the distance between p1 and p2 according to the L\u003csub\u003e\u0026infin;\u003c/sub\u003e norm\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.distanceSq#321",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.distanceSq(org.apache.commons.math3.geometry.euclidean.twod.Vector2D, org.apache.commons.math3.geometry.euclidean.twod.Vector2D)",
    "snippet": "public static double distanceSq(Vector2D p1,Vector2D p2){\n  return p1.distanceSq(p2);\n}",
    "begin_line": 321,
    "end_line": 323,
    "comment": "/** \n * Compute the square of the distance between two vectors. \u003cp\u003eCalling this method is equivalent to calling: \u003ccode\u003ep1.subtract(p2).getNormSq()\u003c/code\u003e except that no intermediate vector is built\u003c/p\u003e\n * @param p1 first vector\n * @param p2 second vector\n * @return the square of the distance between p1 and p2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.equals#345",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.equals(java.lang.Object)",
    "snippet": "@Override public boolean equals(Object other){\n  if (this \u003d\u003d other) {\n    return true;\n  }\n  if (other instanceof Vector2D) {\n    final Vector2D rhs\u003d(Vector2D)other;\n    if (rhs.isNaN()) {\n      return this.isNaN();\n    }\n    return (x \u003d\u003d rhs.x) \u0026\u0026 (y \u003d\u003d rhs.y);\n  }\n  return false;\n}",
    "begin_line": 345,
    "end_line": 360,
    "comment": "/** \n * Test for the equality of two 2D vectors. \u003cp\u003e If all coordinates of two 2D vectors are exactly the same, and none are \u003ccode\u003eDouble.NaN\u003c/code\u003e, the two 2D vectors are considered to be equal. \u003c/p\u003e \u003cp\u003e \u003ccode\u003eNaN\u003c/code\u003e coordinates are considered to affect globally the vector and be equals to each other - i.e, if either (or all) coordinates of the 2D vector are equal to \u003ccode\u003eDouble.NaN\u003c/code\u003e, the 2D vector is equal to {@link #NaN}. \u003c/p\u003e\n * @param other Object to test for equality to this\n * @return true if two 2D vector objects are equal, false ifobject is null, not an instance of Vector2D, or not equal to this Vector2D instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.hashCode#370",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.hashCode()",
    "snippet": "@Override public int hashCode(){\n  if (isNaN()) {\n    return 542;\n  }\n  return 122 * (76 * MathUtils.hash(x) + MathUtils.hash(y));\n}",
    "begin_line": 370,
    "end_line": 375,
    "comment": "/** \n * Get a hashCode for the 2D vector. \u003cp\u003e All NaN values have the same hash code.\u003c/p\u003e\n * @return a hash code value for this object\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.toString#381",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.toString()",
    "snippet": "@Override public String toString(){\n  return Vector2DFormat.getInstance().format(this);\n}",
    "begin_line": 381,
    "end_line": 383,
    "comment": "/** \n * Get a string representation of this vector.\n * @return a string representation of this vector\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Vector2D.toString#386",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/euclidean/twod/Vector2D.java",
    "class_name": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D",
    "signature": "org.apache.commons.math3.geometry.euclidean.twod.Vector2D.toString(java.text.NumberFormat)",
    "snippet": "public String toString(final NumberFormat format){\n  return new Vector2DFormat(format).format(this);\n}",
    "begin_line": 386,
    "end_line": 388,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.AbstractRegion#51",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion()",
    "snippet": "protected AbstractRegion(){\n  tree\u003dnew BSPTree\u003cS\u003e(Boolean.TRUE);\n}",
    "begin_line": 51,
    "end_line": 53,
    "comment": "/** \n * Build a region representing the whole space.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.AbstractRegion#67",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "protected AbstractRegion(final BSPTree\u003cS\u003e tree){\n  this.tree\u003dtree;\n}",
    "begin_line": 67,
    "end_line": 69,
    "comment": "/** \n * Build a region from an inside/outside BSP tree. \u003cp\u003eThe leaf nodes of the BSP tree \u003cem\u003emust\u003c/em\u003e have a {@code Boolean} attribute representing the inside status ofthe corresponding cell (true for inside cells, false for outside cells). In order to avoid building too many small objects, it is recommended to use the predefined constants {@code Boolean.TRUE} and {@code Boolean.FALSE}. The tree also \u003cem\u003emust\u003c/em\u003e have either null internal nodes or internal nodes representing the boundary as specified in the {@link #getTree getTree} method).\u003c/p\u003e\n * @param tree inside/outside BSP tree representing the region\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.AbstractRegion#90",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion(java.util.Collection\u003corg.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e\u003e)",
    "snippet": "protected AbstractRegion(final Collection\u003cSubHyperplane\u003cS\u003e\u003e boundary){\n  if (boundary.size() \u003d\u003d 0) {\n    tree\u003dnew BSPTree\u003cS\u003e(Boolean.TRUE);\n  }\n else {\n    final TreeSet\u003cSubHyperplane\u003cS\u003e\u003e ordered\u003dnew TreeSet\u003cSubHyperplane\u003cS\u003e\u003e(new Comparator\u003cSubHyperplane\u003cS\u003e\u003e(){\n      public int compare(      final SubHyperplane\u003cS\u003e o1,      final SubHyperplane\u003cS\u003e o2){\n        final double size1\u003do1.getSize();\n        final double size2\u003do2.getSize();\n        return (size2 \u003c size1) ? -1 : ((o1 \u003d\u003d o2) ? 0 : +1);\n      }\n    }\n);\n    ordered.addAll(boundary);\n    tree\u003dnew BSPTree\u003cS\u003e();\n    insertCuts(tree,ordered);\n    tree.visit(new BSPTreeVisitor\u003cS\u003e(){\n      \n      public Order visitOrder(      final BSPTree\u003cS\u003e node){\n        return Order.PLUS_SUB_MINUS;\n      }\n      \n      public void visitInternalNode(      final BSPTree\u003cS\u003e node){\n      }\n      \n      public void visitLeafNode(      final BSPTree\u003cS\u003e node){\n        node.setAttribute((node \u003d\u003d node.getParent().getPlus()) ? Boolean.FALSE : Boolean.TRUE);\n      }\n    }\n);\n  }\n}",
    "begin_line": 90,
    "end_line": 136,
    "comment": "/** \n * Build a Region from a Boundary REPresentation (B-rep). \u003cp\u003eThe boundary is provided as a collection of  {@link SubHyperplane sub-hyperplanes}. Each sub-hyperplane has the interior part of the region on its minus side and the exterior on its plus side.\u003c/p\u003e \u003cp\u003eThe boundary elements can be in any order, and can form several non-connected sets (like for example polygons with holes or a set of disjoints polyhedrons considered as a whole). In fact, the elements do not even need to be connected together (their topological connections are not used here). However, if the boundary does not really separate an inside open from an outside open (open having here its topological meaning), then subsequent calls to the  {@link #checkPoint(Vector) checkPoint} method will not bemeaningful anymore.\u003c/p\u003e \u003cp\u003eIf the boundary is empty, the region will represent the whole space.\u003c/p\u003e\n * @param boundary collection of boundary elements, as acollection of  {@link SubHyperplane SubHyperplane} objects\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.compare#103",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.compare(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e)",
    "snippet": "public int compare(final SubHyperplane\u003cS\u003e o1,final SubHyperplane\u003cS\u003e o2){\n  final double size1\u003do1.getSize();\n  final double size2\u003do2.getSize();\n  return (size2 \u003c size1) ? -1 : ((o1 \u003d\u003d o2) ? 0 : +1);\n}",
    "begin_line": 103,
    "end_line": 107,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.visitOrder#119",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.visitOrder(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public Order visitOrder(final BSPTree\u003cS\u003e node){\n  return Order.PLUS_SUB_MINUS;\n}",
    "begin_line": 119,
    "end_line": 121,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.visitInternalNode#124",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.visitInternalNode(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public void visitInternalNode(final BSPTree\u003cS\u003e node){\n}",
    "begin_line": 124,
    "end_line": 125,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.visitLeafNode#128",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.visitLeafNode(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public void visitLeafNode(final BSPTree\u003cS\u003e node){\n  node.setAttribute((node \u003d\u003d node.getParent().getPlus()) ? Boolean.FALSE : Boolean.TRUE);\n}",
    "begin_line": 128,
    "end_line": 131,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.AbstractRegion#142",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.AbstractRegion(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e[])",
    "snippet": "public AbstractRegion(final Hyperplane\u003cS\u003e[] hyperplanes){\n  if ((hyperplanes \u003d\u003d null) || (hyperplanes.length \u003d\u003d 0)) {\n    tree\u003dnew BSPTree\u003cS\u003e(Boolean.FALSE);\n  }\n else {\n    tree\u003dhyperplanes[0].wholeSpace().getTree(false);\n    BSPTree\u003cS\u003e node\u003dtree;\n    node.setAttribute(Boolean.TRUE);\n    for (    final Hyperplane\u003cS\u003e hyperplane : hyperplanes) {\n      if (node.insertCut(hyperplane)) {\n        node.setAttribute(null);\n        node.getPlus().setAttribute(Boolean.FALSE);\n        node\u003dnode.getMinus();\n        node.setAttribute(Boolean.TRUE);\n      }\n    }\n  }\n}",
    "begin_line": 142,
    "end_line": 164,
    "comment": "/** \n * Build a convex region from an array of bounding hyperplanes.\n * @param hyperplanes array of bounding hyperplanes (if null, anempty region will be built)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.buildNew#167",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.buildNew(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public abstract AbstractRegion\u003cS,T\u003e buildNew(BSPTree\u003cS\u003e newTree);",
    "begin_line": 167,
    "end_line": 167,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.insertCuts#175",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.insertCuts(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, java.util.Collection\u003corg.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e\u003e)",
    "snippet": "private void insertCuts(final BSPTree\u003cS\u003e node,final Collection\u003cSubHyperplane\u003cS\u003e\u003e boundary){\n  final Iterator\u003cSubHyperplane\u003cS\u003e\u003e iterator\u003dboundary.iterator();\n  Hyperplane\u003cS\u003e inserted\u003dnull;\n  while ((inserted \u003d\u003d null) \u0026\u0026 iterator.hasNext()) {\n    inserted\u003diterator.next().getHyperplane();\n    if (!node.insertCut(inserted.copySelf())) {\n      inserted\u003dnull;\n    }\n  }\n  if (!iterator.hasNext()) {\n    return;\n  }\n  final ArrayList\u003cSubHyperplane\u003cS\u003e\u003e plusList\u003dnew ArrayList\u003cSubHyperplane\u003cS\u003e\u003e();\n  final ArrayList\u003cSubHyperplane\u003cS\u003e\u003e minusList\u003dnew ArrayList\u003cSubHyperplane\u003cS\u003e\u003e();\n  while (iterator.hasNext()) {\n    final SubHyperplane\u003cS\u003e other\u003diterator.next();\nswitch (other.side(inserted)) {\ncase PLUS:      plusList.add(other);\n    break;\ncase MINUS:  minusList.add(other);\nbreak;\ncase BOTH:final SubHyperplane.SplitSubHyperplane\u003cS\u003e split\u003dother.split(inserted);\nplusList.add(split.getPlus());\nminusList.add(split.getMinus());\nbreak;\ndefault:}\n}\ninsertCuts(node.getPlus(),plusList);\ninsertCuts(node.getMinus(),minusList);\n}",
    "begin_line": 175,
    "end_line": 218,
    "comment": "/** \n * Recursively build a tree by inserting cut sub-hyperplanes.\n * @param node current tree node (it is a leaf node at the beginningof the call)\n * @param boundary collection of edges belonging to the cell definedby the node\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.copySelf#221",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.copySelf()",
    "snippet": "public AbstractRegion\u003cS,T\u003e copySelf(){\n  return buildNew(tree.copySelf());\n}",
    "begin_line": 221,
    "end_line": 223,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.isEmpty#226",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.isEmpty()",
    "snippet": "public boolean isEmpty(){\n  return isEmpty(tree);\n}",
    "begin_line": 226,
    "end_line": 228,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.isEmpty#231",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.isEmpty(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public boolean isEmpty(final BSPTree\u003cS\u003e node){\n  if (node.getCut() \u003d\u003d null) {\n    return !((Boolean)node.getAttribute());\n  }\n  return isEmpty(node.getMinus()) \u0026\u0026 isEmpty(node.getPlus());\n}",
    "begin_line": 231,
    "end_line": 245,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.contains#248",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.contains(org.apache.commons.math3.geometry.partitioning.Region\u003cS\u003e)",
    "snippet": "public boolean contains(final Region\u003cS\u003e region){\n  return new RegionFactory\u003cS\u003e().difference(region,this).isEmpty();\n}",
    "begin_line": 248,
    "end_line": 250,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.checkPoint#253",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.checkPoint(org.apache.commons.math3.geometry.Vector\u003cS\u003e)",
    "snippet": "public Location checkPoint(final Vector\u003cS\u003e point){\n  return checkPoint(tree,point);\n}",
    "begin_line": 253,
    "end_line": 255,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.checkPoint#264",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.checkPoint(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.Vector\u003cS\u003e)",
    "snippet": "protected Location checkPoint(final BSPTree\u003cS\u003e node,final Vector\u003cS\u003e point){\n  final BSPTree\u003cS\u003e cell\u003dnode.getCell(point);\n  if (cell.getCut() \u003d\u003d null) {\n    return ((Boolean)cell.getAttribute()) ? Location.INSIDE : Location.OUTSIDE;\n  }\n  final Location minusCode\u003dcheckPoint(cell.getMinus(),point);\n  final Location plusCode\u003dcheckPoint(cell.getPlus(),point);\n  return (minusCode \u003d\u003d plusCode) ? minusCode : Location.BOUNDARY;\n}",
    "begin_line": 264,
    "end_line": 276,
    "comment": "/** \n * Check a point with respect to the region starting at a given node.\n * @param node root node of the region\n * @param point point to check\n * @return a code representing the point status: either {@link Region.Location#INSIDE INSIDE},  {@link Region.Location#OUTSIDE OUTSIDE} or {@link Region.Location#BOUNDARY BOUNDARY}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractRegion.getTree#279",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getTree(boolean)",
    "snippet": "public BSPTree\u003cS\u003e getTree(final boolean includeBoundaryAttributes){\n  if (includeBoundaryAttributes \u0026\u0026 (tree.getCut() !\u003d null) \u0026\u0026 (tree.getAttribute() \u003d\u003d null)) {\n    tree.visit(new BoundaryBuilder\u003cS\u003e());\n  }\n  return tree;\n}",
    "begin_line": 279,
    "end_line": 285,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.visitOrder#296",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.visitOrder(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public Order visitOrder(BSPTree\u003cS\u003e node){\n  return Order.PLUS_MINUS_SUB;\n}",
    "begin_line": 296,
    "end_line": 298,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.visitInternalNode#301",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.visitInternalNode(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public void visitInternalNode(BSPTree\u003cS\u003e node){\n  SubHyperplane\u003cS\u003e plusOutside\u003dnull;\n  SubHyperplane\u003cS\u003e plusInside\u003dnull;\n  @SuppressWarnings(\"unchecked\") final SubHyperplane\u003cS\u003e[] plusChar\u003d(SubHyperplane\u003cS\u003e[])Array.newInstance(SubHyperplane.class,2);\n  characterize(node.getPlus(),node.getCut().copySelf(),plusChar);\n  if (plusChar[0] !\u003d null \u0026\u0026 !plusChar[0].isEmpty()) {\n    @SuppressWarnings(\"unchecked\") final SubHyperplane\u003cS\u003e[] minusChar\u003d(SubHyperplane\u003cS\u003e[])Array.newInstance(SubHyperplane.class,2);\n    characterize(node.getMinus(),plusChar[0],minusChar);\n    if (minusChar[1] !\u003d null \u0026\u0026 !minusChar[1].isEmpty()) {\n      plusOutside\u003dminusChar[1];\n    }\n  }\n  if (plusChar[1] !\u003d null \u0026\u0026 !plusChar[1].isEmpty()) {\n    @SuppressWarnings(\"unchecked\") final SubHyperplane\u003cS\u003e[] minusChar\u003d(SubHyperplane\u003cS\u003e[])Array.newInstance(SubHyperplane.class,2);\n    characterize(node.getMinus(),plusChar[1],minusChar);\n    if (minusChar[0] !\u003d null \u0026\u0026 !minusChar[0].isEmpty()) {\n      plusInside\u003dminusChar[0];\n    }\n  }\n  node.setAttribute(new BoundaryAttribute\u003cS\u003e(plusOutside,plusInside));\n}",
    "begin_line": 301,
    "end_line": 343,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.visitLeafNode#346",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.visitLeafNode(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e)",
    "snippet": "public void visitLeafNode(BSPTree\u003cS\u003e node){\n}",
    "begin_line": 346,
    "end_line": 347,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.characterize#362",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.characterize(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e[])",
    "snippet": "private void characterize(final BSPTree\u003cS\u003e node,final SubHyperplane\u003cS\u003e sub,final SubHyperplane\u003cS\u003e[] characterization){\n  if (node.getCut() \u003d\u003d null) {\n    final boolean inside\u003d(Boolean)node.getAttribute();\n    if (inside) {\n      if (characterization[1] \u003d\u003d null) {\n        characterization[1]\u003dsub;\n      }\n else {\n        characterization[1]\u003dcharacterization[1].reunite(sub);\n      }\n    }\n else {\n      if (characterization[0] \u003d\u003d null) {\n        characterization[0]\u003dsub;\n      }\n else {\n        characterization[0]\u003dcharacterization[0].reunite(sub);\n      }\n    }\n  }\n else {\n    final Hyperplane\u003cS\u003e hyperplane\u003dnode.getCut().getHyperplane();\nswitch (sub.side(hyperplane)) {\ncase PLUS:      characterize(node.getPlus(),sub,characterization);\n    break;\ncase MINUS:  characterize(node.getMinus(),sub,characterization);\nbreak;\ncase BOTH:final SubHyperplane.SplitSubHyperplane\u003cS\u003e split\u003dsub.split(hyperplane);\ncharacterize(node.getPlus(),split.getPlus(),characterization);\ncharacterize(node.getMinus(),split.getMinus(),characterization);\nbreak;\ndefault:throw new MathInternalError();\n}\n}\n}",
    "begin_line": 362,
    "end_line": 399,
    "comment": "/** \n * Filter the parts of an hyperplane belonging to the boundary. \u003cp\u003eThe filtering consist in splitting the specified sub-hyperplane into several parts lying in inside and outside cells of the tree. The principle is to call this method twice for each cut sub-hyperplane in the tree, once one the plus node and once on the minus node. The parts that have the same flag (inside/inside or outside/outside) do not belong to the boundary while parts that have different flags (inside/outside or outside/inside) do belong to the boundary.\u003c/p\u003e\n * @param node current BSP tree node\n * @param sub sub-hyperplane to characterize\n * @param characterization placeholder where to put the characterized parts\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.getBoundarySize#404",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getBoundarySize()",
    "snippet": "public double getBoundarySize(){\n  final BoundarySizeVisitor\u003cS\u003e visitor\u003dnew BoundarySizeVisitor\u003cS\u003e();\n  getTree(true).visit(visitor);\n  return visitor.getSize();\n}",
    "begin_line": 404,
    "end_line": 408,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.getSize#411",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getSize()",
    "snippet": "public double getSize(){\n  if (barycenter \u003d\u003d null) {\n    computeGeometricalProperties();\n  }\n  return size;\n}",
    "begin_line": 411,
    "end_line": 416,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.setSize#421",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.setSize(double)",
    "snippet": "protected void setSize(final double size){\n  this.size\u003dsize;\n}",
    "begin_line": 421,
    "end_line": 423,
    "comment": "/** \n * Set the size of the instance.\n * @param size size of the instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.getBarycenter#426",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.getBarycenter()",
    "snippet": "public Vector\u003cS\u003e getBarycenter(){\n  if (barycenter \u003d\u003d null) {\n    computeGeometricalProperties();\n  }\n  return barycenter;\n}",
    "begin_line": 426,
    "end_line": 431,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.setBarycenter#436",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.setBarycenter(org.apache.commons.math3.geometry.Vector\u003cS\u003e)",
    "snippet": "protected void setBarycenter(final Vector\u003cS\u003e barycenter){\n  this.barycenter\u003dbarycenter;\n}",
    "begin_line": 436,
    "end_line": 438,
    "comment": "/** \n * Set the barycenter of the instance.\n * @param barycenter barycenter of the instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.computeGeometricalProperties#443",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.computeGeometricalProperties()",
    "snippet": "protected abstract void computeGeometricalProperties();",
    "begin_line": 443,
    "end_line": 443,
    "comment": "/** \n * Compute some geometrical properties. \u003cp\u003eThe properties to compute are the barycenter and the size.\u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.side#446",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.side(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e)",
    "snippet": "public Side side(final Hyperplane\u003cS\u003e hyperplane){\n  final Sides sides\u003dnew Sides();\n  recurseSides(tree,hyperplane.wholeHyperplane(),sides);\n  return sides.plusFound() ? (sides.minusFound() ? Side.BOTH : Side.PLUS) : (sides.minusFound() ? Side.MINUS : Side.HYPER);\n}",
    "begin_line": 446,
    "end_line": 452,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BoundaryBuilder.recurseSides#469",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.recurseSides(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.AbstractRegion.Sides)",
    "snippet": "private void recurseSides(final BSPTree\u003cS\u003e node,final SubHyperplane\u003cS\u003e sub,final Sides sides){\n  if (node.getCut() \u003d\u003d null) {\n    if ((Boolean)node.getAttribute()) {\n      sides.rememberPlusFound();\n      sides.rememberMinusFound();\n    }\n    return;\n  }\n  final Hyperplane\u003cS\u003e hyperplane\u003dnode.getCut().getHyperplane();\nswitch (sub.side(hyperplane)) {\ncase PLUS:    if (node.getCut().side(sub.getHyperplane()) \u003d\u003d Side.PLUS) {\n      if (!isEmpty(node.getMinus())) {\n        sides.rememberPlusFound();\n      }\n    }\n else {\n      if (!isEmpty(node.getMinus())) {\n        sides.rememberMinusFound();\n      }\n    }\n  if (!(sides.plusFound() \u0026\u0026 sides.minusFound())) {\n    recurseSides(node.getPlus(),sub,sides);\n  }\nbreak;\ncase MINUS:if (node.getCut().side(sub.getHyperplane()) \u003d\u003d Side.PLUS) {\nif (!isEmpty(node.getPlus())) {\n  sides.rememberPlusFound();\n}\n}\n else {\nif (!isEmpty(node.getPlus())) {\n  sides.rememberMinusFound();\n}\n}\nif (!(sides.plusFound() \u0026\u0026 sides.minusFound())) {\nrecurseSides(node.getMinus(),sub,sides);\n}\nbreak;\ncase BOTH:final SubHyperplane.SplitSubHyperplane\u003cS\u003e split\u003dsub.split(hyperplane);\nrecurseSides(node.getPlus(),split.getPlus(),sides);\nif (!(sides.plusFound() \u0026\u0026 sides.minusFound())) {\nrecurseSides(node.getMinus(),split.getMinus(),sides);\n}\nbreak;\ndefault:if (node.getCut().getHyperplane().sameOrientationAs(sub.getHyperplane())) {\nif ((node.getPlus().getCut() !\u003d null) || ((Boolean)node.getPlus().getAttribute())) {\nsides.rememberPlusFound();\n}\nif ((node.getMinus().getCut() !\u003d null) || ((Boolean)node.getMinus().getAttribute())) {\nsides.rememberMinusFound();\n}\n}\n else {\nif ((node.getPlus().getCut() !\u003d null) || ((Boolean)node.getPlus().getAttribute())) {\nsides.rememberMinusFound();\n}\nif ((node.getMinus().getCut() !\u003d null) || ((Boolean)node.getMinus().getAttribute())) {\nsides.rememberPlusFound();\n}\n}\n}\n}",
    "begin_line": 469,
    "end_line": 543,
    "comment": "/** \n * Search recursively for inside leaf nodes on each side of the given hyperplane. \u003cp\u003eThe algorithm used here is directly derived from the one described in section III (\u003ci\u003eBinary Partitioning of a BSP Tree\u003c/i\u003e) of the Bruce Naylor, John Amanatides and William Thibault paper \u003ca href\u003d\"http://www.cs.yorku.ca/~amana/research/bsptSetOp.pdf\"\u003eMerging BSP Trees Yields Polyhedral Set Operations\u003c/a\u003e Proc. Siggraph \u002790, Computer Graphics 24(4), August 1990, pp 115-124, published by the Association for Computing Machinery (ACM)..\u003c/p\u003e\n * @param node current BSP tree node\n * @param sub sub-hyperplane\n * @param sides object holding the sides found\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.Sides#556",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.Sides()",
    "snippet": "public Sides(){\n  plusFound\u003dfalse;\n  minusFound\u003dfalse;\n}",
    "begin_line": 556,
    "end_line": 559,
    "comment": "/** \n * Simple constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.rememberPlusFound#563",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.rememberPlusFound()",
    "snippet": "public void rememberPlusFound(){\n  plusFound\u003dtrue;\n}",
    "begin_line": 563,
    "end_line": 565,
    "comment": "/** \n * Remember the fact that inside leaf nodes have been found on the plus side.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.plusFound#570",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.plusFound()",
    "snippet": "public boolean plusFound(){\n  return plusFound;\n}",
    "begin_line": 570,
    "end_line": 572,
    "comment": "/** \n * Check if inside leaf nodes have been found on the plus side.\n * @return true if inside leaf nodes have been found on the plus side\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.rememberMinusFound#576",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.rememberMinusFound()",
    "snippet": "public void rememberMinusFound(){\n  minusFound\u003dtrue;\n}",
    "begin_line": 576,
    "end_line": 578,
    "comment": "/** \n * Remember the fact that inside leaf nodes have been found on the minus side.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.minusFound#583",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.minusFound()",
    "snippet": "public boolean minusFound(){\n  return minusFound;\n}",
    "begin_line": 583,
    "end_line": 585,
    "comment": "/** \n * Check if inside leaf nodes have been found on the minus side.\n * @return true if inside leaf nodes have been found on the minus side\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.intersection#590",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.intersection(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e)",
    "snippet": "public SubHyperplane\u003cS\u003e intersection(final SubHyperplane\u003cS\u003e sub){\n  return recurseIntersection(tree,sub);\n}",
    "begin_line": 590,
    "end_line": 592,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.recurseIntersection#600",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.recurseIntersection(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e)",
    "snippet": "private SubHyperplane\u003cS\u003e recurseIntersection(final BSPTree\u003cS\u003e node,final SubHyperplane\u003cS\u003e sub){\n  if (node.getCut() \u003d\u003d null) {\n    return (Boolean)node.getAttribute() ? sub.copySelf() : null;\n  }\n  final Hyperplane\u003cS\u003e hyperplane\u003dnode.getCut().getHyperplane();\nswitch (sub.side(hyperplane)) {\ncase PLUS:    return recurseIntersection(node.getPlus(),sub);\ncase MINUS:  return recurseIntersection(node.getMinus(),sub);\ncase BOTH:final SubHyperplane.SplitSubHyperplane\u003cS\u003e split\u003dsub.split(hyperplane);\nfinal SubHyperplane\u003cS\u003e plus\u003drecurseIntersection(node.getPlus(),split.getPlus());\nfinal SubHyperplane\u003cS\u003e minus\u003drecurseIntersection(node.getMinus(),split.getMinus());\nif (plus \u003d\u003d null) {\nreturn minus;\n}\n else if (minus \u003d\u003d null) {\nreturn plus;\n}\n else {\nreturn plus.reunite(minus);\n}\ndefault:return recurseIntersection(node.getPlus(),recurseIntersection(node.getMinus(),sub));\n}\n}",
    "begin_line": 600,
    "end_line": 628,
    "comment": "/** \n * Recursively compute the parts of a sub-hyperplane that are contained in the region.\n * @param node current BSP tree node\n * @param sub sub-hyperplane traversing the region\n * @return filtered sub-hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.applyTransform#640",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.applyTransform(org.apache.commons.math3.geometry.partitioning.Transform\u003cS,T\u003e)",
    "snippet": "public AbstractRegion\u003cS,T\u003e applyTransform(final Transform\u003cS,T\u003e transform){\n  return buildNew(recurseTransform(getTree(false),transform));\n}",
    "begin_line": 640,
    "end_line": 642,
    "comment": "/** \n * Transform a region. \u003cp\u003eApplying a transform to a region consist in applying the transform to all the hyperplanes of the underlying BSP tree and of the boundary (and also to the sub-hyperplanes embedded in these hyperplanes) and to the barycenter. The instance is not modified, a new instance is built.\u003c/p\u003e\n * @param transform transform to apply\n * @return a new region, resulting from the application of thetransform to the instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Sides.recurseTransform#650",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractRegion.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractRegion",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractRegion.recurseTransform(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.Transform\u003cS,T\u003e)",
    "snippet": "@SuppressWarnings(\"unchecked\") private BSPTree\u003cS\u003e recurseTransform(final BSPTree\u003cS\u003e node,final Transform\u003cS,T\u003e transform){\n  if (node.getCut() \u003d\u003d null) {\n    return new BSPTree\u003cS\u003e(node.getAttribute());\n  }\n  final SubHyperplane\u003cS\u003e sub\u003dnode.getCut();\n  final SubHyperplane\u003cS\u003e tSub\u003d((AbstractSubHyperplane\u003cS,T\u003e)sub).applyTransform(transform);\n  BoundaryAttribute\u003cS\u003e attribute\u003d(BoundaryAttribute\u003cS\u003e)node.getAttribute();\n  if (attribute !\u003d null) {\n    final SubHyperplane\u003cS\u003e tPO\u003d(attribute.getPlusOutside() \u003d\u003d null) ? null : ((AbstractSubHyperplane\u003cS,T\u003e)attribute.getPlusOutside()).applyTransform(transform);\n    final SubHyperplane\u003cS\u003e tPI\u003d(attribute.getPlusInside() \u003d\u003d null) ? null : ((AbstractSubHyperplane\u003cS,T\u003e)attribute.getPlusInside()).applyTransform(transform);\n    attribute\u003dnew BoundaryAttribute\u003cS\u003e(tPO,tPI);\n  }\n  return new BSPTree\u003cS\u003e(tSub,recurseTransform(node.getPlus(),transform),recurseTransform(node.getMinus(),transform),attribute);\n}",
    "begin_line": 650,
    "end_line": 672,
    "comment": "/** \n * Recursively transform an inside/outside BSP-tree.\n * @param node current BSP tree node\n * @param transform transform to apply\n * @return a new tree\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.AbstractSubHyperplane#49",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.AbstractSubHyperplane(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.Region\u003cT\u003e)",
    "snippet": "protected AbstractSubHyperplane(final Hyperplane\u003cS\u003e hyperplane,final Region\u003cT\u003e remainingRegion){\n  this.hyperplane\u003dhyperplane;\n  this.remainingRegion\u003dremainingRegion;\n}",
    "begin_line": 49,
    "end_line": 53,
    "comment": "/** \n * Build a sub-hyperplane from an hyperplane and a region.\n * @param hyperplane underlying hyperplane\n * @param remainingRegion remaining region of the hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.buildNew#60",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.buildNew(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.Region\u003cT\u003e)",
    "snippet": "protected abstract AbstractSubHyperplane\u003cS,T\u003e buildNew(final Hyperplane\u003cS\u003e hyper,final Region\u003cT\u003e remaining);",
    "begin_line": 60,
    "end_line": 61,
    "comment": "/** \n * Build a sub-hyperplane from an hyperplane and a region.\n * @param hyper underlying hyperplane\n * @param remaining remaining region of the hyperplane\n * @return a new sub-hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.copySelf#64",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.copySelf()",
    "snippet": "public AbstractSubHyperplane\u003cS,T\u003e copySelf(){\n  return buildNew(hyperplane,remainingRegion);\n}",
    "begin_line": 64,
    "end_line": 66,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.getHyperplane#71",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getHyperplane()",
    "snippet": "public Hyperplane\u003cS\u003e getHyperplane(){\n  return hyperplane;\n}",
    "begin_line": 71,
    "end_line": 73,
    "comment": "/** \n * Get the underlying hyperplane.\n * @return underlying hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.getRemainingRegion#82",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getRemainingRegion()",
    "snippet": "public Region\u003cT\u003e getRemainingRegion(){\n  return remainingRegion;\n}",
    "begin_line": 82,
    "end_line": 84,
    "comment": "/** \n * Get the remaining region of the hyperplane. \u003cp\u003eThe returned region is expressed in the canonical hyperplane frame and has the hyperplane dimension. For example a chopped hyperplane in the 3D euclidean is a 2D plane and the corresponding region is a convex 2D polygon.\u003c/p\u003e\n * @return remaining region of the hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.getSize#87",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.getSize()",
    "snippet": "public double getSize(){\n  return remainingRegion.getSize();\n}",
    "begin_line": 87,
    "end_line": 89,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.reunite#92",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.reunite(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e)",
    "snippet": "public AbstractSubHyperplane\u003cS,T\u003e reunite(final SubHyperplane\u003cS\u003e other){\n  @SuppressWarnings(\"unchecked\") AbstractSubHyperplane\u003cS,T\u003e o\u003d(AbstractSubHyperplane\u003cS,T\u003e)other;\n  return buildNew(hyperplane,new RegionFactory\u003cT\u003e().union(remainingRegion,o.remainingRegion));\n}",
    "begin_line": 92,
    "end_line": 97,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.applyTransform#109",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.applyTransform(org.apache.commons.math3.geometry.partitioning.Transform\u003cS,T\u003e)",
    "snippet": "public AbstractSubHyperplane\u003cS,T\u003e applyTransform(final Transform\u003cS,T\u003e transform){\n  final Hyperplane\u003cS\u003e tHyperplane\u003dtransform.apply(hyperplane);\n  final BSPTree\u003cT\u003e tTree\u003drecurseTransform(remainingRegion.getTree(false),tHyperplane,transform);\n  return buildNew(tHyperplane,remainingRegion.buildNew(tTree));\n}",
    "begin_line": 109,
    "end_line": 114,
    "comment": "/** \n * Apply a transform to the instance. \u003cp\u003eThe instance must be a (D-1)-dimension sub-hyperplane with respect to the transform \u003cem\u003enot\u003c/em\u003e a (D-2)-dimension sub-hyperplane the transform knows how to transform by itself. The transform will consist in transforming first the hyperplane and then the all region using the various methods provided by the transform.\u003c/p\u003e\n * @param transform D-dimension transform to apply\n * @return the transformed instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.recurseTransform#122",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.recurseTransform(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cT\u003e, org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.Transform\u003cS,T\u003e)",
    "snippet": "private BSPTree\u003cT\u003e recurseTransform(final BSPTree\u003cT\u003e node,final Hyperplane\u003cS\u003e transformed,final Transform\u003cS,T\u003e transform){\n  if (node.getCut() \u003d\u003d null) {\n    return new BSPTree\u003cT\u003e(node.getAttribute());\n  }\n  @SuppressWarnings(\"unchecked\") BoundaryAttribute\u003cT\u003e attribute\u003d(BoundaryAttribute\u003cT\u003e)node.getAttribute();\n  if (attribute !\u003d null) {\n    final SubHyperplane\u003cT\u003e tPO\u003d(attribute.getPlusOutside() \u003d\u003d null) ? null : transform.apply(attribute.getPlusOutside(),hyperplane,transformed);\n    final SubHyperplane\u003cT\u003e tPI\u003d(attribute.getPlusInside() \u003d\u003d null) ? null : transform.apply(attribute.getPlusInside(),hyperplane,transformed);\n    attribute\u003dnew BoundaryAttribute\u003cT\u003e(tPO,tPI);\n  }\n  return new BSPTree\u003cT\u003e(transform.apply(node.getCut(),hyperplane,transformed),recurseTransform(node.getPlus(),transformed,transform),recurseTransform(node.getMinus(),transformed,transform),attribute);\n}",
    "begin_line": 122,
    "end_line": 145,
    "comment": "/** \n * Recursively transform a BSP-tree from a sub-hyperplane.\n * @param node current BSP tree node\n * @param transformed image of the instance hyperplane by the transform\n * @param transform transform to apply\n * @return a new tree\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.side#148",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.side(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e)",
    "snippet": "public abstract Side side(Hyperplane\u003cS\u003e hyper);",
    "begin_line": 148,
    "end_line": 148,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.split#151",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.split(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e)",
    "snippet": "public abstract SplitSubHyperplane\u003cS\u003e split(Hyperplane\u003cS\u003e hyper);",
    "begin_line": 151,
    "end_line": 151,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "AbstractSubHyperplane.isEmpty#154",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/AbstractSubHyperplane.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane",
    "signature": "org.apache.commons.math3.geometry.partitioning.AbstractSubHyperplane.isEmpty()",
    "snippet": "public boolean isEmpty(){\n  return remainingRegion.isEmpty();\n}",
    "begin_line": 154,
    "end_line": 156,
    "comment": "/** \n * {@inheritDoc} \n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.BSPTree#82",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree()",
    "snippet": "public BSPTree(){\n  cut\u003dnull;\n  plus\u003dnull;\n  minus\u003dnull;\n  parent\u003dnull;\n  attribute\u003dnull;\n}",
    "begin_line": 82,
    "end_line": 88,
    "comment": "/** \n * Build a tree having only one root cell representing the whole space.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.BSPTree#93",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree(java.lang.Object)",
    "snippet": "public BSPTree(final Object attribute){\n  cut\u003dnull;\n  plus\u003dnull;\n  minus\u003dnull;\n  parent\u003dnull;\n  this.attribute\u003dattribute;\n}",
    "begin_line": 93,
    "end_line": 99,
    "comment": "/** \n * Build a tree having only one root cell representing the whole space.\n * @param attribute attribute of the tree (may be null)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.BSPTree#114",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.BSPTree(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, java.lang.Object)",
    "snippet": "public BSPTree(final SubHyperplane\u003cS\u003e cut,final BSPTree\u003cS\u003e plus,final BSPTree\u003cS\u003e minus,final Object attribute){\n  this.cut\u003dcut;\n  this.plus\u003dplus;\n  this.minus\u003dminus;\n  this.parent\u003dnull;\n  this.attribute\u003dattribute;\n  plus.parent\u003dthis;\n  minus.parent\u003dthis;\n}",
    "begin_line": 114,
    "end_line": 123,
    "comment": "/** \n * Build a BSPTree from its underlying elements. \u003cp\u003eThis method does \u003cem\u003enot\u003c/em\u003e perform any verification on consistency of its arguments, it should therefore be used only when then caller knows what it is doing.\u003c/p\u003e \u003cp\u003eThis method is mainly useful kto build trees bottom-up. Building trees top-down is realized with the help of method  {@link #insertCut insertCut}.\u003c/p\u003e\n * @param cut cut sub-hyperplane for the tree\n * @param plus plus side sub-tree\n * @param minus minus side sub-tree\n * @param attribute attribute associated with the node (may be null)\n * @see #insertCut\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.insertCut#148",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.insertCut(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e)",
    "snippet": "public boolean insertCut(final Hyperplane\u003cS\u003e hyperplane){\n  if (cut !\u003d null) {\n    plus.parent\u003dnull;\n    minus.parent\u003dnull;\n  }\n  final SubHyperplane\u003cS\u003e chopped\u003dfitToCell(hyperplane.wholeHyperplane());\n  if (chopped \u003d\u003d null || chopped.isEmpty()) {\n    cut\u003dnull;\n    plus\u003dnull;\n    minus\u003dnull;\n    return false;\n  }\n  cut\u003dchopped;\n  plus\u003dnew BSPTree\u003cS\u003e();\n  plus.parent\u003dthis;\n  minus\u003dnew BSPTree\u003cS\u003e();\n  minus.parent\u003dthis;\n  return true;\n}",
    "begin_line": 148,
    "end_line": 170,
    "comment": "/** \n * Insert a cut sub-hyperplane in a node. \u003cp\u003eThe sub-tree starting at this node will be completely overwritten. The new cut sub-hyperplane will be built from the intersection of the provided hyperplane with the cell. If the hyperplane does intersect the cell, the cell will have two children cells with  {@code null} attributes on each side ofthe inserted cut sub-hyperplane. If the hyperplane does not intersect the cell then \u003cem\u003eno\u003c/em\u003e cut hyperplane will be inserted and the cell will be changed to a leaf cell. The attribute of the node is never changed.\u003c/p\u003e \u003cp\u003eThis method is mainly useful when called on leaf nodes (i.e. nodes for which  {@link #getCut getCut} returns{@code null}), in this case it provides a way to build a tree top-down (whereas the  {@link #BSPTree(SubHyperplane,BSPTree,BSPTree,Object) 4 arguments constructor} is devoted tobuild trees bottom-up).\u003c/p\u003e\n * @param hyperplane hyperplane to insert, it will be chopped inorder to fit in the cell defined by the parent nodes of the instance\n * @return true if a cut sub-hyperplane has been inserted (i.e. ifthe cell now has two leaf child nodes)\n * @see #BSPTree(SubHyperplane,BSPTree,BSPTree,Object)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.copySelf#179",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.copySelf()",
    "snippet": "public BSPTree\u003cS\u003e copySelf(){\n  if (cut \u003d\u003d null) {\n    return new BSPTree\u003cS\u003e(attribute);\n  }\n  return new BSPTree\u003cS\u003e(cut.copySelf(),plus.copySelf(),minus.copySelf(),attribute);\n}",
    "begin_line": 179,
    "end_line": 188,
    "comment": "/** \n * Copy the instance. \u003cp\u003eThe instance created is completely independant of the original one. A deep copy is used, none of the underlying objects are shared (except for the nodes attributes and immutable objects).\u003c/p\u003e\n * @return a new tree, copy of the instance\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.getCut#193",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getCut()",
    "snippet": "public SubHyperplane\u003cS\u003e getCut(){\n  return cut;\n}",
    "begin_line": 193,
    "end_line": 195,
    "comment": "/** \n * Get the cut sub-hyperplane.\n * @return cut sub-hyperplane, null if this is a leaf tree\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.getPlus#201",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getPlus()",
    "snippet": "public BSPTree\u003cS\u003e getPlus(){\n  return plus;\n}",
    "begin_line": 201,
    "end_line": 203,
    "comment": "/** \n * Get the tree on the plus side of the cut hyperplane.\n * @return tree on the plus side of the cut hyperplane, null if thisis a leaf tree\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.getMinus#209",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getMinus()",
    "snippet": "public BSPTree\u003cS\u003e getMinus(){\n  return minus;\n}",
    "begin_line": 209,
    "end_line": 211,
    "comment": "/** \n * Get the tree on the minus side of the cut hyperplane.\n * @return tree on the minus side of the cut hyperplane, null if thisis a leaf tree\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.getParent#216",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getParent()",
    "snippet": "public BSPTree\u003cS\u003e getParent(){\n  return parent;\n}",
    "begin_line": 216,
    "end_line": 218,
    "comment": "/** \n * Get the parent node.\n * @return parent node, null if the node has no parents\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.setAttribute#224",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.setAttribute(java.lang.Object)",
    "snippet": "public void setAttribute(final Object attribute){\n  this.attribute\u003dattribute;\n}",
    "begin_line": 224,
    "end_line": 226,
    "comment": "/** \n * Associate an attribute with the instance.\n * @param attribute attribute to associate with the node\n * @see #getAttribute\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.getAttribute#234",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getAttribute()",
    "snippet": "public Object getAttribute(){\n  return attribute;\n}",
    "begin_line": 234,
    "end_line": 236,
    "comment": "/** \n * Get the attribute associated with the instance.\n * @return attribute associated with the node or null if noattribute has been explicitly set using the  {@link #setAttribute setAttribute} method\n * @see #setAttribute\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.visit#241",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.visit(org.apache.commons.math3.geometry.partitioning.BSPTreeVisitor\u003cS\u003e)",
    "snippet": "public void visit(final BSPTreeVisitor\u003cS\u003e visitor){\n  if (cut \u003d\u003d null) {\n    visitor.visitLeafNode(this);\n  }\n else {\nswitch (visitor.visitOrder(this)) {\ncase PLUS_MINUS_SUB:      plus.visit(visitor);\n    minus.visit(visitor);\n  visitor.visitInternalNode(this);\nbreak;\ncase PLUS_SUB_MINUS:plus.visit(visitor);\nvisitor.visitInternalNode(this);\nminus.visit(visitor);\nbreak;\ncase MINUS_PLUS_SUB:minus.visit(visitor);\nplus.visit(visitor);\nvisitor.visitInternalNode(this);\nbreak;\ncase MINUS_SUB_PLUS:minus.visit(visitor);\nvisitor.visitInternalNode(this);\nplus.visit(visitor);\nbreak;\ncase SUB_PLUS_MINUS:visitor.visitInternalNode(this);\nplus.visit(visitor);\nminus.visit(visitor);\nbreak;\ncase SUB_MINUS_PLUS:visitor.visitInternalNode(this);\nminus.visit(visitor);\nplus.visit(visitor);\nbreak;\ndefault:throw new MathInternalError();\n}\n}\n}",
    "begin_line": 241,
    "end_line": 281,
    "comment": "/** \n * Visit the BSP tree nodes.\n * @param visitor object visiting the tree nodes\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.fitToCell#291",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.fitToCell(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e)",
    "snippet": "private SubHyperplane\u003cS\u003e fitToCell(final SubHyperplane\u003cS\u003e sub){\n  SubHyperplane\u003cS\u003e s\u003dsub;\n  for (BSPTree\u003cS\u003e tree\u003dthis; tree.parent !\u003d null; tree\u003dtree.parent) {\n    if (tree \u003d\u003d tree.parent.plus) {\n      s\u003ds.split(tree.parent.cut.getHyperplane()).getPlus();\n    }\n else {\n      s\u003ds.split(tree.parent.cut.getHyperplane()).getMinus();\n    }\n  }\n  return s;\n}",
    "begin_line": 291,
    "end_line": 301,
    "comment": "/** \n * Fit a sub-hyperplane inside the cell defined by the instance. \u003cp\u003eFitting is done by chopping off the parts of the sub-hyperplane that lie outside of the cell using the cut-hyperplanes of the parent nodes of the instance.\u003c/p\u003e\n * @param sub sub-hyperplane to fit\n * @return a new sub-hyperplane, guaranteed to have no part outsideof the instance cell\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.getCell#310",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.getCell(org.apache.commons.math3.geometry.Vector\u003cS\u003e)",
    "snippet": "public BSPTree\u003cS\u003e getCell(final Vector\u003cS\u003e point){\n  if (cut \u003d\u003d null) {\n    return this;\n  }\n  final double offset\u003dcut.getHyperplane().getOffset(point);\n  if (FastMath.abs(offset) \u003c 1.0e-10) {\n    return this;\n  }\n else   if (offset \u003c\u003d 0) {\n    return minus.getCell(point);\n  }\n else {\n    return plus.getCell(point);\n  }\n}",
    "begin_line": 310,
    "end_line": 329,
    "comment": "/** \n * Get the cell to which a point belongs. \u003cp\u003eIf the returned cell is a leaf node the points belongs to the interior of the node, if the cell is an internal node the points belongs to the node cut sub-hyperplane.\u003c/p\u003e\n * @param point point to check\n * @return the tree cell to which the point belongs (can be\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.condense#335",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.condense()",
    "snippet": "private void condense(){\n  if ((cut !\u003d null) \u0026\u0026 (plus.cut \u003d\u003d null) \u0026\u0026 (minus.cut \u003d\u003d null)\u0026\u0026 (((plus.attribute \u003d\u003d null) \u0026\u0026 (minus.attribute \u003d\u003d null)) || ((plus.attribute !\u003d null) \u0026\u0026 plus.attribute.equals(minus.attribute)))) {\n    attribute\u003d(plus.attribute \u003d\u003d null) ? minus.attribute : plus.attribute;\n    cut\u003dnull;\n    plus\u003dnull;\n    minus\u003dnull;\n  }\n}",
    "begin_line": 335,
    "end_line": 344,
    "comment": "/** \n * Perform condensation on a tree. \u003cp\u003eThe condensation operation is not recursive, it must be called explicitely from leaves to root.\u003c/p\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.merge#364",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.merge(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree.LeafMerger\u003cS\u003e)",
    "snippet": "public BSPTree\u003cS\u003e merge(final BSPTree\u003cS\u003e tree,final LeafMerger\u003cS\u003e leafMerger){\n  return merge(tree,leafMerger,null,false);\n}",
    "begin_line": 364,
    "end_line": 366,
    "comment": "/** \n * Merge a BSP tree with the instance. \u003cp\u003eAll trees are modified (parts of them are reused in the new tree), it is the responsibility of the caller to ensure a copy has been done before if any of the former tree should be preserved, \u003cem\u003eno\u003c/em\u003e such copy is done here!\u003c/p\u003e \u003cp\u003eThe algorithm used here is directly derived from the one described in the Naylor, Amanatides and Thibault paper (section III, Binary Partitioning of a BSP Tree).\u003c/p\u003e\n * @param tree other tree to merge with the instance (will be\u003cem\u003eunusable\u003c/em\u003e after the operation, as well as the instance itself)\n * @param leafMerger object implementing the final merging phase(this is where the semantic of the operation occurs, generally depending on the attribute of the leaf node)\n * @return a new tree, result of \u003ccode\u003einstance \u0026lt;op\u0026gt;tree\u003c/code\u003e, this value can be ignored if parentTree is not null since all connections have already been established\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "BSPTree.merge#383",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.merge(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree.LeafMerger\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, boolean)",
    "snippet": "private BSPTree\u003cS\u003e merge(final BSPTree\u003cS\u003e tree,final LeafMerger\u003cS\u003e leafMerger,final BSPTree\u003cS\u003e parentTree,final boolean isPlusChild){\n  if (cut \u003d\u003d null) {\n    return leafMerger.merge(this,tree,parentTree,isPlusChild,true);\n  }\n else   if (tree.cut \u003d\u003d null) {\n    return leafMerger.merge(tree,this,parentTree,isPlusChild,false);\n  }\n else {\n    final BSPTree\u003cS\u003e merged\u003dtree.split(cut);\n    if (parentTree !\u003d null) {\n      merged.parent\u003dparentTree;\n      if (isPlusChild) {\n        parentTree.plus\u003dmerged;\n      }\n else {\n        parentTree.minus\u003dmerged;\n      }\n    }\n    plus.merge(merged.plus,leafMerger,merged,true);\n    minus.merge(merged.minus,leafMerger,merged,false);\n    merged.condense();\n    if (merged.cut !\u003d null) {\n      merged.cut\u003dmerged.fitToCell(merged.cut.getHyperplane().wholeHyperplane());\n    }\n    return merged;\n  }\n}",
    "begin_line": 383,
    "end_line": 415,
    "comment": "/** \n * Merge a BSP tree with the instance.\n * @param tree other tree to merge with the instance (will be\u003cem\u003eunusable\u003c/em\u003e after the operation, as well as the instance itself)\n * @param leafMerger object implementing the final merging phase(this is where the semantic of the operation occurs, generally depending on the attribute of the leaf node)\n * @param parentTree parent tree to connect to (may be null)\n * @param isPlusChild if true and if parentTree is not null, theresulting tree should be the plus child of its parent, ignored if parentTree is null\n * @return a new tree, result of \u003ccode\u003einstance \u0026lt;op\u0026gt;tree\u003c/code\u003e, this value can be ignored if parentTree is not null since all connections have already been established\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LeafMerger.merge#464",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.merge(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, boolean, boolean)",
    "snippet": "BSPTree\u003cS\u003e merge(BSPTree\u003cS\u003e leaf,BSPTree\u003cS\u003e tree,BSPTree\u003cS\u003e parentTree,boolean isPlusChild,boolean leafFromInstance);",
    "begin_line": 464,
    "end_line": 465,
    "comment": "/** \n * Merge a leaf node and a tree node. \u003cp\u003eThis method is called at the end of a recursive merging resulting from a  {@code tree1.merge(tree2, leafMerger)}call, when one of the sub-trees involved is a leaf (i.e. when its cut-hyperplane is null). This is the only place where the precise semantics of the operation are required. For all upper level nodes in the tree, the merging operation is only a generic partitioning algorithm.\u003c/p\u003e \u003cp\u003eSince the final operation may be non-commutative, it is important to know if the leaf node comes from the instance tree ( {@code tree1}) or the argument tree ( {@code tree2}). The third argument of the method is devoted to this. It can be ignored for commutative operations.\u003c/p\u003e \u003cp\u003eThe  {@link BSPTree#insertInTree BSPTree.insertInTree} methodmay be useful to implement this method.\u003c/p\u003e\n * @param leaf leaf node (its cut hyperplane is guaranteed to benull)\n * @param tree tree node (its cut hyperplane may be null or not)\n * @param parentTree parent tree to connect to (may be null)\n * @param isPlusChild if true and if parentTree is not null, theresulting tree should be the plus child of its parent, ignored if parentTree is null\n * @param leafFromInstance if true, the leaf node comes from theinstance tree ( {@code tree1}) and the tree node comes from the argument tree ( {@code tree2})\n * @return the BSP tree resulting from the merging (may be one ofthe arguments)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LeafMerger.split#487",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.split(org.apache.commons.math3.geometry.partitioning.SubHyperplane\u003cS\u003e)",
    "snippet": "public BSPTree\u003cS\u003e split(final SubHyperplane\u003cS\u003e sub){\n  if (cut \u003d\u003d null) {\n    return new BSPTree\u003cS\u003e(sub,copySelf(),new BSPTree\u003cS\u003e(attribute),null);\n  }\n  final Hyperplane\u003cS\u003e cHyperplane\u003dcut.getHyperplane();\n  final Hyperplane\u003cS\u003e sHyperplane\u003dsub.getHyperplane();\nswitch (sub.side(cHyperplane)) {\ncase PLUS:{\n      final BSPTree\u003cS\u003e split\u003dplus.split(sub);\n      if (cut.side(sHyperplane) \u003d\u003d Side.PLUS) {\n        split.plus\u003dnew BSPTree\u003cS\u003e(cut.copySelf(),split.plus,minus.copySelf(),attribute);\n        split.plus.condense();\n        split.plus.parent\u003dsplit;\n      }\n else {\n        split.minus\u003dnew BSPTree\u003cS\u003e(cut.copySelf(),split.minus,minus.copySelf(),attribute);\n        split.minus.condense();\n        split.minus.parent\u003dsplit;\n      }\n      return split;\n    }\ncase MINUS:{\n    final BSPTree\u003cS\u003e split\u003dminus.split(sub);\n    if (cut.side(sHyperplane) \u003d\u003d Side.PLUS) {\n      split.plus\u003dnew BSPTree\u003cS\u003e(cut.copySelf(),plus.copySelf(),split.plus,attribute);\n      split.plus.condense();\n      split.plus.parent\u003dsplit;\n    }\n else {\n      split.minus\u003dnew BSPTree\u003cS\u003e(cut.copySelf(),plus.copySelf(),split.minus,attribute);\n      split.minus.condense();\n      split.minus.parent\u003dsplit;\n    }\n    return split;\n  }\ncase BOTH:{\n  final SubHyperplane.SplitSubHyperplane\u003cS\u003e cutParts\u003dcut.split(sHyperplane);\n  final SubHyperplane.SplitSubHyperplane\u003cS\u003e subParts\u003dsub.split(cHyperplane);\n  final BSPTree\u003cS\u003e split\u003dnew BSPTree\u003cS\u003e(sub,plus.split(subParts.getPlus()),minus.split(subParts.getMinus()),null);\n  split.plus.cut\u003dcutParts.getPlus();\n  split.minus.cut\u003dcutParts.getMinus();\n  final BSPTree\u003cS\u003e tmp\u003dsplit.plus.minus;\n  split.plus.minus\u003dsplit.minus.plus;\n  split.plus.minus.parent\u003dsplit.plus;\n  split.minus.plus\u003dtmp;\n  split.minus.plus.parent\u003dsplit.minus;\n  split.plus.condense();\n  split.minus.condense();\n  return split;\n}\ndefault:return cHyperplane.sameOrientationAs(sHyperplane) ? new BSPTree\u003cS\u003e(sub,plus.copySelf(),minus.copySelf(),attribute) : new BSPTree\u003cS\u003e(sub,minus.copySelf(),plus.copySelf(),attribute);\n}\n}",
    "begin_line": 487,
    "end_line": 553,
    "comment": "/** \n * Split a BSP tree by an external sub-hyperplane. \u003cp\u003eSplit a tree in two halves, on each side of the sub-hyperplane. The instance is not modified.\u003c/p\u003e \u003cp\u003eThe tree returned is not upward-consistent: despite all of its sub-trees cut sub-hyperplanes (including its own cut sub-hyperplane) are bounded to the current cell, it is \u003cem\u003enot\u003c/em\u003e attached to any parent tree yet. This tree is intended to be later inserted into an higher level tree.\u003c/p\u003e \u003cp\u003eThe algorithm used here is the one given in Naylor, Amanatides and Thibault paper (section III, Binary Partitioning of a BSP Tree).\u003c/p\u003e\n * @param sub partitioning sub-hyperplane, must be already clippedto the convex region represented by the instance, will be used as the cut sub-hyperplane of the returned tree\n * @return a tree having the specified sub-hyperplane as its cutsub-hyperplane, the two parts of the split instance as its two sub-trees and a null parent\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LeafMerger.insertInTree#564",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.insertInTree(org.apache.commons.math3.geometry.partitioning.BSPTree\u003cS\u003e, boolean)",
    "snippet": "public void insertInTree(final BSPTree\u003cS\u003e parentTree,final boolean isPlusChild){\n  parent\u003dparentTree;\n  if (parentTree !\u003d null) {\n    if (isPlusChild) {\n      parentTree.plus\u003dthis;\n    }\n else {\n      parentTree.minus\u003dthis;\n    }\n  }\n  if (cut !\u003d null) {\n    for (BSPTree\u003cS\u003e tree\u003dthis; tree.parent !\u003d null; tree\u003dtree.parent) {\n      final Hyperplane\u003cS\u003e hyperplane\u003dtree.parent.cut.getHyperplane();\n      if (tree \u003d\u003d tree.parent.plus) {\n        cut\u003dcut.split(hyperplane).getPlus();\n        plus.chopOffMinus(hyperplane);\n        minus.chopOffMinus(hyperplane);\n      }\n else {\n        cut\u003dcut.split(hyperplane).getMinus();\n        plus.chopOffPlus(hyperplane);\n        minus.chopOffPlus(hyperplane);\n      }\n    }\n    condense();\n  }\n}",
    "begin_line": 564,
    "end_line": 605,
    "comment": "/** \n * Insert the instance into another tree. \u003cp\u003eThe instance itself is modified so its former parent should not be used anymore.\u003c/p\u003e\n * @param parentTree parent tree to connect to (may be null)\n * @param isPlusChild if true and if parentTree is not null, theresulting tree should be the plus child of its parent, ignored if parentTree is null\n * @see LeafMerger\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LeafMerger.chopOffMinus#613",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.chopOffMinus(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e)",
    "snippet": "private void chopOffMinus(final Hyperplane\u003cS\u003e hyperplane){\n  if (cut !\u003d null) {\n    cut\u003dcut.split(hyperplane).getPlus();\n    plus.chopOffMinus(hyperplane);\n    minus.chopOffMinus(hyperplane);\n  }\n}",
    "begin_line": 613,
    "end_line": 619,
    "comment": "/** \n * Chop off parts of the tree. \u003cp\u003eThe instance is modified in place, all the parts that are on the minus side of the chopping hyperplane are discarded, only the parts on the plus side remain.\u003c/p\u003e\n * @param hyperplane chopping hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "LeafMerger.chopOffPlus#627",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/geometry/partitioning/BSPTree.java",
    "class_name": "org.apache.commons.math3.geometry.partitioning.BSPTree",
    "signature": "org.apache.commons.math3.geometry.partitioning.BSPTree.chopOffPlus(org.apache.commons.math3.geometry.partitioning.Hyperplane\u003cS\u003e)",
    "snippet": "private void chopOffPlus(final Hyperplane\u003cS\u003e hyperplane){\n  if (cut !\u003d null) {\n    cut\u003dcut.split(hyperplane).getMinus();\n    plus.chopOffPlus(hyperplane);\n    minus.chopOffPlus(hyperplane);\n  }\n}",
    "begin_line": 627,
    "end_line": 633,
    "comment": "/** \n * Chop off parts of the tree. \u003cp\u003eThe instance is modified in place, all the parts that are on the plus side of the chopping hyperplane are discarded, only the parts on the minus side remain.\u003c/p\u003e\n * @param hyperplane chopping hyperplane\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.FastMath#359",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.FastMath()",
    "snippet": "private FastMath(){\n}",
    "begin_line": 359,
    "end_line": 359,
    "comment": "/** \n * Private Constructor\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.doubleHighPart#370",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.doubleHighPart(double)",
    "snippet": "private static double doubleHighPart(double d){\n  if (d \u003e -Precision.SAFE_MIN \u0026\u0026 d \u003c Precision.SAFE_MIN) {\n    return d;\n  }\n  long xl\u003dDouble.doubleToRawLongBits(d);\n  xl\u003dxl \u0026 MASK_30BITS;\n  return Double.longBitsToDouble(xl);\n}",
    "begin_line": 370,
    "end_line": 377,
    "comment": "/** \n * Get the high order bits from the mantissa. Equivalent to adding and subtracting HEX_40000 but also works for very large numbers\n * @param d the value to split\n * @return the high order part of the mantissa\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.sqrt#384",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sqrt(double)",
    "snippet": "public static double sqrt(final double a){\n  return Math.sqrt(a);\n}",
    "begin_line": 384,
    "end_line": 386,
    "comment": "/** \n * Compute the square root of a number. \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e this implementation currently delegates to  {@link Math#sqrt}\n * @param a number on which evaluation is done\n * @return square root of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.cosh#392",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cosh(double)",
    "snippet": "public static double cosh(double x){\n  if (x !\u003d x) {\n    return x;\n  }\n  if (x \u003e 20) {\n    if (x \u003e\u003d LOG_MAX_VALUE) {\n      final double t\u003dexp(0.5 * x);\n      return (0.5 * t) * t;\n    }\n else {\n      return 0.5 * exp(x);\n    }\n  }\n else   if (x \u003c -20) {\n    if (x \u003c\u003d -LOG_MAX_VALUE) {\n      final double t\u003dexp(-0.5 * x);\n      return (0.5 * t) * t;\n    }\n else {\n      return 0.5 * exp(-x);\n    }\n  }\n  final double hiPrec[]\u003dnew double[2];\n  if (x \u003c 0.0) {\n    x\u003d-x;\n  }\n  exp(x,0.0,hiPrec);\n  double ya\u003dhiPrec[0] + hiPrec[1];\n  double yb\u003d-(ya - hiPrec[0] - hiPrec[1]);\n  double temp\u003dya * HEX_40000000;\n  double yaa\u003dya + temp - temp;\n  double yab\u003dya - yaa;\n  double recip\u003d1.0 / ya;\n  temp\u003drecip * HEX_40000000;\n  double recipa\u003drecip + temp - temp;\n  double recipb\u003drecip - recipa;\n  recipb+\u003d(1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n  recipb+\u003d-yb * recip * recip;\n  temp\u003dya + recipa;\n  yb+\u003d-(temp - ya - recipa);\n  ya\u003dtemp;\n  temp\u003dya + recipb;\n  yb+\u003d-(temp - ya - recipb);\n  ya\u003dtemp;\n  double result\u003dya + yb;\n  result*\u003d0.5;\n  return result;\n}",
    "begin_line": 392,
    "end_line": 455,
    "comment": "/** \n * Compute the hyperbolic cosine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic cosine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.sinh#461",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sinh(double)",
    "snippet": "public static double sinh(double x){\n  boolean negate\u003dfalse;\n  if (x !\u003d x) {\n    return x;\n  }\n  if (x \u003e 20) {\n    if (x \u003e\u003d LOG_MAX_VALUE) {\n      final double t\u003dexp(0.5 * x);\n      return (0.5 * t) * t;\n    }\n else {\n      return 0.5 * exp(x);\n    }\n  }\n else   if (x \u003c -20) {\n    if (x \u003c\u003d -LOG_MAX_VALUE) {\n      final double t\u003dexp(-0.5 * x);\n      return (-0.5 * t) * t;\n    }\n else {\n      return -0.5 * exp(-x);\n    }\n  }\n  if (x \u003d\u003d 0) {\n    return x;\n  }\n  if (x \u003c 0.0) {\n    x\u003d-x;\n    negate\u003dtrue;\n  }\n  double result;\n  if (x \u003e 0.25) {\n    double hiPrec[]\u003dnew double[2];\n    exp(x,0.0,hiPrec);\n    double ya\u003dhiPrec[0] + hiPrec[1];\n    double yb\u003d-(ya - hiPrec[0] - hiPrec[1]);\n    double temp\u003dya * HEX_40000000;\n    double yaa\u003dya + temp - temp;\n    double yab\u003dya - yaa;\n    double recip\u003d1.0 / ya;\n    temp\u003drecip * HEX_40000000;\n    double recipa\u003drecip + temp - temp;\n    double recipb\u003drecip - recipa;\n    recipb+\u003d(1.0 - yaa * recipa - yaa * recipb - yab * recipa - yab * recipb) * recip;\n    recipb+\u003d-yb * recip * recip;\n    recipa\u003d-recipa;\n    recipb\u003d-recipb;\n    temp\u003dya + recipa;\n    yb+\u003d-(temp - ya - recipa);\n    ya\u003dtemp;\n    temp\u003dya + recipb;\n    yb+\u003d-(temp - ya - recipb);\n    ya\u003dtemp;\n    result\u003dya + yb;\n    result*\u003d0.5;\n  }\n else {\n    double hiPrec[]\u003dnew double[2];\n    expm1(x,hiPrec);\n    double ya\u003dhiPrec[0] + hiPrec[1];\n    double yb\u003d-(ya - hiPrec[0] - hiPrec[1]);\n    double denom\u003d1.0 + ya;\n    double denomr\u003d1.0 / denom;\n    double denomb\u003d-(denom - 1.0 - ya) + yb;\n    double ratio\u003dya * denomr;\n    double temp\u003dratio * HEX_40000000;\n    double ra\u003dratio + temp - temp;\n    double rb\u003dratio - ra;\n    temp\u003ddenom * HEX_40000000;\n    double za\u003ddenom + temp - temp;\n    double zb\u003ddenom - za;\n    rb+\u003d(ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n    rb+\u003dyb * denomr;\n    rb+\u003d-ya * denomb * denomr* denomr;\n    temp\u003dya + ra;\n    yb+\u003d-(temp - ya - ra);\n    ya\u003dtemp;\n    temp\u003dya + rb;\n    yb+\u003d-(temp - ya - rb);\n    ya\u003dtemp;\n    result\u003dya + yb;\n    result*\u003d0.5;\n  }\n  if (negate) {\n    result\u003d-result;\n  }\n  return result;\n}",
    "begin_line": 461,
    "end_line": 580,
    "comment": "/** \n * Compute the hyperbolic sine of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic sine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.tanh#586",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.tanh(double)",
    "snippet": "public static double tanh(double x){\n  boolean negate\u003dfalse;\n  if (x !\u003d x) {\n    return x;\n  }\n  if (x \u003e 20.0) {\n    return 1.0;\n  }\n  if (x \u003c -20) {\n    return -1.0;\n  }\n  if (x \u003d\u003d 0) {\n    return x;\n  }\n  if (x \u003c 0.0) {\n    x\u003d-x;\n    negate\u003dtrue;\n  }\n  double result;\n  if (x \u003e\u003d 0.5) {\n    double hiPrec[]\u003dnew double[2];\n    exp(x * 2.0,0.0,hiPrec);\n    double ya\u003dhiPrec[0] + hiPrec[1];\n    double yb\u003d-(ya - hiPrec[0] - hiPrec[1]);\n    double na\u003d-1.0 + ya;\n    double nb\u003d-(na + 1.0 - ya);\n    double temp\u003dna + yb;\n    nb+\u003d-(temp - na - yb);\n    na\u003dtemp;\n    double da\u003d1.0 + ya;\n    double db\u003d-(da - 1.0 - ya);\n    temp\u003dda + yb;\n    db+\u003d-(temp - da - yb);\n    da\u003dtemp;\n    temp\u003dda * HEX_40000000;\n    double daa\u003dda + temp - temp;\n    double dab\u003dda - daa;\n    double ratio\u003dna / da;\n    temp\u003dratio * HEX_40000000;\n    double ratioa\u003dratio + temp - temp;\n    double ratiob\u003dratio - ratioa;\n    ratiob+\u003d(na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n    ratiob+\u003dnb / da;\n    ratiob+\u003d-db * na / da / da;\n    result\u003dratioa + ratiob;\n  }\n else {\n    double hiPrec[]\u003dnew double[2];\n    expm1(x * 2.0,hiPrec);\n    double ya\u003dhiPrec[0] + hiPrec[1];\n    double yb\u003d-(ya - hiPrec[0] - hiPrec[1]);\n    double na\u003dya;\n    double nb\u003dyb;\n    double da\u003d2.0 + ya;\n    double db\u003d-(da - 2.0 - ya);\n    double temp\u003dda + yb;\n    db+\u003d-(temp - da - yb);\n    da\u003dtemp;\n    temp\u003dda * HEX_40000000;\n    double daa\u003dda + temp - temp;\n    double dab\u003dda - daa;\n    double ratio\u003dna / da;\n    temp\u003dratio * HEX_40000000;\n    double ratioa\u003dratio + temp - temp;\n    double ratiob\u003dratio - ratioa;\n    ratiob+\u003d(na - daa * ratioa - daa * ratiob - dab * ratioa - dab * ratiob) / da;\n    ratiob+\u003dnb / da;\n    ratiob+\u003d-db * na / da / da;\n    result\u003dratioa + ratiob;\n  }\n  if (negate) {\n    result\u003d-result;\n  }\n  return result;\n}",
    "begin_line": 586,
    "end_line": 704,
    "comment": "/** \n * Compute the hyperbolic tangent of a number.\n * @param x number on which evaluation is done\n * @return hyperbolic tangent of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.acosh#710",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.acosh(double)",
    "snippet": "public static double acosh(final double a){\n  return FastMath.log(a + FastMath.sqrt(a * a - 1));\n}",
    "begin_line": 710,
    "end_line": 712,
    "comment": "/** \n * Compute the inverse hyperbolic cosine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic cosine of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.asinh#718",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.asinh(double)",
    "snippet": "public static double asinh(double a){\n  boolean negative\u003dfalse;\n  if (a \u003c 0) {\n    negative\u003dtrue;\n    a\u003d-a;\n  }\n  double absAsinh;\n  if (a \u003e 0.167) {\n    absAsinh\u003dFastMath.log(FastMath.sqrt(a * a + 1) + a);\n  }\n else {\n    final double a2\u003da * a;\n    if (a \u003e 0.097) {\n      absAsinh\u003da * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * (F_1_13 - a2 * (F_1_15 - a2 * F_1_17 * F_15_16) * F_13_14) * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n    }\n else     if (a \u003e 0.036) {\n      absAsinh\u003da * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * (F_1_9 - a2 * (F_1_11 - a2 * F_1_13 * F_11_12) * F_9_10) * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n    }\n else     if (a \u003e 0.0036) {\n      absAsinh\u003da * (1 - a2 * (F_1_3 - a2 * (F_1_5 - a2 * (F_1_7 - a2 * F_1_9 * F_7_8) * F_5_6) * F_3_4) * F_1_2);\n    }\n else {\n      absAsinh\u003da * (1 - a2 * (F_1_3 - a2 * F_1_5 * F_3_4) * F_1_2);\n    }\n  }\n  return negative ? -absAsinh : absAsinh;\n}",
    "begin_line": 718,
    "end_line": 742,
    "comment": "/** \n * Compute the inverse hyperbolic sine of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic sine of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.atanh#748",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.atanh(double)",
    "snippet": "public static double atanh(double a){\n  boolean negative\u003dfalse;\n  if (a \u003c 0) {\n    negative\u003dtrue;\n    a\u003d-a;\n  }\n  double absAtanh;\n  if (a \u003e 0.15) {\n    absAtanh\u003d0.5 * FastMath.log((1 + a) / (1 - a));\n  }\n else {\n    final double a2\u003da * a;\n    if (a \u003e 0.087) {\n      absAtanh\u003da * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * (F_1_13 + a2 * (F_1_15 + a2 * F_1_17))))))));\n    }\n else     if (a \u003e 0.031) {\n      absAtanh\u003da * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * (F_1_9 + a2 * (F_1_11 + a2 * F_1_13))))));\n    }\n else     if (a \u003e 0.003) {\n      absAtanh\u003da * (1 + a2 * (F_1_3 + a2 * (F_1_5 + a2 * (F_1_7 + a2 * F_1_9))));\n    }\n else {\n      absAtanh\u003da * (1 + a2 * (F_1_3 + a2 * F_1_5));\n    }\n  }\n  return negative ? -absAtanh : absAtanh;\n}",
    "begin_line": 748,
    "end_line": 772,
    "comment": "/** \n * Compute the inverse hyperbolic tangent of a number.\n * @param a number on which evaluation is done\n * @return inverse hyperbolic tangent of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.signum#779",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.signum(double)",
    "snippet": "public static double signum(final double a){\n  return (a \u003c 0.0) ? -1.0 : ((a \u003e 0.0) ? 1.0 : a);\n}",
    "begin_line": 779,
    "end_line": 781,
    "comment": "/** \n * Compute the signum of a number. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.signum#788",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.signum(float)",
    "snippet": "public static float signum(final float a){\n  return (a \u003c 0.0f) ? -1.0f : ((a \u003e 0.0f) ? 1.0f : a);\n}",
    "begin_line": 788,
    "end_line": 790,
    "comment": "/** \n * Compute the signum of a number. The signum is -1 for negative numbers, +1 for positive numbers and 0 otherwise\n * @param a number on which evaluation is done\n * @return -1.0, -0.0, +0.0, +1.0 or NaN depending on sign of a\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.nextUp#796",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.nextUp(double)",
    "snippet": "public static double nextUp(final double a){\n  return nextAfter(a,Double.POSITIVE_INFINITY);\n}",
    "begin_line": 796,
    "end_line": 798,
    "comment": "/** \n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.nextUp#804",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.nextUp(float)",
    "snippet": "public static float nextUp(final float a){\n  return nextAfter(a,Float.POSITIVE_INFINITY);\n}",
    "begin_line": 804,
    "end_line": 806,
    "comment": "/** \n * Compute next number towards positive infinity.\n * @param a number to which neighbor should be computed\n * @return neighbor of a towards positive infinity\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.random#812",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.random()",
    "snippet": "public static double random(){\n  return Math.random();\n}",
    "begin_line": 812,
    "end_line": 814,
    "comment": "/** \n * Returns a pseudo-random number between 0.0 and 1.0. \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e this implementation currently delegates to  {@link Math#random}\n * @return a random number between 0.0 and 1.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.exp#836",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.exp(double)",
    "snippet": "public static double exp(double x){\n  return exp(x,0.0,null);\n}",
    "begin_line": 836,
    "end_line": 838,
    "comment": "/** \n * Exponential function. Computes exp(x), function result is nearly rounded.   It will be correctly rounded to the theoretical value for 99.9% of input values, otherwise it will have a 1 UPL error. Method: Lookup intVal \u003d exp(int(x)) Lookup fracVal \u003d exp(int(x-int(x) / 1024.0) * 1024.0 ); Compute z as the exponential of the remaining bits by a polynomial minus one exp(x) \u003d intVal * fracVal * (1 + z) Accuracy: Calculation is done with 63 bits of precision, so result should be correctly rounded for 99.9% of input values, with less than 1 ULP error otherwise.\n * @param x   a double\n * @return double e\u003csup\u003ex\u003c/sup\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.exp#847",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.exp(double, double, double[])",
    "snippet": "private static double exp(double x,double extra,double[] hiPrec){\n  double intPartA;\n  double intPartB;\n  int intVal;\n  if (x \u003c 0.0) {\n    intVal\u003d(int)-x;\n    if (intVal \u003e 746) {\n      if (hiPrec !\u003d null) {\n        hiPrec[0]\u003d0.0;\n        hiPrec[1]\u003d0.0;\n      }\n      return 0.0;\n    }\n    if (intVal \u003e 709) {\n      final double result\u003dexp(x + 40.19140625,extra,hiPrec) / 285040095144011776.0;\n      if (hiPrec !\u003d null) {\n        hiPrec[0]/\u003d285040095144011776.0;\n        hiPrec[1]/\u003d285040095144011776.0;\n      }\n      return result;\n    }\n    if (intVal \u003d\u003d 709) {\n      final double result\u003dexp(x + 1.494140625,extra,hiPrec) / 4.455505956692756620;\n      if (hiPrec !\u003d null) {\n        hiPrec[0]/\u003d4.455505956692756620;\n        hiPrec[1]/\u003d4.455505956692756620;\n      }\n      return result;\n    }\n    intVal++;\n    intPartA\u003dExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX - intVal];\n    intPartB\u003dExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX - intVal];\n    intVal\u003d-intVal;\n  }\n else {\n    intVal\u003d(int)x;\n    if (intVal \u003e 709) {\n      if (hiPrec !\u003d null) {\n        hiPrec[0]\u003dDouble.POSITIVE_INFINITY;\n        hiPrec[1]\u003d0.0;\n      }\n      return Double.POSITIVE_INFINITY;\n    }\n    intPartA\u003dExpIntTable.EXP_INT_TABLE_A[EXP_INT_TABLE_MAX_INDEX + intVal];\n    intPartB\u003dExpIntTable.EXP_INT_TABLE_B[EXP_INT_TABLE_MAX_INDEX + intVal];\n  }\n  final int intFrac\u003d(int)((x - intVal) * 1024.0);\n  final double fracPartA\u003dExpFracTable.EXP_FRAC_TABLE_A[intFrac];\n  final double fracPartB\u003dExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n  final double epsilon\u003dx - (intVal + intFrac / 1024.0);\n  double z\u003d0.04168701738764507;\n  z\u003dz * epsilon + 0.1666666505023083;\n  z\u003dz * epsilon + 0.5000000000042687;\n  z\u003dz * epsilon + 1.0;\n  z\u003dz * epsilon + -3.940510424527919E-20;\n  double tempA\u003dintPartA * fracPartA;\n  double tempB\u003dintPartA * fracPartB + intPartB * fracPartA + intPartB * fracPartB;\n  final double tempC\u003dtempB + tempA;\n  final double result;\n  if (extra !\u003d 0.0) {\n    result\u003dtempC * extra * z + tempC * extra + tempC * z + tempB + tempA;\n  }\n else {\n    result\u003dtempC * z + tempB + tempA;\n  }\n  if (hiPrec !\u003d null) {\n    hiPrec[0]\u003dtempA;\n    hiPrec[1]\u003dtempC * extra * z + tempC * extra + tempC * z + tempB;\n  }\n  return result;\n}",
    "begin_line": 847,
    "end_line": 962,
    "comment": "/** \n * Internal helper method for exponential function.\n * @param x original argument of the exponential function\n * @param extra extra bits of precision on input (To Be Confirmed)\n * @param hiPrec extra bits of precision on output (To Be Confirmed)\n * @return exp(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.expm1#968",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.expm1(double)",
    "snippet": "public static double expm1(double x){\n  return expm1(x,null);\n}",
    "begin_line": 968,
    "end_line": 970,
    "comment": "/** \n * Compute exp(x) - 1\n * @param x number to compute shifted exponential\n * @return exp(x) - 1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.expm1#977",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.expm1(double, double)",
    "snippet": "private static double expm1(double x,double hiPrecOut[]){\n  if (x !\u003d x || x \u003d\u003d 0.0) {\n    return x;\n  }\n  if (x \u003c\u003d -1.0 || x \u003e\u003d 1.0) {\n    double hiPrec[]\u003dnew double[2];\n    exp(x,0.0,hiPrec);\n    if (x \u003e 0.0) {\n      return -1.0 + hiPrec[0] + hiPrec[1];\n    }\n else {\n      final double ra\u003d-1.0 + hiPrec[0];\n      double rb\u003d-(ra + 1.0 - hiPrec[0]);\n      rb+\u003dhiPrec[1];\n      return ra + rb;\n    }\n  }\n  double baseA;\n  double baseB;\n  double epsilon;\n  boolean negative\u003dfalse;\n  if (x \u003c 0.0) {\n    x\u003d-x;\n    negative\u003dtrue;\n  }\n{\n    int intFrac\u003d(int)(x * 1024.0);\n    double tempA\u003dExpFracTable.EXP_FRAC_TABLE_A[intFrac] - 1.0;\n    double tempB\u003dExpFracTable.EXP_FRAC_TABLE_B[intFrac];\n    double temp\u003dtempA + tempB;\n    tempB\u003d-(temp - tempA - tempB);\n    tempA\u003dtemp;\n    temp\u003dtempA * HEX_40000000;\n    baseA\u003dtempA + temp - temp;\n    baseB\u003dtempB + (tempA - baseA);\n    epsilon\u003dx - intFrac / 1024.0;\n  }\n  double zb\u003d0.008336750013465571;\n  zb\u003dzb * epsilon + 0.041666663879186654;\n  zb\u003dzb * epsilon + 0.16666666666745392;\n  zb\u003dzb * epsilon + 0.49999999999999994;\n  zb\u003dzb * epsilon;\n  zb\u003dzb * epsilon;\n  double za\u003depsilon;\n  double temp\u003dza + zb;\n  zb\u003d-(temp - za - zb);\n  za\u003dtemp;\n  temp\u003dza * HEX_40000000;\n  temp\u003dza + temp - temp;\n  zb+\u003dza - temp;\n  za\u003dtemp;\n  double ya\u003dza * baseA;\n  temp\u003dya + za * baseB;\n  double yb\u003d-(temp - ya - za * baseB);\n  ya\u003dtemp;\n  temp\u003dya + zb * baseA;\n  yb+\u003d-(temp - ya - zb * baseA);\n  ya\u003dtemp;\n  temp\u003dya + zb * baseB;\n  yb+\u003d-(temp - ya - zb * baseB);\n  ya\u003dtemp;\n  temp\u003dya + baseA;\n  yb+\u003d-(temp - baseA - ya);\n  ya\u003dtemp;\n  temp\u003dya + za;\n  yb+\u003d-(temp - ya - za);\n  ya\u003dtemp;\n  temp\u003dya + baseB;\n  yb+\u003d-(temp - ya - baseB);\n  ya\u003dtemp;\n  temp\u003dya + zb;\n  yb+\u003d-(temp - ya - zb);\n  ya\u003dtemp;\n  if (negative) {\n    double denom\u003d1.0 + ya;\n    double denomr\u003d1.0 / denom;\n    double denomb\u003d-(denom - 1.0 - ya) + yb;\n    double ratio\u003dya * denomr;\n    temp\u003dratio * HEX_40000000;\n    final double ra\u003dratio + temp - temp;\n    double rb\u003dratio - ra;\n    temp\u003ddenom * HEX_40000000;\n    za\u003ddenom + temp - temp;\n    zb\u003ddenom - za;\n    rb+\u003d(ya - za * ra - za * rb - zb * ra - zb * rb) * denomr;\n    rb+\u003dyb * denomr;\n    rb+\u003d-ya * denomb * denomr* denomr;\n    ya\u003d-ra;\n    yb\u003d-rb;\n  }\n  if (hiPrecOut !\u003d null) {\n    hiPrecOut[0]\u003dya;\n    hiPrecOut[1]\u003dyb;\n  }\n  return ya + yb;\n}",
    "begin_line": 977,
    "end_line": 1117,
    "comment": "/** \n * Internal helper method for expm1\n * @param x number to compute shifted exponential\n * @param hiPrecOut receive high precision result for -1.0 \u003c x \u003c 1.0\n * @return exp(x) - 1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log#1125",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double)",
    "snippet": "public static double log(final double x){\n  return log(x,null);\n}",
    "begin_line": 1125,
    "end_line": 1127,
    "comment": "/** \n * Natural logarithm.\n * @param x   a double\n * @return log(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log#1135",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double, double[])",
    "snippet": "private static double log(final double x,final double[] hiPrec){\n  if (x \u003d\u003d 0) {\n    return Double.NEGATIVE_INFINITY;\n  }\n  long bits\u003dDouble.doubleToRawLongBits(x);\n  if (((bits \u0026 0x8000000000000000L) !\u003d 0 || x !\u003d x) \u0026\u0026 x !\u003d 0.0) {\n    if (hiPrec !\u003d null) {\n      hiPrec[0]\u003dDouble.NaN;\n    }\n    return Double.NaN;\n  }\n  if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n    if (hiPrec !\u003d null) {\n      hiPrec[0]\u003dDouble.POSITIVE_INFINITY;\n    }\n    return Double.POSITIVE_INFINITY;\n  }\n  int exp\u003d(int)(bits \u003e\u003e 52) - 1023;\n  if ((bits \u0026 0x7ff0000000000000L) \u003d\u003d 0) {\n    if (x \u003d\u003d 0) {\n      if (hiPrec !\u003d null) {\n        hiPrec[0]\u003dDouble.NEGATIVE_INFINITY;\n      }\n      return Double.NEGATIVE_INFINITY;\n    }\n    bits\u003c\u003c\u003d1;\n    while ((bits \u0026 0x0010000000000000L) \u003d\u003d 0) {\n      --exp;\n      bits\u003c\u003c\u003d1;\n    }\n  }\n  if ((exp \u003d\u003d -1 || exp \u003d\u003d 0) \u0026\u0026 x \u003c 1.01 \u0026\u0026 x \u003e 0.99 \u0026\u0026 hiPrec \u003d\u003d null) {\n    double xa\u003dx - 1.0;\n    double xb\u003dxa - x + 1.0;\n    double tmp\u003dxa * HEX_40000000;\n    double aa\u003dxa + tmp - tmp;\n    double ab\u003dxa - aa;\n    xa\u003daa;\n    xb\u003dab;\n    final double[] lnCoef_last\u003dLN_QUICK_COEF[LN_QUICK_COEF.length - 1];\n    double ya\u003dlnCoef_last[0];\n    double yb\u003dlnCoef_last[1];\n    for (int i\u003dLN_QUICK_COEF.length - 2; i \u003e\u003d 0; i--) {\n      aa\u003dya * xa;\n      ab\u003dya * xb + yb * xa + yb * xb;\n      tmp\u003daa * HEX_40000000;\n      ya\u003daa + tmp - tmp;\n      yb\u003daa - ya + ab;\n      final double[] lnCoef_i\u003dLN_QUICK_COEF[i];\n      aa\u003dya + lnCoef_i[0];\n      ab\u003dyb + lnCoef_i[1];\n      tmp\u003daa * HEX_40000000;\n      ya\u003daa + tmp - tmp;\n      yb\u003daa - ya + ab;\n    }\n    aa\u003dya * xa;\n    ab\u003dya * xb + yb * xa + yb * xb;\n    tmp\u003daa * HEX_40000000;\n    ya\u003daa + tmp - tmp;\n    yb\u003daa - ya + ab;\n    return ya + yb;\n  }\n  final double[] lnm\u003dlnMant.LN_MANT[(int)((bits \u0026 0x000ffc0000000000L) \u003e\u003e 42)];\n  final double epsilon\u003d(bits \u0026 0x3ffffffffffL) / (TWO_POWER_52 + (bits \u0026 0x000ffc0000000000L));\n  double lnza\u003d0.0;\n  double lnzb\u003d0.0;\n  if (hiPrec !\u003d null) {\n    double tmp\u003depsilon * HEX_40000000;\n    double aa\u003depsilon + tmp - tmp;\n    double ab\u003depsilon - aa;\n    double xa\u003daa;\n    double xb\u003dab;\n    final double numer\u003dbits \u0026 0x3ffffffffffL;\n    final double denom\u003dTWO_POWER_52 + (bits \u0026 0x000ffc0000000000L);\n    aa\u003dnumer - xa * denom - xb * denom;\n    xb+\u003daa / denom;\n    final double[] lnCoef_last\u003dLN_HI_PREC_COEF[LN_HI_PREC_COEF.length - 1];\n    double ya\u003dlnCoef_last[0];\n    double yb\u003dlnCoef_last[1];\n    for (int i\u003dLN_HI_PREC_COEF.length - 2; i \u003e\u003d 0; i--) {\n      aa\u003dya * xa;\n      ab\u003dya * xb + yb * xa + yb * xb;\n      tmp\u003daa * HEX_40000000;\n      ya\u003daa + tmp - tmp;\n      yb\u003daa - ya + ab;\n      final double[] lnCoef_i\u003dLN_HI_PREC_COEF[i];\n      aa\u003dya + lnCoef_i[0];\n      ab\u003dyb + lnCoef_i[1];\n      tmp\u003daa * HEX_40000000;\n      ya\u003daa + tmp - tmp;\n      yb\u003daa - ya + ab;\n    }\n    aa\u003dya * xa;\n    ab\u003dya * xb + yb * xa + yb * xb;\n    lnza\u003daa + ab;\n    lnzb\u003d-(lnza - aa - ab);\n  }\n else {\n    lnza\u003d-0.16624882440418567;\n    lnza\u003dlnza * epsilon + 0.19999954120254515;\n    lnza\u003dlnza * epsilon + -0.2499999997677497;\n    lnza\u003dlnza * epsilon + 0.3333333333332802;\n    lnza\u003dlnza * epsilon + -0.5;\n    lnza\u003dlnza * epsilon + 1.0;\n    lnza\u003dlnza * epsilon;\n  }\n  double a\u003dLN_2_A * exp;\n  double b\u003d0.0;\n  double c\u003da + lnm[0];\n  double d\u003d-(c - a - lnm[0]);\n  a\u003dc;\n  b\u003db + d;\n  c\u003da + lnza;\n  d\u003d-(c - a - lnza);\n  a\u003dc;\n  b\u003db + d;\n  c\u003da + LN_2_B * exp;\n  d\u003d-(c - a - LN_2_B * exp);\n  a\u003dc;\n  b\u003db + d;\n  c\u003da + lnm[1];\n  d\u003d-(c - a - lnm[1]);\n  a\u003dc;\n  b\u003db + d;\n  c\u003da + lnzb;\n  d\u003d-(c - a - lnzb);\n  a\u003dc;\n  b\u003db + d;\n  if (hiPrec !\u003d null) {\n    hiPrec[0]\u003da;\n    hiPrec[1]\u003db;\n  }\n  return a + b;\n}",
    "begin_line": 1135,
    "end_line": 1355,
    "comment": "/** \n * Internal helper method for natural logarithm function.\n * @param x original argument of the natural logarithm function\n * @param hiPrec extra bits of precision on output (To Be Confirmed)\n * @return log(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log1p#1363",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log1p(double)",
    "snippet": "public static double log1p(final double x){\n  if (x \u003d\u003d -1) {\n    return Double.NEGATIVE_INFINITY;\n  }\n  if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n    return Double.POSITIVE_INFINITY;\n  }\n  if (x \u003e 1e-6 || x \u003c -1e-6) {\n    final double xpa\u003d1 + x;\n    final double xpb\u003d-(xpa - 1 - x);\n    final double[] hiPrec\u003dnew double[2];\n    final double lores\u003dlog(xpa,hiPrec);\n    if (Double.isInfinite(lores)) {\n      return lores;\n    }\n    final double fx1\u003dxpb / xpa;\n    final double epsilon\u003d0.5 * fx1 + 1;\n    return epsilon * fx1 + hiPrec[1] + hiPrec[0];\n  }\n else {\n    final double y\u003d(x * F_1_3 - F_1_2) * x + 1;\n    return y * x;\n  }\n}",
    "begin_line": 1363,
    "end_line": 1393,
    "comment": "/** \n * Computes log(1 + x).\n * @param x Number.\n * @return {@code log(1 + x)}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log10#1399",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log10(double)",
    "snippet": "public static double log10(final double x){\n  final double hiPrec[]\u003dnew double[2];\n  final double lores\u003dlog(x,hiPrec);\n  if (Double.isInfinite(lores)) {\n    return lores;\n  }\n  final double tmp\u003dhiPrec[0] * HEX_40000000;\n  final double lna\u003dhiPrec[0] + tmp - tmp;\n  final double lnb\u003dhiPrec[0] - lna + hiPrec[1];\n  final double rln10a\u003d0.4342944622039795;\n  final double rln10b\u003d1.9699272335463627E-8;\n  return rln10b * lnb + rln10b * lna + rln10a * lnb + rln10a * lna;\n}",
    "begin_line": 1399,
    "end_line": 1415,
    "comment": "/** \n * Compute the base 10 logarithm.\n * @param x a number\n * @return log10(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.log#1433",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.log(double, double)",
    "snippet": "public static double log(double base,double x){\n  return log(x) / log(base);\n}",
    "begin_line": 1433,
    "end_line": 1435,
    "comment": "/** \n * Computes the \u003ca href\u003d\"http://mathworld.wolfram.com/Logarithm.html\"\u003e logarithm\u003c/a\u003e in a given base. Returns  {@code NaN} if either argument is negative.If  {@code base} is 0 and {@code x} is positive, 0 is returned.If  {@code base} is positive and {@code x} is 0,{@code Double.NEGATIVE_INFINITY} is returned.If both arguments are 0, the result is  {@code NaN}.\n * @param base Base of the logarithm, must be greater than 0.\n * @param x Argument, must be greater than 0.\n * @return the value of the logarithm, i.e. the number {@code y} such that\u003ccode\u003ebase\u003csup\u003ey\u003c/sup\u003e \u003d x\u003c/code\u003e.\n * @since 1.2 (previously in {@code MathUtils}, moved as of version 3.0)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.pow#1444",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.pow(double, double)",
    "snippet": "public static double pow(double x,double y){\n  final double lns[]\u003dnew double[2];\n  if (y \u003d\u003d 0.0) {\n    return 1.0;\n  }\n  if (x !\u003d x) {\n    return x;\n  }\n  if (x \u003d\u003d 0) {\n    long bits\u003dDouble.doubleToRawLongBits(x);\n    if ((bits \u0026 0x8000000000000000L) !\u003d 0) {\n      long yi\u003d(long)y;\n      if (y \u003c 0 \u0026\u0026 y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n        return Double.NEGATIVE_INFINITY;\n      }\n      if (y \u003e 0 \u0026\u0026 y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n        return -0.0;\n      }\n    }\n    if (y \u003c 0) {\n      return Double.POSITIVE_INFINITY;\n    }\n    if (y \u003e 0) {\n      return 0.0;\n    }\n    return Double.NaN;\n  }\n  if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n    if (y !\u003d y) {\n      return y;\n    }\n    if (y \u003c 0.0) {\n      return 0.0;\n    }\n else {\n      return Double.POSITIVE_INFINITY;\n    }\n  }\n  if (y \u003d\u003d Double.POSITIVE_INFINITY) {\n    if (x * x \u003d\u003d 1.0) {\n      return Double.NaN;\n    }\n    if (x * x \u003e 1.0) {\n      return Double.POSITIVE_INFINITY;\n    }\n else {\n      return 0.0;\n    }\n  }\n  if (x \u003d\u003d Double.NEGATIVE_INFINITY) {\n    if (y !\u003d y) {\n      return y;\n    }\n    if (y \u003c 0) {\n      long yi\u003d(long)y;\n      if (y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n        return -0.0;\n      }\n      return 0.0;\n    }\n    if (y \u003e 0) {\n      long yi\u003d(long)y;\n      if (y \u003d\u003d yi \u0026\u0026 (yi \u0026 1) \u003d\u003d 1) {\n        return Double.NEGATIVE_INFINITY;\n      }\n      return Double.POSITIVE_INFINITY;\n    }\n  }\n  if (y \u003d\u003d Double.NEGATIVE_INFINITY) {\n    if (x * x \u003d\u003d 1.0) {\n      return Double.NaN;\n    }\n    if (x * x \u003c 1.0) {\n      return Double.POSITIVE_INFINITY;\n    }\n else {\n      return 0.0;\n    }\n  }\n  if (x \u003c 0) {\n    if (y \u003e\u003d TWO_POWER_53 || y \u003c\u003d -TWO_POWER_53) {\n      return pow(-x,y);\n    }\n    if (y \u003d\u003d (long)y) {\n      return ((long)y \u0026 1) \u003d\u003d 0 ? pow(-x,y) : -pow(-x,y);\n    }\n else {\n      return Double.NaN;\n    }\n  }\n  double ya;\n  double yb;\n  if (y \u003c 8e298 \u0026\u0026 y \u003e -8e298) {\n    double tmp1\u003dy * HEX_40000000;\n    ya\u003dy + tmp1 - tmp1;\n    yb\u003dy - ya;\n  }\n else {\n    double tmp1\u003dy * 9.31322574615478515625E-10;\n    double tmp2\u003dtmp1 * 9.31322574615478515625E-10;\n    ya\u003d(tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n    yb\u003dy - ya;\n  }\n  final double lores\u003dlog(x,lns);\n  if (Double.isInfinite(lores)) {\n    return lores;\n  }\n  double lna\u003dlns[0];\n  double lnb\u003dlns[1];\n  double tmp1\u003dlna * HEX_40000000;\n  double tmp2\u003dlna + tmp1 - tmp1;\n  lnb+\u003dlna - tmp2;\n  lna\u003dtmp2;\n  final double aa\u003dlna * ya;\n  final double ab\u003dlna * yb + lnb * ya + lnb * yb;\n  lna\u003daa + ab;\n  lnb\u003d-(lna - aa - ab);\n  double z\u003d1.0 / 120.0;\n  z\u003dz * lnb + (1.0 / 24.0);\n  z\u003dz * lnb + (1.0 / 6.0);\n  z\u003dz * lnb + 0.5;\n  z\u003dz * lnb + 1.0;\n  z\u003dz * lnb;\n  final double result\u003dexp(lna,z,null);\n  return result;\n}",
    "begin_line": 1444,
    "end_line": 1602,
    "comment": "/** \n * Power function.  Compute x^y.\n * @param x   a double\n * @param y   a double\n * @return double\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.pow#1613",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.pow(double, int)",
    "snippet": "public static double pow(double d,int e){\n  if (e \u003d\u003d 0) {\n    return 1.0;\n  }\n else   if (e \u003c 0) {\n    e\u003d-e;\n    d\u003d1.0 / d;\n  }\n  final int splitFactor\u003d0x8000001;\n  final double cd\u003dsplitFactor * d;\n  final double d1High\u003dcd - (cd - d);\n  final double d1Low\u003dd - d1High;\n  double resultHigh\u003d1;\n  double resultLow\u003d0;\n  double d2p\u003dd;\n  double d2pHigh\u003dd1High;\n  double d2pLow\u003dd1Low;\n  while (e !\u003d 0) {\n    if ((e \u0026 0x1) !\u003d 0) {\n      final double tmpHigh\u003dresultHigh * d2p;\n      final double cRH\u003dsplitFactor * resultHigh;\n      final double rHH\u003dcRH - (cRH - resultHigh);\n      final double rHL\u003dresultHigh - rHH;\n      final double tmpLow\u003drHL * d2pLow - (((tmpHigh - rHH * d2pHigh) - rHL * d2pHigh) - rHH * d2pLow);\n      resultHigh\u003dtmpHigh;\n      resultLow\u003dresultLow * d2p + tmpLow;\n    }\n    final double tmpHigh\u003dd2pHigh * d2p;\n    final double cD2pH\u003dsplitFactor * d2pHigh;\n    final double d2pHH\u003dcD2pH - (cD2pH - d2pHigh);\n    final double d2pHL\u003dd2pHigh - d2pHH;\n    final double tmpLow\u003dd2pHL * d2pLow - (((tmpHigh - d2pHH * d2pHigh) - d2pHL * d2pHigh) - d2pHH * d2pLow);\n    final double cTmpH\u003dsplitFactor * tmpHigh;\n    d2pHigh\u003dcTmpH - (cTmpH - tmpHigh);\n    d2pLow\u003dd2pLow * d2p + tmpLow + (tmpHigh - d2pHigh);\n    d2p\u003dd2pHigh + d2pLow;\n    e\u003de \u003e\u003e 1;\n  }\n  return resultHigh + resultLow;\n}",
    "begin_line": 1613,
    "end_line": 1670,
    "comment": "/** \n * Raise a double to an int power.\n * @param d Number to raise.\n * @param e Exponent.\n * @return d\u003csup\u003ee\u003c/sup\u003e\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.polySine#1678",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.polySine(double)",
    "snippet": "private static double polySine(final double x){\n  double x2\u003dx * x;\n  double p\u003d2.7553817452272217E-6;\n  p\u003dp * x2 + -1.9841269659586505E-4;\n  p\u003dp * x2 + 0.008333333333329196;\n  p\u003dp * x2 + -0.16666666666666666;\n  p\u003dp * x2 * x;\n  return p;\n}",
    "begin_line": 1678,
    "end_line": 1691,
    "comment": "/** \n * Computes sin(x) - x, where |x| \u003c 1/16. Use a Remez polynomial approximation.\n * @param x a number smaller than 1/16\n * @return sin(x) - x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.polyCosine#1699",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.polyCosine(double)",
    "snippet": "private static double polyCosine(double x){\n  double x2\u003dx * x;\n  double p\u003d2.479773539153719E-5;\n  p\u003dp * x2 + -0.0013888888689039883;\n  p\u003dp * x2 + 0.041666666666621166;\n  p\u003dp * x2 + -0.49999999999999994;\n  p*\u003dx2;\n  return p;\n}",
    "begin_line": 1699,
    "end_line": 1709,
    "comment": "/** \n * Computes cos(x) - 1, where |x| \u003c 1/16. Use a Remez polynomial approximation.\n * @param x a number smaller than 1/16\n * @return cos(x) - 1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.sinQ#1718",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sinQ(double, double)",
    "snippet": "private static double sinQ(double xa,double xb){\n  int idx\u003d(int)((xa * 8.0) + 0.5);\n  final double epsilon\u003dxa - EIGHTHS[idx];\n  final double sintA\u003dSINE_TABLE_A[idx];\n  final double sintB\u003dSINE_TABLE_B[idx];\n  final double costA\u003dCOSINE_TABLE_A[idx];\n  final double costB\u003dCOSINE_TABLE_B[idx];\n  double sinEpsA\u003depsilon;\n  double sinEpsB\u003dpolySine(epsilon);\n  final double cosEpsA\u003d1.0;\n  final double cosEpsB\u003dpolyCosine(epsilon);\n  final double temp\u003dsinEpsA * HEX_40000000;\n  double temp2\u003d(sinEpsA + temp) - temp;\n  sinEpsB+\u003dsinEpsA - temp2;\n  sinEpsA\u003dtemp2;\n  double result;\n  double a\u003d0;\n  double b\u003d0;\n  double t\u003dsintA;\n  double c\u003da + t;\n  double d\u003d-(c - a - t);\n  a\u003dc;\n  b\u003db + d;\n  t\u003dcostA * sinEpsA;\n  c\u003da + t;\n  d\u003d-(c - a - t);\n  a\u003dc;\n  b\u003db + d;\n  b\u003db + sintA * cosEpsB + costA * sinEpsB;\n  b\u003db + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n  if (xb !\u003d 0.0) {\n    t\u003d((costA + costB) * (cosEpsA + cosEpsB) - (sintA + sintB) * (sinEpsA + sinEpsB)) * xb;\n    c\u003da + t;\n    d\u003d-(c - a - t);\n    a\u003dc;\n    b\u003db + d;\n  }\n  result\u003da + b;\n  return result;\n}",
    "begin_line": 1718,
    "end_line": 1833,
    "comment": "/** \n * Compute sine over the first quadrant (0 \u003c x \u003c pi/2). Use combination of table lookup and rational polynomial expansion.\n * @param xa number from which sine is requested\n * @param xb extra bits for x (may be 0.0)\n * @return sin(xa + xb)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.cosQ#1842",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cosQ(double, double)",
    "snippet": "private static double cosQ(double xa,double xb){\n  final double pi2a\u003d1.5707963267948966;\n  final double pi2b\u003d6.123233995736766E-17;\n  final double a\u003dpi2a - xa;\n  double b\u003d-(a - pi2a + xa);\n  b+\u003dpi2b - xb;\n  return sinQ(a,b);\n}",
    "begin_line": 1842,
    "end_line": 1851,
    "comment": "/** \n * Compute cosine in the first quadrant by subtracting input from PI/2 and then calling sinQ.  This is more accurate as the input approaches PI/2.\n * @param xa number from which cosine is requested\n * @param xb extra bits for x (may be 0.0)\n * @return cos(xa + xb)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.tanQ#1861",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.tanQ(double, double, boolean)",
    "snippet": "private static double tanQ(double xa,double xb,boolean cotanFlag){\n  int idx\u003d(int)((xa * 8.0) + 0.5);\n  final double epsilon\u003dxa - EIGHTHS[idx];\n  final double sintA\u003dSINE_TABLE_A[idx];\n  final double sintB\u003dSINE_TABLE_B[idx];\n  final double costA\u003dCOSINE_TABLE_A[idx];\n  final double costB\u003dCOSINE_TABLE_B[idx];\n  double sinEpsA\u003depsilon;\n  double sinEpsB\u003dpolySine(epsilon);\n  final double cosEpsA\u003d1.0;\n  final double cosEpsB\u003dpolyCosine(epsilon);\n  double temp\u003dsinEpsA * HEX_40000000;\n  double temp2\u003d(sinEpsA + temp) - temp;\n  sinEpsB+\u003dsinEpsA - temp2;\n  sinEpsA\u003dtemp2;\n  double a\u003d0;\n  double b\u003d0;\n  double t\u003dsintA;\n  double c\u003da + t;\n  double d\u003d-(c - a - t);\n  a\u003dc;\n  b\u003db + d;\n  t\u003dcostA * sinEpsA;\n  c\u003da + t;\n  d\u003d-(c - a - t);\n  a\u003dc;\n  b\u003db + d;\n  b\u003db + sintA * cosEpsB + costA * sinEpsB;\n  b\u003db + sintB + costB * sinEpsA + sintB * cosEpsB + costB * sinEpsB;\n  double sina\u003da + b;\n  double sinb\u003d-(sina - a - b);\n  a\u003db\u003dc\u003dd\u003d0.0;\n  t\u003dcostA * cosEpsA;\n  c\u003da + t;\n  d\u003d-(c - a - t);\n  a\u003dc;\n  b\u003db + d;\n  t\u003d-sintA * sinEpsA;\n  c\u003da + t;\n  d\u003d-(c - a - t);\n  a\u003dc;\n  b\u003db + d;\n  b\u003db + costB * cosEpsA + costA * cosEpsB + costB * cosEpsB;\n  b\u003db - (sintB * sinEpsA + sintA * sinEpsB + sintB * sinEpsB);\n  double cosa\u003da + b;\n  double cosb\u003d-(cosa - a - b);\n  if (cotanFlag) {\n    double tmp;\n    tmp\u003dcosa;\n    cosa\u003dsina;\n    sina\u003dtmp;\n    tmp\u003dcosb;\n    cosb\u003dsinb;\n    sinb\u003dtmp;\n  }\n  double est\u003dsina / cosa;\n  temp\u003dest * HEX_40000000;\n  double esta\u003d(est + temp) - temp;\n  double estb\u003dest - esta;\n  temp\u003dcosa * HEX_40000000;\n  double cosaa\u003d(cosa + temp) - temp;\n  double cosab\u003dcosa - cosaa;\n  double err\u003d(sina - esta * cosaa - esta * cosab - estb * cosaa - estb * cosab) / cosa;\n  err+\u003dsinb / cosa;\n  err+\u003d-sina * cosb / cosa / cosa;\n  if (xb !\u003d 0.0) {\n    double xbadj\u003dxb + est * est * xb;\n    if (cotanFlag) {\n      xbadj\u003d-xbadj;\n    }\n    err+\u003dxbadj;\n  }\n  return est + err;\n}",
    "begin_line": 1861,
    "end_line": 1996,
    "comment": "/** \n * Compute tangent (or cotangent) over the first quadrant.   0 \u003c x \u003c pi/2 Use combination of table lookup and rational polynomial expansion.\n * @param xa number from which sine is requested\n * @param xb extra bits for x (may be 0.0)\n * @param cotanFlag if true, compute the cotangent instead of the tangent\n * @return tan(xa+xb) (or cotangent, depending on cotanFlag)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.reducePayneHanek#2009",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.reducePayneHanek(double, double)",
    "snippet": "private static void reducePayneHanek(double x,double result[]){\n  long inbits\u003dDouble.doubleToRawLongBits(x);\n  int exponent\u003d(int)((inbits \u003e\u003e 52) \u0026 0x7ff) - 1023;\n  inbits\u0026\u003d0x000fffffffffffffL;\n  inbits|\u003d0x0010000000000000L;\n  exponent++;\n  inbits\u003c\u003c\u003d11;\n  long shpi0;\n  long shpiA;\n  long shpiB;\n  int idx\u003dexponent \u003e\u003e 6;\n  int shift\u003dexponent - (idx \u003c\u003c 6);\n  if (shift !\u003d 0) {\n    shpi0\u003d(idx \u003d\u003d 0) ? 0 : (RECIP_2PI[idx - 1] \u003c\u003c shift);\n    shpi0|\u003dRECIP_2PI[idx] \u003e\u003e\u003e (64 - shift);\n    shpiA\u003d(RECIP_2PI[idx] \u003c\u003c shift) | (RECIP_2PI[idx + 1] \u003e\u003e\u003e (64 - shift));\n    shpiB\u003d(RECIP_2PI[idx + 1] \u003c\u003c shift) | (RECIP_2PI[idx + 2] \u003e\u003e\u003e (64 - shift));\n  }\n else {\n    shpi0\u003d(idx \u003d\u003d 0) ? 0 : RECIP_2PI[idx - 1];\n    shpiA\u003dRECIP_2PI[idx];\n    shpiB\u003dRECIP_2PI[idx + 1];\n  }\n  long a\u003dinbits \u003e\u003e\u003e 32;\n  long b\u003dinbits \u0026 0xffffffffL;\n  long c\u003dshpiA \u003e\u003e\u003e 32;\n  long d\u003dshpiA \u0026 0xffffffffL;\n  long ac\u003da * c;\n  long bd\u003db * d;\n  long bc\u003db * c;\n  long ad\u003da * d;\n  long prodB\u003dbd + (ad \u003c\u003c 32);\n  long prodA\u003dac + (ad \u003e\u003e\u003e 32);\n  boolean bita\u003d(bd \u0026 0x8000000000000000L) !\u003d 0;\n  boolean bitb\u003d(ad \u0026 0x80000000L) !\u003d 0;\n  boolean bitsum\u003d(prodB \u0026 0x8000000000000000L) !\u003d 0;\n  if ((bita \u0026\u0026 bitb) || ((bita || bitb) \u0026\u0026 !bitsum)) {\n    prodA++;\n  }\n  bita\u003d(prodB \u0026 0x8000000000000000L) !\u003d 0;\n  bitb\u003d(bc \u0026 0x80000000L) !\u003d 0;\n  prodB\u003dprodB + (bc \u003c\u003c 32);\n  prodA\u003dprodA + (bc \u003e\u003e\u003e 32);\n  bitsum\u003d(prodB \u0026 0x8000000000000000L) !\u003d 0;\n  if ((bita \u0026\u0026 bitb) || ((bita || bitb) \u0026\u0026 !bitsum)) {\n    prodA++;\n  }\n  c\u003dshpiB \u003e\u003e\u003e 32;\n  d\u003dshpiB \u0026 0xffffffffL;\n  ac\u003da * c;\n  bc\u003db * c;\n  ad\u003da * d;\n  ac\u003dac + ((bc + ad) \u003e\u003e\u003e 32);\n  bita\u003d(prodB \u0026 0x8000000000000000L) !\u003d 0;\n  bitb\u003d(ac \u0026 0x8000000000000000L) !\u003d 0;\n  prodB+\u003dac;\n  bitsum\u003d(prodB \u0026 0x8000000000000000L) !\u003d 0;\n  if ((bita \u0026\u0026 bitb) || ((bita || bitb) \u0026\u0026 !bitsum)) {\n    prodA++;\n  }\n  c\u003dshpi0 \u003e\u003e\u003e 32;\n  d\u003dshpi0 \u0026 0xffffffffL;\n  bd\u003db * d;\n  bc\u003db * c;\n  ad\u003da * d;\n  prodA+\u003dbd + ((bc + ad) \u003c\u003c 32);\n  int intPart\u003d(int)(prodA \u003e\u003e\u003e 62);\n  prodA\u003c\u003c\u003d2;\n  prodA|\u003dprodB \u003e\u003e\u003e 62;\n  prodB\u003c\u003c\u003d2;\n  a\u003dprodA \u003e\u003e\u003e 32;\n  b\u003dprodA \u0026 0xffffffffL;\n  c\u003dPI_O_4_BITS[0] \u003e\u003e\u003e 32;\n  d\u003dPI_O_4_BITS[0] \u0026 0xffffffffL;\n  ac\u003da * c;\n  bd\u003db * d;\n  bc\u003db * c;\n  ad\u003da * d;\n  long prod2B\u003dbd + (ad \u003c\u003c 32);\n  long prod2A\u003dac + (ad \u003e\u003e\u003e 32);\n  bita\u003d(bd \u0026 0x8000000000000000L) !\u003d 0;\n  bitb\u003d(ad \u0026 0x80000000L) !\u003d 0;\n  bitsum\u003d(prod2B \u0026 0x8000000000000000L) !\u003d 0;\n  if ((bita \u0026\u0026 bitb) || ((bita || bitb) \u0026\u0026 !bitsum)) {\n    prod2A++;\n  }\n  bita\u003d(prod2B \u0026 0x8000000000000000L) !\u003d 0;\n  bitb\u003d(bc \u0026 0x80000000L) !\u003d 0;\n  prod2B\u003dprod2B + (bc \u003c\u003c 32);\n  prod2A\u003dprod2A + (bc \u003e\u003e\u003e 32);\n  bitsum\u003d(prod2B \u0026 0x8000000000000000L) !\u003d 0;\n  if ((bita \u0026\u0026 bitb) || ((bita || bitb) \u0026\u0026 !bitsum)) {\n    prod2A++;\n  }\n  c\u003dPI_O_4_BITS[1] \u003e\u003e\u003e 32;\n  d\u003dPI_O_4_BITS[1] \u0026 0xffffffffL;\n  ac\u003da * c;\n  bc\u003db * c;\n  ad\u003da * d;\n  ac\u003dac + ((bc + ad) \u003e\u003e\u003e 32);\n  bita\u003d(prod2B \u0026 0x8000000000000000L) !\u003d 0;\n  bitb\u003d(ac \u0026 0x8000000000000000L) !\u003d 0;\n  prod2B+\u003dac;\n  bitsum\u003d(prod2B \u0026 0x8000000000000000L) !\u003d 0;\n  if ((bita \u0026\u0026 bitb) || ((bita || bitb) \u0026\u0026 !bitsum)) {\n    prod2A++;\n  }\n  a\u003dprodB \u003e\u003e\u003e 32;\n  b\u003dprodB \u0026 0xffffffffL;\n  c\u003dPI_O_4_BITS[0] \u003e\u003e\u003e 32;\n  d\u003dPI_O_4_BITS[0] \u0026 0xffffffffL;\n  ac\u003da * c;\n  bc\u003db * c;\n  ad\u003da * d;\n  ac\u003dac + ((bc + ad) \u003e\u003e\u003e 32);\n  bita\u003d(prod2B \u0026 0x8000000000000000L) !\u003d 0;\n  bitb\u003d(ac \u0026 0x8000000000000000L) !\u003d 0;\n  prod2B+\u003dac;\n  bitsum\u003d(prod2B \u0026 0x8000000000000000L) !\u003d 0;\n  if ((bita \u0026\u0026 bitb) || ((bita || bitb) \u0026\u0026 !bitsum)) {\n    prod2A++;\n  }\n  double tmpA\u003d(prod2A \u003e\u003e\u003e 12) / TWO_POWER_52;\n  double tmpB\u003d(((prod2A \u0026 0xfffL) \u003c\u003c 40) + (prod2B \u003e\u003e\u003e 24)) / TWO_POWER_52 / TWO_POWER_52;\n  double sumA\u003dtmpA + tmpB;\n  double sumB\u003d-(sumA - tmpA - tmpB);\n  result[0]\u003dintPart;\n  result[1]\u003dsumA * 2.0;\n  result[2]\u003dsumB * 2.0;\n}",
    "begin_line": 2009,
    "end_line": 2219,
    "comment": "/** \n * Reduce the input argument using the Payne and Hanek method. This is good for all inputs 0.0 \u003c x \u003c inf Output is remainder after dividing by PI/2 The result array should contain 3 numbers. result[0] is the integer portion, so mod 4 this gives the quadrant. result[1] is the upper bits of the remainder result[2] is the lower bits of the remainder\n * @param x number to reduce\n * @param result placeholder where to put the result\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.sin#2227",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.sin(double)",
    "snippet": "public static double sin(double x){\n  boolean negative\u003dfalse;\n  int quadrant\u003d0;\n  double xa;\n  double xb\u003d0.0;\n  xa\u003dx;\n  if (x \u003c 0) {\n    negative\u003dtrue;\n    xa\u003d-xa;\n  }\n  if (xa \u003d\u003d 0.0) {\n    long bits\u003dDouble.doubleToRawLongBits(x);\n    if (bits \u003c 0) {\n      return -0.0;\n    }\n    return 0.0;\n  }\n  if (xa !\u003d xa || xa \u003d\u003d Double.POSITIVE_INFINITY) {\n    return Double.NaN;\n  }\n  if (xa \u003e 3294198.0) {\n    double reduceResults[]\u003dnew double[3];\n    reducePayneHanek(xa,reduceResults);\n    quadrant\u003d((int)reduceResults[0]) \u0026 3;\n    xa\u003dreduceResults[1];\n    xb\u003dreduceResults[2];\n  }\n else   if (xa \u003e 1.5707963267948966) {\n    final CodyWaite cw\u003dnew CodyWaite(xa);\n    quadrant\u003dcw.getK() \u0026 3;\n    xa\u003dcw.getRemA();\n    xb\u003dcw.getRemB();\n  }\n  if (negative) {\n    quadrant^\u003d2;\n  }\nswitch (quadrant) {\ncase 0:    return sinQ(xa,xb);\ncase 1:  return cosQ(xa,xb);\ncase 2:return -sinQ(xa,xb);\ncase 3:return -cosQ(xa,xb);\ndefault:return Double.NaN;\n}\n}",
    "begin_line": 2227,
    "end_line": 2286,
    "comment": "/** \n * Sine function.\n * @param x Argument.\n * @return sin(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.cos#2294",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cos(double)",
    "snippet": "public static double cos(double x){\n  int quadrant\u003d0;\n  double xa\u003dx;\n  if (x \u003c 0) {\n    xa\u003d-xa;\n  }\n  if (xa !\u003d xa || xa \u003d\u003d Double.POSITIVE_INFINITY) {\n    return Double.NaN;\n  }\n  double xb\u003d0;\n  if (xa \u003e 3294198.0) {\n    double reduceResults[]\u003dnew double[3];\n    reducePayneHanek(xa,reduceResults);\n    quadrant\u003d((int)reduceResults[0]) \u0026 3;\n    xa\u003dreduceResults[1];\n    xb\u003dreduceResults[2];\n  }\n else   if (xa \u003e 1.5707963267948966) {\n    final CodyWaite cw\u003dnew CodyWaite(xa);\n    quadrant\u003dcw.getK() \u0026 3;\n    xa\u003dcw.getRemA();\n    xb\u003dcw.getRemB();\n  }\nswitch (quadrant) {\ncase 0:    return cosQ(xa,xb);\ncase 1:  return -sinQ(xa,xb);\ncase 2:return -cosQ(xa,xb);\ncase 3:return sinQ(xa,xb);\ndefault:return Double.NaN;\n}\n}",
    "begin_line": 2294,
    "end_line": 2340,
    "comment": "/** \n * Cosine function.\n * @param x Argument.\n * @return cos(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.tan#2348",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.tan(double)",
    "snippet": "public static double tan(double x){\n  boolean negative\u003dfalse;\n  int quadrant\u003d0;\n  double xa\u003dx;\n  if (x \u003c 0) {\n    negative\u003dtrue;\n    xa\u003d-xa;\n  }\n  if (xa \u003d\u003d 0.0) {\n    long bits\u003dDouble.doubleToRawLongBits(x);\n    if (bits \u003c 0) {\n      return -0.0;\n    }\n    return 0.0;\n  }\n  if (xa !\u003d xa || xa \u003d\u003d Double.POSITIVE_INFINITY) {\n    return Double.NaN;\n  }\n  double xb\u003d0;\n  if (xa \u003e 3294198.0) {\n    double reduceResults[]\u003dnew double[3];\n    reducePayneHanek(xa,reduceResults);\n    quadrant\u003d((int)reduceResults[0]) \u0026 3;\n    xa\u003dreduceResults[1];\n    xb\u003dreduceResults[2];\n  }\n else   if (xa \u003e 1.5707963267948966) {\n    final CodyWaite cw\u003dnew CodyWaite(xa);\n    quadrant\u003dcw.getK() \u0026 3;\n    xa\u003dcw.getRemA();\n    xb\u003dcw.getRemB();\n  }\n  if (xa \u003e 1.5) {\n    final double pi2a\u003d1.5707963267948966;\n    final double pi2b\u003d6.123233995736766E-17;\n    final double a\u003dpi2a - xa;\n    double b\u003d-(a - pi2a + xa);\n    b+\u003dpi2b - xb;\n    xa\u003da + b;\n    xb\u003d-(xa - a - b);\n    quadrant^\u003d1;\n    negative^\u003dtrue;\n  }\n  double result;\n  if ((quadrant \u0026 1) \u003d\u003d 0) {\n    result\u003dtanQ(xa,xb,false);\n  }\n else {\n    result\u003d-tanQ(xa,xb,true);\n  }\n  if (negative) {\n    result\u003d-result;\n  }\n  return result;\n}",
    "begin_line": 2348,
    "end_line": 2417,
    "comment": "/** \n * Tangent function.\n * @param x Argument.\n * @return tan(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.atan#2424",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.atan(double)",
    "snippet": "public static double atan(double x){\n  return atan(x,0.0,false);\n}",
    "begin_line": 2424,
    "end_line": 2426,
    "comment": "/** \n * Arctangent function\n * @param x a number\n * @return atan(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.atan#2434",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.atan(double, double, boolean)",
    "snippet": "private static double atan(double xa,double xb,boolean leftPlane){\n  boolean negate\u003dfalse;\n  int idx;\n  if (xa \u003d\u003d 0.0) {\n    return leftPlane ? copySign(Math.PI,xa) : xa;\n  }\n  if (xa \u003c 0) {\n    xa\u003d-xa;\n    xb\u003d-xb;\n    negate\u003dtrue;\n  }\n  if (xa \u003e 1.633123935319537E16) {\n    return (negate ^ leftPlane) ? (-Math.PI * F_1_2) : (Math.PI * F_1_2);\n  }\n  if (xa \u003c 1) {\n    idx\u003d(int)(((-1.7168146928204136 * xa * xa + 8.0) * xa) + 0.5);\n  }\n else {\n    final double oneOverXa\u003d1 / xa;\n    idx\u003d(int)(-((-1.7168146928204136 * oneOverXa * oneOverXa + 8.0) * oneOverXa) + 13.07);\n  }\n  double epsA\u003dxa - TANGENT_TABLE_A[idx];\n  double epsB\u003d-(epsA - xa + TANGENT_TABLE_A[idx]);\n  epsB+\u003dxb - TANGENT_TABLE_B[idx];\n  double temp\u003depsA + epsB;\n  epsB\u003d-(temp - epsA - epsB);\n  epsA\u003dtemp;\n  temp\u003dxa * HEX_40000000;\n  double ya\u003dxa + temp - temp;\n  double yb\u003dxb + xa - ya;\n  xa\u003dya;\n  xb+\u003dyb;\n  if (idx \u003d\u003d 0) {\n    final double denom\u003d1d / (1d + (xa + xb) * (TANGENT_TABLE_A[idx] + TANGENT_TABLE_B[idx]));\n    ya\u003depsA * denom;\n    yb\u003depsB * denom;\n  }\n else {\n    double temp2\u003dxa * TANGENT_TABLE_A[idx];\n    double za\u003d1d + temp2;\n    double zb\u003d-(za - 1d - temp2);\n    temp2\u003dxb * TANGENT_TABLE_A[idx] + xa * TANGENT_TABLE_B[idx];\n    temp\u003dza + temp2;\n    zb+\u003d-(temp - za - temp2);\n    za\u003dtemp;\n    zb+\u003dxb * TANGENT_TABLE_B[idx];\n    ya\u003depsA / za;\n    temp\u003dya * HEX_40000000;\n    final double yaa\u003d(ya + temp) - temp;\n    final double yab\u003dya - yaa;\n    temp\u003dza * HEX_40000000;\n    final double zaa\u003d(za + temp) - temp;\n    final double zab\u003dza - zaa;\n    yb\u003d(epsA - yaa * zaa - yaa * zab - yab * zaa - yab * zab) / za;\n    yb+\u003d-epsA * zb / za / za;\n    yb+\u003depsB / za;\n  }\n  epsA\u003dya;\n  epsB\u003dyb;\n  final double epsA2\u003depsA * epsA;\n  yb\u003d0.07490822288864472;\n  yb\u003dyb * epsA2 + -0.09088450866185192;\n  yb\u003dyb * epsA2 + 0.11111095942313305;\n  yb\u003dyb * epsA2 + -0.1428571423679182;\n  yb\u003dyb * epsA2 + 0.19999999999923582;\n  yb\u003dyb * epsA2 + -0.33333333333333287;\n  yb\u003dyb * epsA2 * epsA;\n  ya\u003depsA;\n  temp\u003dya + yb;\n  yb\u003d-(temp - ya - yb);\n  ya\u003dtemp;\n  yb+\u003depsB / (1d + epsA * epsA);\n  double za\u003dEIGHTHS[idx] + ya;\n  double zb\u003d-(za - EIGHTHS[idx] - ya);\n  temp\u003dza + yb;\n  zb+\u003d-(temp - za - yb);\n  za\u003dtemp;\n  double result\u003dza + zb;\n  double resultb\u003d-(result - za - zb);\n  if (leftPlane) {\n    final double pia\u003d1.5707963267948966 * 2;\n    final double pib\u003d6.123233995736766E-17 * 2;\n    za\u003dpia - result;\n    zb\u003d-(za - pia + result);\n    zb+\u003dpib - resultb;\n    result\u003dza + zb;\n    resultb\u003d-(result - za - zb);\n  }\n  if (negate ^ leftPlane) {\n    result\u003d-result;\n  }\n  return result;\n}",
    "begin_line": 2434,
    "end_line": 2573,
    "comment": "/** \n * Internal helper function to compute arctangent.\n * @param xa number from which arctangent is requested\n * @param xb extra bits for x (may be 0.0)\n * @param leftPlane if true, result angle must be put in the left half plane\n * @return atan(xa + xb) (or angle shifted by {@code PI} if leftPlane is true)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.atan2#2581",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.atan2(double, double)",
    "snippet": "public static double atan2(double y,double x){\n  if (x !\u003d x || y !\u003d y) {\n    return Double.NaN;\n  }\n  if (y \u003d\u003d 0) {\n    final double result\u003dx * y;\n    final double invx\u003d1d / x;\n    final double invy\u003d1d / y;\n    if (invx \u003d\u003d 0) {\n      if (x \u003e 0) {\n        return y;\n      }\n else {\n        return copySign(Math.PI,y);\n      }\n    }\n    if (x \u003c 0 || invx \u003c 0) {\n      if (y \u003c 0 || invy \u003c 0) {\n        return -Math.PI;\n      }\n else {\n        return Math.PI;\n      }\n    }\n else {\n      return result;\n    }\n  }\n  if (y \u003d\u003d Double.POSITIVE_INFINITY) {\n    if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n      return Math.PI * F_1_4;\n    }\n    if (x \u003d\u003d Double.NEGATIVE_INFINITY) {\n      return Math.PI * F_3_4;\n    }\n    return Math.PI * F_1_2;\n  }\n  if (y \u003d\u003d Double.NEGATIVE_INFINITY) {\n    if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n      return -Math.PI * F_1_4;\n    }\n    if (x \u003d\u003d Double.NEGATIVE_INFINITY) {\n      return -Math.PI * F_3_4;\n    }\n    return -Math.PI * F_1_2;\n  }\n  if (x \u003d\u003d Double.POSITIVE_INFINITY) {\n    if (y \u003e 0 || 1 / y \u003e 0) {\n      return 0d;\n    }\n    if (y \u003c 0 || 1 / y \u003c 0) {\n      return -0d;\n    }\n  }\n  if (x \u003d\u003d Double.NEGATIVE_INFINITY) {\n    if (y \u003e 0.0 || 1 / y \u003e 0.0) {\n      return Math.PI;\n    }\n    if (y \u003c 0 || 1 / y \u003c 0) {\n      return -Math.PI;\n    }\n  }\n  if (x \u003d\u003d 0) {\n    if (y \u003e 0 || 1 / y \u003e 0) {\n      return Math.PI * F_1_2;\n    }\n    if (y \u003c 0 || 1 / y \u003c 0) {\n      return -Math.PI * F_1_2;\n    }\n  }\n  final double r\u003dy / x;\n  if (Double.isInfinite(r)) {\n    return atan(r,0,x \u003c 0);\n  }\n  double ra\u003ddoubleHighPart(r);\n  double rb\u003dr - ra;\n  final double xa\u003ddoubleHighPart(x);\n  final double xb\u003dx - xa;\n  rb+\u003d(y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n  final double temp\u003dra + rb;\n  rb\u003d-(temp - ra - rb);\n  ra\u003dtemp;\n  if (ra \u003d\u003d 0) {\n    ra\u003dcopySign(0d,y);\n  }\n  final double result\u003datan(ra,rb,x \u003c 0);\n  return result;\n}",
    "begin_line": 2581,
    "end_line": 2696,
    "comment": "/** \n * Two arguments arctangent function\n * @param y ordinate\n * @param x abscissa\n * @return phase angle of point (x,y) between {@code -PI} and {@code PI}\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.asin#2702",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.asin(double)",
    "snippet": "public static double asin(double x){\n  if (x !\u003d x) {\n    return Double.NaN;\n  }\n  if (x \u003e 1.0 || x \u003c -1.0) {\n    return Double.NaN;\n  }\n  if (x \u003d\u003d 1.0) {\n    return Math.PI / 2.0;\n  }\n  if (x \u003d\u003d -1.0) {\n    return -Math.PI / 2.0;\n  }\n  if (x \u003d\u003d 0.0) {\n    return x;\n  }\n  double temp\u003dx * HEX_40000000;\n  final double xa\u003dx + temp - temp;\n  final double xb\u003dx - xa;\n  double ya\u003dxa * xa;\n  double yb\u003dxa * xb * 2.0 + xb * xb;\n  ya\u003d-ya;\n  yb\u003d-yb;\n  double za\u003d1.0 + ya;\n  double zb\u003d-(za - 1.0 - ya);\n  temp\u003dza + yb;\n  zb+\u003d-(temp - za - yb);\n  za\u003dtemp;\n  double y;\n  y\u003dsqrt(za);\n  temp\u003dy * HEX_40000000;\n  ya\u003dy + temp - temp;\n  yb\u003dy - ya;\n  yb+\u003d(za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);\n  double dx\u003dzb / (2.0 * y);\n  double r\u003dx / y;\n  temp\u003dr * HEX_40000000;\n  double ra\u003dr + temp - temp;\n  double rb\u003dr - ra;\n  rb+\u003d(x - ra * ya - ra * yb - rb * ya - rb * yb) / y;\n  rb+\u003d-x * dx / y / y;\n  temp\u003dra + rb;\n  rb\u003d-(temp - ra - rb);\n  ra\u003dtemp;\n  return atan(ra,rb,false);\n}",
    "begin_line": 2702,
    "end_line": 2772,
    "comment": "/** \n * Compute the arc sine of a number.\n * @param x number on which evaluation is done\n * @return arc sine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.acos#2778",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.acos(double)",
    "snippet": "public static double acos(double x){\n  if (x !\u003d x) {\n    return Double.NaN;\n  }\n  if (x \u003e 1.0 || x \u003c -1.0) {\n    return Double.NaN;\n  }\n  if (x \u003d\u003d -1.0) {\n    return Math.PI;\n  }\n  if (x \u003d\u003d 1.0) {\n    return 0.0;\n  }\n  if (x \u003d\u003d 0) {\n    return Math.PI / 2.0;\n  }\n  double temp\u003dx * HEX_40000000;\n  final double xa\u003dx + temp - temp;\n  final double xb\u003dx - xa;\n  double ya\u003dxa * xa;\n  double yb\u003dxa * xb * 2.0 + xb * xb;\n  ya\u003d-ya;\n  yb\u003d-yb;\n  double za\u003d1.0 + ya;\n  double zb\u003d-(za - 1.0 - ya);\n  temp\u003dza + yb;\n  zb+\u003d-(temp - za - yb);\n  za\u003dtemp;\n  double y\u003dsqrt(za);\n  temp\u003dy * HEX_40000000;\n  ya\u003dy + temp - temp;\n  yb\u003dy - ya;\n  yb+\u003d(za - ya * ya - 2 * ya * yb - yb * yb) / (2.0 * y);\n  yb+\u003dzb / (2.0 * y);\n  y\u003dya + yb;\n  yb\u003d-(y - ya - yb);\n  double r\u003dy / x;\n  if (Double.isInfinite(r)) {\n    return Math.PI / 2;\n  }\n  double ra\u003ddoubleHighPart(r);\n  double rb\u003dr - ra;\n  rb+\u003d(y - ra * xa - ra * xb - rb * xa - rb * xb) / x;\n  rb+\u003dyb / x;\n  temp\u003dra + rb;\n  rb\u003d-(temp - ra - rb);\n  ra\u003dtemp;\n  return atan(ra,rb,x \u003c 0);\n}",
    "begin_line": 2778,
    "end_line": 2854,
    "comment": "/** \n * Compute the arc cosine of a number.\n * @param x number on which evaluation is done\n * @return arc cosine of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.cbrt#2860",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.cbrt(double)",
    "snippet": "public static double cbrt(double x){\n  long inbits\u003dDouble.doubleToRawLongBits(x);\n  int exponent\u003d(int)((inbits \u003e\u003e 52) \u0026 0x7ff) - 1023;\n  boolean subnormal\u003dfalse;\n  if (exponent \u003d\u003d -1023) {\n    if (x \u003d\u003d 0) {\n      return x;\n    }\n    subnormal\u003dtrue;\n    x*\u003d1.8014398509481984E16;\n    inbits\u003dDouble.doubleToRawLongBits(x);\n    exponent\u003d(int)((inbits \u003e\u003e 52) \u0026 0x7ff) - 1023;\n  }\n  if (exponent \u003d\u003d 1024) {\n    return x;\n  }\n  int exp3\u003dexponent / 3;\n  double p2\u003dDouble.longBitsToDouble((inbits \u0026 0x8000000000000000L) | (long)(((exp3 + 1023) \u0026 0x7ff)) \u003c\u003c 52);\n  final double mant\u003dDouble.longBitsToDouble((inbits \u0026 0x000fffffffffffffL) | 0x3ff0000000000000L);\n  double est\u003d-0.010714690733195933;\n  est\u003dest * mant + 0.0875862700108075;\n  est\u003dest * mant + -0.3058015757857271;\n  est\u003dest * mant + 0.7249995199969751;\n  est\u003dest * mant + 0.5039018405998233;\n  est*\u003dCBRTTWO[exponent % 3 + 2];\n  final double xs\u003dx / (p2 * p2 * p2);\n  est+\u003d(xs - est * est * est) / (3 * est * est);\n  est+\u003d(xs - est * est * est) / (3 * est * est);\n  double temp\u003dest * HEX_40000000;\n  double ya\u003dest + temp - temp;\n  double yb\u003dest - ya;\n  double za\u003dya * ya;\n  double zb\u003dya * yb * 2.0 + yb * yb;\n  temp\u003dza * HEX_40000000;\n  double temp2\u003dza + temp - temp;\n  zb+\u003dza - temp2;\n  za\u003dtemp2;\n  zb\u003dza * yb + ya * zb + zb * yb;\n  za\u003dza * ya;\n  double na\u003dxs - za;\n  double nb\u003d-(na - xs + za);\n  nb-\u003dzb;\n  est+\u003d(na + nb) / (3 * est * est);\n  est*\u003dp2;\n  if (subnormal) {\n    est*\u003d3.814697265625E-6;\n  }\n  return est;\n}",
    "begin_line": 2860,
    "end_line": 2938,
    "comment": "/** \n * Compute the cubic root of a number.\n * @param x number on which evaluation is done\n * @return cubic root of x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.toRadians#2945",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.toRadians(double)",
    "snippet": "public static double toRadians(double x){\n  if (Double.isInfinite(x) || x \u003d\u003d 0.0) {\n    return x;\n  }\n  final double facta\u003d0.01745329052209854;\n  final double factb\u003d1.997844754509471E-9;\n  double xa\u003ddoubleHighPart(x);\n  double xb\u003dx - xa;\n  double result\u003dxb * factb + xb * facta + xa * factb + xa * facta;\n  if (result \u003d\u003d 0) {\n    result\u003dresult * x;\n  }\n  return result;\n}",
    "begin_line": 2945,
    "end_line": 2963,
    "comment": "/** \n * Convert degrees to radians, with error of less than 0.5 ULP\n * @param x angle in degrees\n * @return x converted into radians\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.toDegrees#2970",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.toDegrees(double)",
    "snippet": "public static double toDegrees(double x){\n  if (Double.isInfinite(x) || x \u003d\u003d 0.0) {\n    return x;\n  }\n  final double facta\u003d57.2957763671875;\n  final double factb\u003d3.145894820876798E-6;\n  double xa\u003ddoubleHighPart(x);\n  double xb\u003dx - xa;\n  return xb * factb + xb * facta + xa * factb + xa * facta;\n}",
    "begin_line": 2970,
    "end_line": 2984,
    "comment": "/** \n * Convert radians to degrees, with error of less than 0.5 ULP\n * @param x angle in radians\n * @return x converted into degrees\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.abs#2991",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(int)",
    "snippet": "public static int abs(final int x){\n  final int i\u003dx \u003e\u003e\u003e 31;\n  return (x ^ (~i + 1)) + i;\n}",
    "begin_line": 2991,
    "end_line": 2994,
    "comment": "/** \n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.abs#3001",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(long)",
    "snippet": "public static long abs(final long x){\n  final long l\u003dx \u003e\u003e\u003e 63;\n  return (x ^ (~l + 1)) + l;\n}",
    "begin_line": 3001,
    "end_line": 3008,
    "comment": "/** \n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.abs#3015",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(float)",
    "snippet": "public static float abs(final float x){\n  return Float.intBitsToFloat(MASK_NON_SIGN_INT \u0026 Float.floatToRawIntBits(x));\n}",
    "begin_line": 3015,
    "end_line": 3017,
    "comment": "/** \n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.abs#3024",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.abs(double)",
    "snippet": "public static double abs(double x){\n  return Double.longBitsToDouble(MASK_NON_SIGN_LONG \u0026 Double.doubleToRawLongBits(x));\n}",
    "begin_line": 3024,
    "end_line": 3026,
    "comment": "/** \n * Absolute value.\n * @param x number from which absolute value is requested\n * @return abs(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.ulp#3033",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.ulp(double)",
    "snippet": "public static double ulp(double x){\n  if (Double.isInfinite(x)) {\n    return Double.POSITIVE_INFINITY;\n  }\n  return abs(x - Double.longBitsToDouble(Double.doubleToRawLongBits(x) ^ 1));\n}",
    "begin_line": 3033,
    "end_line": 3038,
    "comment": "/** \n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.ulp#3045",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.ulp(float)",
    "snippet": "public static float ulp(float x){\n  if (Float.isInfinite(x)) {\n    return Float.POSITIVE_INFINITY;\n  }\n  return abs(x - Float.intBitsToFloat(Float.floatToIntBits(x) ^ 1));\n}",
    "begin_line": 3045,
    "end_line": 3050,
    "comment": "/** \n * Compute least significant bit (Unit in Last Position) for a number.\n * @param x number from which ulp is requested\n * @return ulp(x)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.scalb#3058",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.scalb(double, int)",
    "snippet": "public static double scalb(final double d,final int n){\n  if ((n \u003e -1023) \u0026\u0026 (n \u003c 1024)) {\n    return d * Double.longBitsToDouble(((long)(n + 1023)) \u003c\u003c 52);\n  }\n  if (Double.isNaN(d) || Double.isInfinite(d) || (d \u003d\u003d 0)) {\n    return d;\n  }\n  if (n \u003c -2098) {\n    return (d \u003e 0) ? 0.0 : -0.0;\n  }\n  if (n \u003e 2097) {\n    return (d \u003e 0) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n  }\n  final long bits\u003dDouble.doubleToRawLongBits(d);\n  final long sign\u003dbits \u0026 0x8000000000000000L;\n  int exponent\u003d((int)(bits \u003e\u003e\u003e 52)) \u0026 0x7ff;\n  long mantissa\u003dbits \u0026 0x000fffffffffffffL;\n  int scaledExponent\u003dexponent + n;\n  if (n \u003c 0) {\n    if (scaledExponent \u003e 0) {\n      return Double.longBitsToDouble(sign | (((long)scaledExponent) \u003c\u003c 52) | mantissa);\n    }\n else     if (scaledExponent \u003e -53) {\n      mantissa\u003dmantissa | (1L \u003c\u003c 52);\n      final long mostSignificantLostBit\u003dmantissa \u0026 (1L \u003c\u003c (-scaledExponent));\n      mantissa\u003dmantissa \u003e\u003e\u003e (1 - scaledExponent);\n      if (mostSignificantLostBit !\u003d 0) {\n        mantissa++;\n      }\n      return Double.longBitsToDouble(sign | mantissa);\n    }\n else {\n      return (sign \u003d\u003d 0L) ? 0.0 : -0.0;\n    }\n  }\n else {\n    if (exponent \u003d\u003d 0) {\n      while ((mantissa \u003e\u003e\u003e 52) !\u003d 1) {\n        mantissa\u003dmantissa \u003c\u003c 1;\n        --scaledExponent;\n      }\n      ++scaledExponent;\n      mantissa\u003dmantissa \u0026 0x000fffffffffffffL;\n      if (scaledExponent \u003c 2047) {\n        return Double.longBitsToDouble(sign | (((long)scaledExponent) \u003c\u003c 52) | mantissa);\n      }\n else {\n        return (sign \u003d\u003d 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n      }\n    }\n else     if (scaledExponent \u003c 2047) {\n      return Double.longBitsToDouble(sign | (((long)scaledExponent) \u003c\u003c 52) | mantissa);\n    }\n else {\n      return (sign \u003d\u003d 0L) ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n    }\n  }\n}",
    "begin_line": 3058,
    "end_line": 3134,
    "comment": "/** \n * Multiply a double number by a power of 2.\n * @param d number to multiply\n * @param n power of 2\n * @return d \u0026times; 2\u003csup\u003en\u003c/sup\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.scalb#3142",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.scalb(float, int)",
    "snippet": "public static float scalb(final float f,final int n){\n  if ((n \u003e -127) \u0026\u0026 (n \u003c 128)) {\n    return f * Float.intBitsToFloat((n + 127) \u003c\u003c 23);\n  }\n  if (Float.isNaN(f) || Float.isInfinite(f) || (f \u003d\u003d 0f)) {\n    return f;\n  }\n  if (n \u003c -277) {\n    return (f \u003e 0) ? 0.0f : -0.0f;\n  }\n  if (n \u003e 276) {\n    return (f \u003e 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n  }\n  final int bits\u003dFloat.floatToIntBits(f);\n  final int sign\u003dbits \u0026 0x80000000;\n  int exponent\u003d(bits \u003e\u003e\u003e 23) \u0026 0xff;\n  int mantissa\u003dbits \u0026 0x007fffff;\n  int scaledExponent\u003dexponent + n;\n  if (n \u003c 0) {\n    if (scaledExponent \u003e 0) {\n      return Float.intBitsToFloat(sign | (scaledExponent \u003c\u003c 23) | mantissa);\n    }\n else     if (scaledExponent \u003e -24) {\n      mantissa\u003dmantissa | (1 \u003c\u003c 23);\n      final int mostSignificantLostBit\u003dmantissa \u0026 (1 \u003c\u003c (-scaledExponent));\n      mantissa\u003dmantissa \u003e\u003e\u003e (1 - scaledExponent);\n      if (mostSignificantLostBit !\u003d 0) {\n        mantissa++;\n      }\n      return Float.intBitsToFloat(sign | mantissa);\n    }\n else {\n      return (sign \u003d\u003d 0) ? 0.0f : -0.0f;\n    }\n  }\n else {\n    if (exponent \u003d\u003d 0) {\n      while ((mantissa \u003e\u003e\u003e 23) !\u003d 1) {\n        mantissa\u003dmantissa \u003c\u003c 1;\n        --scaledExponent;\n      }\n      ++scaledExponent;\n      mantissa\u003dmantissa \u0026 0x007fffff;\n      if (scaledExponent \u003c 255) {\n        return Float.intBitsToFloat(sign | (scaledExponent \u003c\u003c 23) | mantissa);\n      }\n else {\n        return (sign \u003d\u003d 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n      }\n    }\n else     if (scaledExponent \u003c 255) {\n      return Float.intBitsToFloat(sign | (scaledExponent \u003c\u003c 23) | mantissa);\n    }\n else {\n      return (sign \u003d\u003d 0) ? Float.POSITIVE_INFINITY : Float.NEGATIVE_INFINITY;\n    }\n  }\n}",
    "begin_line": 3142,
    "end_line": 3218,
    "comment": "/** \n * Multiply a float number by a power of 2.\n * @param f number to multiply\n * @param n power of 2\n * @return f \u0026times; 2\u003csup\u003en\u003c/sup\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.nextAfter#3251",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.nextAfter(double, double)",
    "snippet": "public static double nextAfter(double d,double direction){\n  if (Double.isNaN(d) || Double.isNaN(direction)) {\n    return Double.NaN;\n  }\n else   if (d \u003d\u003d direction) {\n    return direction;\n  }\n else   if (Double.isInfinite(d)) {\n    return (d \u003c 0) ? -Double.MAX_VALUE : Double.MAX_VALUE;\n  }\n else   if (d \u003d\u003d 0) {\n    return (direction \u003c 0) ? -Double.MIN_VALUE : Double.MIN_VALUE;\n  }\n  final long bits\u003dDouble.doubleToRawLongBits(d);\n  final long sign\u003dbits \u0026 0x8000000000000000L;\n  if ((direction \u003c d) ^ (sign \u003d\u003d 0L)) {\n    return Double.longBitsToDouble(sign | ((bits \u0026 0x7fffffffffffffffL) + 1));\n  }\n else {\n    return Double.longBitsToDouble(sign | ((bits \u0026 0x7fffffffffffffffL) - 1));\n  }\n}",
    "begin_line": 3251,
    "end_line": 3274,
    "comment": "/** \n * Get the next machine representable number after a number, moving in the direction of another number. \u003cp\u003e The ordering is as follows (increasing): \u003cul\u003e \u003cli\u003e-INFINITY\u003c/li\u003e \u003cli\u003e-MAX_VALUE\u003c/li\u003e \u003cli\u003e-MIN_VALUE\u003c/li\u003e \u003cli\u003e-0.0\u003c/li\u003e \u003cli\u003e+0.0\u003c/li\u003e \u003cli\u003e+MIN_VALUE\u003c/li\u003e \u003cli\u003e+MAX_VALUE\u003c/li\u003e \u003cli\u003e+INFINITY\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cp\u003e If arguments compare equal, then the second argument is returned. \u003cp\u003e If  {@code direction} is greater than {@code d}, the smallest machine representable number strictly greater than {@code d} is returned; if less, then the largest representable numberstrictly less than  {@code d} is returned.\u003c/p\u003e\u003cp\u003e If  {@code d} is infinite and direction does notbring it back to finite numbers, it is returned unchanged.\u003c/p\u003e\n * @param d base number\n * @param direction (the only important thing is whether{@code direction} is greater or smaller than {@code d})\n * @return the next machine representable number in the specified direction\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.nextAfter#3307",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.nextAfter(float, double)",
    "snippet": "public static float nextAfter(final float f,final double direction){\n  if (Double.isNaN(f) || Double.isNaN(direction)) {\n    return Float.NaN;\n  }\n else   if (f \u003d\u003d direction) {\n    return (float)direction;\n  }\n else   if (Float.isInfinite(f)) {\n    return (f \u003c 0f) ? -Float.MAX_VALUE : Float.MAX_VALUE;\n  }\n else   if (f \u003d\u003d 0f) {\n    return (direction \u003c 0) ? -Float.MIN_VALUE : Float.MIN_VALUE;\n  }\n  final int bits\u003dFloat.floatToIntBits(f);\n  final int sign\u003dbits \u0026 0x80000000;\n  if ((direction \u003c f) ^ (sign \u003d\u003d 0)) {\n    return Float.intBitsToFloat(sign | ((bits \u0026 0x7fffffff) + 1));\n  }\n else {\n    return Float.intBitsToFloat(sign | ((bits \u0026 0x7fffffff) - 1));\n  }\n}",
    "begin_line": 3307,
    "end_line": 3330,
    "comment": "/** \n * Get the next machine representable number after a number, moving in the direction of another number. \u003cp\u003e The ordering is as follows (increasing): \u003cul\u003e \u003cli\u003e-INFINITY\u003c/li\u003e \u003cli\u003e-MAX_VALUE\u003c/li\u003e \u003cli\u003e-MIN_VALUE\u003c/li\u003e \u003cli\u003e-0.0\u003c/li\u003e \u003cli\u003e+0.0\u003c/li\u003e \u003cli\u003e+MIN_VALUE\u003c/li\u003e \u003cli\u003e+MAX_VALUE\u003c/li\u003e \u003cli\u003e+INFINITY\u003c/li\u003e \u003cli\u003e\u003c/li\u003e \u003cp\u003e If arguments compare equal, then the second argument is returned. \u003cp\u003e If  {@code direction} is greater than {@code f}, the smallest machine representable number strictly greater than {@code f} is returned; if less, then the largest representable numberstrictly less than  {@code f} is returned.\u003c/p\u003e\u003cp\u003e If  {@code f} is infinite and direction does notbring it back to finite numbers, it is returned unchanged.\u003c/p\u003e\n * @param f base number\n * @param direction (the only important thing is whether{@code direction} is greater or smaller than {@code f})\n * @return the next machine representable number in the specified direction\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.floor#3336",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.floor(double)",
    "snippet": "public static double floor(double x){\n  long y;\n  if (x !\u003d x) {\n    return x;\n  }\n  if (x \u003e\u003d TWO_POWER_52 || x \u003c\u003d -TWO_POWER_52) {\n    return x;\n  }\n  y\u003d(long)x;\n  if (x \u003c 0 \u0026\u0026 y !\u003d x) {\n    y--;\n  }\n  if (y \u003d\u003d 0) {\n    return x * y;\n  }\n  return y;\n}",
    "begin_line": 3336,
    "end_line": 3357,
    "comment": "/** \n * Get the largest whole number smaller than x.\n * @param x number from which floor is requested\n * @return a double number f such that f is an integer f \u003c\u003d x \u003c f + 1.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.ceil#3363",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.ceil(double)",
    "snippet": "public static double ceil(double x){\n  double y;\n  if (x !\u003d x) {\n    return x;\n  }\n  y\u003dfloor(x);\n  if (y \u003d\u003d x) {\n    return y;\n  }\n  y+\u003d1.0;\n  if (y \u003d\u003d 0) {\n    return x * y;\n  }\n  return y;\n}",
    "begin_line": 3363,
    "end_line": 3382,
    "comment": "/** \n * Get the smallest whole number larger than x.\n * @param x number from which ceil is requested\n * @return a double number c such that c is an integer c - 1.0 \u003c x \u003c\u003d c\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.rint#3388",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.rint(double)",
    "snippet": "public static double rint(double x){\n  double y\u003dfloor(x);\n  double d\u003dx - y;\n  if (d \u003e 0.5) {\n    if (y \u003d\u003d -1.0) {\n      return -0.0;\n    }\n    return y + 1.0;\n  }\n  if (d \u003c 0.5) {\n    return y;\n  }\n  long z\u003d(long)y;\n  return (z \u0026 1) \u003d\u003d 0 ? y : y + 1.0;\n}",
    "begin_line": 3388,
    "end_line": 3405,
    "comment": "/** \n * Get the whole number that is the nearest to x, or the even one if x is exactly half way between two integers.\n * @param x number from which nearest whole number is requested\n * @return a double number r such that r is an integer r - 0.5 \u003c\u003d x \u003c\u003d r + 0.5\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.round#3411",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.round(double)",
    "snippet": "public static long round(double x){\n  return (long)floor(x + 0.5);\n}",
    "begin_line": 3411,
    "end_line": 3413,
    "comment": "/** \n * Get the closest long to x.\n * @param x number from which closest long is requested\n * @return closest long to x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.round#3419",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.round(float)",
    "snippet": "public static int round(final float x){\n  return (int)floor(x + 0.5f);\n}",
    "begin_line": 3419,
    "end_line": 3421,
    "comment": "/** \n * Get the closest int to x.\n * @param x number from which closest int is requested\n * @return closest int to x\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.min#3428",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(int, int)",
    "snippet": "public static int min(final int a,final int b){\n  return (a \u003c\u003d b) ? a : b;\n}",
    "begin_line": 3428,
    "end_line": 3430,
    "comment": "/** \n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.min#3437",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(long, long)",
    "snippet": "public static long min(final long a,final long b){\n  return (a \u003c\u003d b) ? a : b;\n}",
    "begin_line": 3437,
    "end_line": 3439,
    "comment": "/** \n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.min#3446",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(float, float)",
    "snippet": "public static float min(final float a,final float b){\n  if (a \u003e b) {\n    return b;\n  }\n  if (a \u003c b) {\n    return a;\n  }\n  if (a !\u003d b) {\n    return Float.NaN;\n  }\n  int bits\u003dFloat.floatToRawIntBits(a);\n  if (bits \u003d\u003d 0x80000000) {\n    return a;\n  }\n  return b;\n}",
    "begin_line": 3446,
    "end_line": 3464,
    "comment": "/** \n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.min#3471",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.min(double, double)",
    "snippet": "public static double min(final double a,final double b){\n  if (a \u003e b) {\n    return b;\n  }\n  if (a \u003c b) {\n    return a;\n  }\n  if (a !\u003d b) {\n    return Double.NaN;\n  }\n  long bits\u003dDouble.doubleToRawLongBits(a);\n  if (bits \u003d\u003d 0x8000000000000000L) {\n    return a;\n  }\n  return b;\n}",
    "begin_line": 3471,
    "end_line": 3489,
    "comment": "/** \n * Compute the minimum of two values\n * @param a first value\n * @param b second value\n * @return a if a is lesser or equal to b, b otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.max#3496",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(int, int)",
    "snippet": "public static int max(final int a,final int b){\n  return (a \u003c\u003d b) ? b : a;\n}",
    "begin_line": 3496,
    "end_line": 3498,
    "comment": "/** \n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.max#3505",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(long, long)",
    "snippet": "public static long max(final long a,final long b){\n  return (a \u003c\u003d b) ? b : a;\n}",
    "begin_line": 3505,
    "end_line": 3507,
    "comment": "/** \n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.max#3514",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(float, float)",
    "snippet": "public static float max(final float a,final float b){\n  if (a \u003e b) {\n    return a;\n  }\n  if (a \u003c b) {\n    return b;\n  }\n  if (a !\u003d b) {\n    return Float.NaN;\n  }\n  int bits\u003dFloat.floatToRawIntBits(a);\n  if (bits \u003d\u003d 0x80000000) {\n    return b;\n  }\n  return a;\n}",
    "begin_line": 3514,
    "end_line": 3532,
    "comment": "/** \n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.max#3539",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.max(double, double)",
    "snippet": "public static double max(final double a,final double b){\n  if (a \u003e b) {\n    return a;\n  }\n  if (a \u003c b) {\n    return b;\n  }\n  if (a !\u003d b) {\n    return Double.NaN;\n  }\n  long bits\u003dDouble.doubleToRawLongBits(a);\n  if (bits \u003d\u003d 0x8000000000000000L) {\n    return b;\n  }\n  return a;\n}",
    "begin_line": 3539,
    "end_line": 3557,
    "comment": "/** \n * Compute the maximum of two values\n * @param a first value\n * @param b second value\n * @return b if a is lesser or equal to b, a otherwise\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.hypot#3573",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.hypot(double, double)",
    "snippet": "public static double hypot(final double x,final double y){\n  if (Double.isInfinite(x) || Double.isInfinite(y)) {\n    return Double.POSITIVE_INFINITY;\n  }\n else   if (Double.isNaN(x) || Double.isNaN(y)) {\n    return Double.NaN;\n  }\n else {\n    final int expX\u003dgetExponent(x);\n    final int expY\u003dgetExponent(y);\n    if (expX \u003e expY + 27) {\n      return abs(x);\n    }\n else     if (expY \u003e expX + 27) {\n      return abs(y);\n    }\n else {\n      final int middleExp\u003d(expX + expY) / 2;\n      final double scaledX\u003dscalb(x,-middleExp);\n      final double scaledY\u003dscalb(y,-middleExp);\n      final double scaledH\u003dsqrt(scaledX * scaledX + scaledY * scaledY);\n      return scalb(scaledH,middleExp);\n    }\n  }\n}",
    "begin_line": 3573,
    "end_line": 3606,
    "comment": "/** \n * Returns the hypotenuse of a triangle with sides  {@code x} and {@code y}- sqrt(\u003ci\u003ex\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e\u0026nbsp;+\u003ci\u003ey\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e)\u003cbr/\u003e avoiding intermediate overflow or underflow. \u003cul\u003e \u003cli\u003e If either argument is infinite, then the result is positive infinity.\u003c/li\u003e \u003cli\u003e else, if either argument is NaN then the result is NaN.\u003c/li\u003e \u003c/ul\u003e\n * @param x a value\n * @param y a value\n * @return sqrt(\u003ci\u003ex\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e\u0026nbsp;+\u003ci\u003ey\u003c/i\u003e\u003csup\u003e2\u003c/sup\u003e)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.IEEEremainder#3628",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.IEEEremainder(double, double)",
    "snippet": "public static double IEEEremainder(double dividend,double divisor){\n  return StrictMath.IEEEremainder(dividend,divisor);\n}",
    "begin_line": 3628,
    "end_line": 3630,
    "comment": "/** \n * Computes the remainder as prescribed by the IEEE 754 standard. The remainder value is mathematically equal to  {@code x - y*n}where  {@code n} is the mathematical integer closest to the exact mathematical valueof the quotient  {@code x/y}. If two mathematical integers are equally close to  {@code x/y} then{@code n} is the integer that is even.\u003cp\u003e \u003cul\u003e \u003cli\u003eIf either operand is NaN, the result is NaN.\u003c/li\u003e \u003cli\u003eIf the result is not NaN, the sign of the result equals the sign of the dividend.\u003c/li\u003e \u003cli\u003eIf the dividend is an infinity, or the divisor is a zero, or both, the result is NaN.\u003c/li\u003e \u003cli\u003eIf the dividend is finite and the divisor is an infinity, the result equals the dividend.\u003c/li\u003e \u003cli\u003eIf the dividend is a zero and the divisor is finite, the result equals the dividend.\u003c/li\u003e \u003c/ul\u003e \u003cp\u003e\u003cb\u003eNote:\u003c/b\u003e this implementation currently delegates to  {@link StrictMath#IEEEremainder}\n * @param dividend the number to be divided\n * @param divisor the number by which to divide\n * @return the remainder, rounded\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.copySign#3640",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.copySign(double, double)",
    "snippet": "public static double copySign(double magnitude,double sign){\n  final long m\u003dDouble.doubleToRawLongBits(magnitude);\n  final long s\u003dDouble.doubleToRawLongBits(sign);\n  if ((m ^ s) \u003e\u003d 0) {\n    return magnitude;\n  }\n  return -magnitude;\n}",
    "begin_line": 3640,
    "end_line": 3651,
    "comment": "/** \n * Returns the first argument with the sign of the second argument. A NaN  {@code sign} argument is treated as positive.\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.copySign#3661",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.copySign(float, float)",
    "snippet": "public static float copySign(float magnitude,float sign){\n  final int m\u003dFloat.floatToRawIntBits(magnitude);\n  final int s\u003dFloat.floatToRawIntBits(sign);\n  if ((m ^ s) \u003e\u003d 0) {\n    return magnitude;\n  }\n  return -magnitude;\n}",
    "begin_line": 3661,
    "end_line": 3672,
    "comment": "/** \n * Returns the first argument with the sign of the second argument. A NaN  {@code sign} argument is treated as positive.\n * @param magnitude the value to return\n * @param sign the sign for the returned value\n * @return the magnitude with the same sign as the {@code sign} argument\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.getExponent#3683",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.getExponent(double)",
    "snippet": "public static int getExponent(final double d){\n  return (int)((Double.doubleToRawLongBits(d) \u003e\u003e\u003e 52) \u0026 0x7ff) - 1023;\n}",
    "begin_line": 3683,
    "end_line": 3686,
    "comment": "/** \n * Return the exponent of a double number, removing the bias. \u003cp\u003e For double numbers of the form 2\u003csup\u003ex\u003c/sup\u003e, the unbiased exponent is exactly x. \u003c/p\u003e\n * @param d number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.getExponent#3697",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.getExponent(float)",
    "snippet": "public static int getExponent(final float f){\n  return ((Float.floatToRawIntBits(f) \u003e\u003e\u003e 23) \u0026 0xff) - 127;\n}",
    "begin_line": 3697,
    "end_line": 3700,
    "comment": "/** \n * Return the exponent of a float number, removing the bias. \u003cp\u003e For float numbers of the form 2\u003csup\u003ex\u003c/sup\u003e, the unbiased exponent is exactly x. \u003c/p\u003e\n * @param f number from which exponent is requested\n * @return exponent for d in IEEE754 representation, without bias\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "FastMath.main#3707",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.main(java.lang.String[])",
    "snippet": "public static void main(String[] a){\n  PrintStream out\u003dSystem.out;\n  FastMathCalc.printarray(out,\"EXP_INT_TABLE_A\",EXP_INT_TABLE_LEN,ExpIntTable.EXP_INT_TABLE_A);\n  FastMathCalc.printarray(out,\"EXP_INT_TABLE_B\",EXP_INT_TABLE_LEN,ExpIntTable.EXP_INT_TABLE_B);\n  FastMathCalc.printarray(out,\"EXP_FRAC_TABLE_A\",EXP_FRAC_TABLE_LEN,ExpFracTable.EXP_FRAC_TABLE_A);\n  FastMathCalc.printarray(out,\"EXP_FRAC_TABLE_B\",EXP_FRAC_TABLE_LEN,ExpFracTable.EXP_FRAC_TABLE_B);\n  FastMathCalc.printarray(out,\"LN_MANT\",LN_MANT_LEN,lnMant.LN_MANT);\n  FastMathCalc.printarray(out,\"SINE_TABLE_A\",SINE_TABLE_LEN,SINE_TABLE_A);\n  FastMathCalc.printarray(out,\"SINE_TABLE_B\",SINE_TABLE_LEN,SINE_TABLE_B);\n  FastMathCalc.printarray(out,\"COSINE_TABLE_A\",SINE_TABLE_LEN,COSINE_TABLE_A);\n  FastMathCalc.printarray(out,\"COSINE_TABLE_B\",SINE_TABLE_LEN,COSINE_TABLE_B);\n  FastMathCalc.printarray(out,\"TANGENT_TABLE_A\",SINE_TABLE_LEN,TANGENT_TABLE_A);\n  FastMathCalc.printarray(out,\"TANGENT_TABLE_B\",SINE_TABLE_LEN,TANGENT_TABLE_B);\n}",
    "begin_line": 3707,
    "end_line": 3720,
    "comment": "/** \n * Print out contents of arrays, and check the length. \u003cp\u003eused to generate the preset arrays originally.\u003c/p\u003e\n * @param a unused\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CodyWaite.CodyWaite#3826",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.CodyWaite(double)",
    "snippet": "CodyWaite(double xa){\n  int k\u003d(int)(xa * 0.6366197723675814);\n  double remA;\n  double remB;\n  while (true) {\n    double a\u003d-k * 1.570796251296997;\n    remA\u003dxa + a;\n    remB\u003d-(remA - xa - a);\n    a\u003d-k * 7.549789948768648E-8;\n    double b\u003dremA;\n    remA\u003da + b;\n    remB+\u003d-(remA - b - a);\n    a\u003d-k * 6.123233995736766E-17;\n    b\u003dremA;\n    remA\u003da + b;\n    remB+\u003d-(remA - b - a);\n    if (remA \u003e 0) {\n      break;\n    }\n    --k;\n  }\n  this.finalK\u003dk;\n  this.finalRemA\u003dremA;\n  this.finalRemB\u003dremB;\n}",
    "begin_line": 3826,
    "end_line": 3862,
    "comment": "/** \n * @param xa Argument.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CodyWaite.getK#3867",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.getK()",
    "snippet": "int getK(){\n  return finalK;\n}",
    "begin_line": 3867,
    "end_line": 3869,
    "comment": "/** \n * @return k\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CodyWaite.getRemA#3873",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.getRemA()",
    "snippet": "double getRemA(){\n  return finalRemA;\n}",
    "begin_line": 3873,
    "end_line": 3875,
    "comment": "/** \n * @return remA\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "CodyWaite.getRemB#3879",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/FastMath.java",
    "class_name": "org.apache.commons.math3.util.FastMath",
    "signature": "org.apache.commons.math3.util.FastMath.getRemB()",
    "snippet": "double getRemB(){\n  return finalRemB;\n}",
    "begin_line": 3879,
    "end_line": 3881,
    "comment": "/** \n * @return remB\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "MathArrays.MathArrays#52",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.MathArrays()",
    "snippet": "private MathArrays(){\n}",
    "begin_line": 52,
    "end_line": 52,
    "comment": "/** \n * Private constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.evaluate#65",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.evaluate(double[])",
    "snippet": "double evaluate(double[] array);",
    "begin_line": 65,
    "end_line": 65,
    "comment": "/** \n * Operates on an entire array.\n * @param array Array to operate on.\n * @return the result of the operation.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.evaluate#72",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.evaluate(double[], int, int)",
    "snippet": "double evaluate(double[] array,int startIndex,int numElements);",
    "begin_line": 72,
    "end_line": 74,
    "comment": "/** \n * @param array Array to operate on.\n * @param startIndex Index of the first element to take into account.\n * @param numElements Number of elements to take into account.\n * @return the result of the operation.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.scale#85",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.scale(double, double[])",
    "snippet": "public static double[] scale(double val,final double[] arr){\n  double[] newArr\u003dnew double[arr.length];\n  for (int i\u003d0; i \u003c arr.length; i++) {\n    newArr[i]\u003darr[i] * val;\n  }\n  return newArr;\n}",
    "begin_line": 85,
    "end_line": 91,
    "comment": "/** \n * Create a copy of an array scaled by a value.\n * @param arr Array to scale.\n * @param val Scalar.\n * @return scaled copy of array with each entry multiplied by val.\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.scaleInPlace#102",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.scaleInPlace(double, double[])",
    "snippet": "public static void scaleInPlace(double val,final double[] arr){\n  for (int i\u003d0; i \u003c arr.length; i++) {\n    arr[i]*\u003dval;\n  }\n}",
    "begin_line": 102,
    "end_line": 106,
    "comment": "/** \n * \u003cp\u003eMultiply each element of an array by a value.\u003c/p\u003e \u003cp\u003eThe array is modified in place (no copy is created).\u003c/p\u003e\n * @param arr Array to scale\n * @param val Scalar\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.ebeAdd#118",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.ebeAdd(double[], double[])",
    "snippet": "public static double[] ebeAdd(double[] a,double[] b) throws DimensionMismatchException {\n  if (a.length !\u003d b.length) {\n    throw new DimensionMismatchException(a.length,b.length);\n  }\n  final double[] result\u003da.clone();\n  for (int i\u003d0; i \u003c a.length; i++) {\n    result[i]+\u003db[i];\n  }\n  return result;\n}",
    "begin_line": 118,
    "end_line": 129,
    "comment": "/** \n * Creates an array whose contents will be the element-by-element addition of the arguments.\n * @param a First term of the addition.\n * @param b Second term of the addition.\n * @return a new array {@code r} where {@code r[i] \u003d a[i] + b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.ebeSubtract#140",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.ebeSubtract(double[], double[])",
    "snippet": "public static double[] ebeSubtract(double[] a,double[] b) throws DimensionMismatchException {\n  if (a.length !\u003d b.length) {\n    throw new DimensionMismatchException(a.length,b.length);\n  }\n  final double[] result\u003da.clone();\n  for (int i\u003d0; i \u003c a.length; i++) {\n    result[i]-\u003db[i];\n  }\n  return result;\n}",
    "begin_line": 140,
    "end_line": 151,
    "comment": "/** \n * Creates an array whose contents will be the element-by-element subtraction of the second argument from the first.\n * @param a First term.\n * @param b Element to be subtracted.\n * @return a new array {@code r} where {@code r[i] \u003d a[i] - b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.ebeMultiply#162",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.ebeMultiply(double[], double[])",
    "snippet": "public static double[] ebeMultiply(double[] a,double[] b) throws DimensionMismatchException {\n  if (a.length !\u003d b.length) {\n    throw new DimensionMismatchException(a.length,b.length);\n  }\n  final double[] result\u003da.clone();\n  for (int i\u003d0; i \u003c a.length; i++) {\n    result[i]*\u003db[i];\n  }\n  return result;\n}",
    "begin_line": 162,
    "end_line": 173,
    "comment": "/** \n * Creates an array whose contents will be the element-by-element multiplication of the arguments.\n * @param a First factor of the multiplication.\n * @param b Second factor of the multiplication.\n * @return a new array {@code r} where {@code r[i] \u003d a[i] * b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.ebeDivide#184",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.ebeDivide(double[], double[])",
    "snippet": "public static double[] ebeDivide(double[] a,double[] b) throws DimensionMismatchException {\n  if (a.length !\u003d b.length) {\n    throw new DimensionMismatchException(a.length,b.length);\n  }\n  final double[] result\u003da.clone();\n  for (int i\u003d0; i \u003c a.length; i++) {\n    result[i]/\u003db[i];\n  }\n  return result;\n}",
    "begin_line": 184,
    "end_line": 195,
    "comment": "/** \n * Creates an array whose contents will be the element-by-element division of the first argument by the second.\n * @param a Numerator of the division.\n * @param b Denominator of the division.\n * @return a new array {@code r} where {@code r[i] \u003d a[i] / b[i]}.\n * @throws DimensionMismatchException if the array lengths differ.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.distance1#204",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.distance1(double[], double[])",
    "snippet": "public static double distance1(double[] p1,double[] p2){\n  double sum\u003d0;\n  for (int i\u003d0; i \u003c p1.length; i++) {\n    sum+\u003dFastMath.abs(p1[i] - p2[i]);\n  }\n  return sum;\n}",
    "begin_line": 204,
    "end_line": 210,
    "comment": "/** \n * Calculates the L\u003csub\u003e1\u003c/sub\u003e (sum of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e1\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.distance1#219",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.distance1(int[], int[])",
    "snippet": "public static int distance1(int[] p1,int[] p2){\n  int sum\u003d0;\n  for (int i\u003d0; i \u003c p1.length; i++) {\n    sum+\u003dFastMath.abs(p1[i] - p2[i]);\n  }\n  return sum;\n}",
    "begin_line": 219,
    "end_line": 225,
    "comment": "/** \n * Calculates the L\u003csub\u003e1\u003c/sub\u003e (sum of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e1\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.distance#234",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.distance(double[], double[])",
    "snippet": "public static double distance(double[] p1,double[] p2){\n  double sum\u003d0;\n  for (int i\u003d0; i \u003c p1.length; i++) {\n    final double dp\u003dp1[i] - p2[i];\n    sum+\u003ddp * dp;\n  }\n  return FastMath.sqrt(sum);\n}",
    "begin_line": 234,
    "end_line": 241,
    "comment": "/** \n * Calculates the L\u003csub\u003e2\u003c/sub\u003e (Euclidean) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e2\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.distance#250",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.distance(int[], int[])",
    "snippet": "public static double distance(int[] p1,int[] p2){\n  double sum\u003d0;\n  for (int i\u003d0; i \u003c p1.length; i++) {\n    final double dp\u003dp1[i] - p2[i];\n    sum+\u003ddp * dp;\n  }\n  return FastMath.sqrt(sum);\n}",
    "begin_line": 250,
    "end_line": 257,
    "comment": "/** \n * Calculates the L\u003csub\u003e2\u003c/sub\u003e (Euclidean) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e2\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.distanceInf#266",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.distanceInf(double[], double[])",
    "snippet": "public static double distanceInf(double[] p1,double[] p2){\n  double max\u003d0;\n  for (int i\u003d0; i \u003c p1.length; i++) {\n    max\u003dFastMath.max(max,FastMath.abs(p1[i] - p2[i]));\n  }\n  return max;\n}",
    "begin_line": 266,
    "end_line": 272,
    "comment": "/** \n * Calculates the L\u003csub\u003e\u0026infin;\u003c/sub\u003e (max of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e\u0026infin;\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.distanceInf#281",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.distanceInf(int[], int[])",
    "snippet": "public static int distanceInf(int[] p1,int[] p2){\n  int max\u003d0;\n  for (int i\u003d0; i \u003c p1.length; i++) {\n    max\u003dFastMath.max(max,FastMath.abs(p1[i] - p2[i]));\n  }\n  return max;\n}",
    "begin_line": 281,
    "end_line": 287,
    "comment": "/** \n * Calculates the L\u003csub\u003e\u0026infin;\u003c/sub\u003e (max of abs) distance between two points.\n * @param p1 the first point\n * @param p2 the second point\n * @return the L\u003csub\u003e\u0026infin;\u003c/sub\u003e distance between the two points\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.isMonotonic#308",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.isMonotonic(T[], org.apache.commons.math3.util.MathArrays.OrderDirection, boolean)",
    "snippet": "public static \u003cT extends Comparable\u003c? super T\u003e\u003eboolean isMonotonic(T[] val,OrderDirection dir,boolean strict){\n  T previous\u003dval[0];\n  final int max\u003dval.length;\n  for (int i\u003d1; i \u003c max; i++) {\n    final int comp;\nswitch (dir) {\ncase INCREASING:      comp\u003dprevious.compareTo(val[i]);\n    if (strict) {\n      if (comp \u003e\u003d 0) {\n        return false;\n      }\n    }\n else {\n      if (comp \u003e 0) {\n        return false;\n      }\n    }\n  break;\ncase DECREASING:comp\u003dval[i].compareTo(previous);\nif (strict) {\nif (comp \u003e\u003d 0) {\n  return false;\n}\n}\n else {\nif (comp \u003e 0) {\n  return false;\n}\n}\nbreak;\ndefault:throw new MathInternalError();\n}\nprevious\u003dval[i];\n}\nreturn true;\n}",
    "begin_line": 308,
    "end_line": 348,
    "comment": "/** \n * Check that an array is monotonically increasing or decreasing.\n * @param \u003c T \u003e the type of the elements in the specified array\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @return {@code true} if sorted, {@code false} otherwise.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.isMonotonic#358",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.isMonotonic(double[], org.apache.commons.math3.util.MathArrays.OrderDirection, boolean)",
    "snippet": "public static boolean isMonotonic(double[] val,OrderDirection dir,boolean strict){\n  return checkOrder(val,dir,strict,false);\n}",
    "begin_line": 358,
    "end_line": 360,
    "comment": "/** \n * Check that an array is monotonically increasing or decreasing.\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @return {@code true} if sorted, {@code false} otherwise.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkOrder#373",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkOrder(double[], org.apache.commons.math3.util.MathArrays.OrderDirection, boolean, boolean)",
    "snippet": "public static boolean checkOrder(double[] val,OrderDirection dir,boolean strict,boolean abort) throws NonMonotonicSequenceException {\n  double previous\u003dval[0];\n  final int max\u003dval.length;\n  int index;\n  ITEM:   for (index\u003d1; index \u003c max; index++) {\nswitch (dir) {\ncase INCREASING:      if (strict) {\n        if (val[index] \u003c\u003d previous) {\n          break ITEM;\n        }\n      }\n else {\n        if (val[index] \u003c previous) {\n          break ITEM;\n        }\n      }\n    break;\ncase DECREASING:  if (strict) {\n    if (val[index] \u003e\u003d previous) {\n      break ITEM;\n    }\n  }\n else {\n    if (val[index] \u003e previous) {\n      break ITEM;\n    }\n  }\nbreak;\ndefault:throw new MathInternalError();\n}\nprevious\u003dval[index];\n}\nif (index \u003d\u003d max) {\nreturn true;\n}\nif (abort) {\nthrow new NonMonotonicSequenceException(val[index],previous,index,dir,strict);\n}\n else {\nreturn false;\n}\n}",
    "begin_line": 373,
    "end_line": 424,
    "comment": "/** \n * Check that the given array is sorted.\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @param abort Whether to throw an exception if the check fails.\n * @return {@code true} if the array is sorted.\n * @throws NonMonotonicSequenceException if the array is not sortedand  {@code abort} is {@code true}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkOrder#435",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkOrder(double[], org.apache.commons.math3.util.MathArrays.OrderDirection, boolean)",
    "snippet": "public static void checkOrder(double[] val,OrderDirection dir,boolean strict) throws NonMonotonicSequenceException {\n  checkOrder(val,dir,strict,true);\n}",
    "begin_line": 435,
    "end_line": 438,
    "comment": "/** \n * Check that the given array is sorted.\n * @param val Values.\n * @param dir Ordering direction.\n * @param strict Whether the order should be strict.\n * @throws NonMonotonicSequenceException if the array is not sorted.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkOrder#447",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkOrder(double[])",
    "snippet": "public static void checkOrder(double[] val) throws NonMonotonicSequenceException {\n  checkOrder(val,OrderDirection.INCREASING,true);\n}",
    "begin_line": 447,
    "end_line": 449,
    "comment": "/** \n * Check that the given array is sorted in strictly increasing order.\n * @param val Values.\n * @throws NonMonotonicSequenceException if the array is not sorted.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkRectangular#459",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkRectangular(long[][])",
    "snippet": "public static void checkRectangular(final long[][] in) throws NullArgumentException, DimensionMismatchException {\n  MathUtils.checkNotNull(in);\n  for (int i\u003d1; i \u003c in.length; i++) {\n    if (in[i].length !\u003d in[0].length) {\n      throw new DimensionMismatchException(LocalizedFormats.DIFFERENT_ROWS_LENGTHS,in[i].length,in[0].length);\n    }\n  }\n}",
    "begin_line": 459,
    "end_line": 469,
    "comment": "/** \n * Throws DimensionMismatchException if the input array is not rectangular.\n * @param in array to be tested\n * @throws NullArgumentException if input array is null\n * @throws DimensionMismatchException if input array is not rectangular\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkPositive#479",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkPositive(double[])",
    "snippet": "public static void checkPositive(final double[] in) throws NotStrictlyPositiveException {\n  for (int i\u003d0; i \u003c in.length; i++) {\n    if (in[i] \u003c\u003d 0) {\n      throw new NotStrictlyPositiveException(in[i]);\n    }\n  }\n}",
    "begin_line": 479,
    "end_line": 486,
    "comment": "/** \n * Check that all entries of the input array are strictly positive.\n * @param in Array to be tested\n * @throws NotStrictlyPositiveException if any entries of the array are notstrictly positive.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkNonNegative#495",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkNonNegative(long[])",
    "snippet": "public static void checkNonNegative(final long[] in) throws NotPositiveException {\n  for (int i\u003d0; i \u003c in.length; i++) {\n    if (in[i] \u003c 0) {\n      throw new NotPositiveException(in[i]);\n    }\n  }\n}",
    "begin_line": 495,
    "end_line": 502,
    "comment": "/** \n * Check that all entries of the input array are \u003e\u003d 0.\n * @param in Array to be tested\n * @throws NotPositiveException if any array entries are less than 0.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.checkNonNegative#511",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.checkNonNegative(long[][])",
    "snippet": "public static void checkNonNegative(final long[][] in) throws NotPositiveException {\n  for (int i\u003d0; i \u003c in.length; i++) {\n    for (int j\u003d0; j \u003c in[i].length; j++) {\n      if (in[i][j] \u003c 0) {\n        throw new NotPositiveException(in[i][j]);\n      }\n    }\n  }\n}",
    "begin_line": 511,
    "end_line": 520,
    "comment": "/** \n * Check all entries of the input array are \u003e\u003d 0.\n * @param in Array to be tested\n * @throws NotPositiveException if any array entries are less than 0.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.safeNorm#582",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.safeNorm(double[])",
    "snippet": "public static double safeNorm(double[] v){\n  double rdwarf\u003d3.834e-20;\n  double rgiant\u003d1.304e+19;\n  double s1\u003d0;\n  double s2\u003d0;\n  double s3\u003d0;\n  double x1max\u003d0;\n  double x3max\u003d0;\n  double floatn\u003dv.length;\n  double agiant\u003drgiant / floatn;\n  for (int i\u003d0; i \u003c v.length; i++) {\n    double xabs\u003dMath.abs(v[i]);\n    if (xabs \u003c rdwarf || xabs \u003e agiant) {\n      if (xabs \u003e rdwarf) {\n        if (xabs \u003e x1max) {\n          double r\u003dx1max / xabs;\n          s1\u003d1 + s1 * r * r;\n          x1max\u003dxabs;\n        }\n else {\n          double r\u003dxabs / x1max;\n          s1+\u003dr * r;\n        }\n      }\n else {\n        if (xabs \u003e x3max) {\n          double r\u003dx3max / xabs;\n          s3\u003d1 + s3 * r * r;\n          x3max\u003dxabs;\n        }\n else {\n          if (xabs !\u003d 0) {\n            double r\u003dxabs / x3max;\n            s3+\u003dr * r;\n          }\n        }\n      }\n    }\n else {\n      s2+\u003dxabs * xabs;\n    }\n  }\n  double norm;\n  if (s1 !\u003d 0) {\n    norm\u003dx1max * Math.sqrt(s1 + (s2 / x1max) / x1max);\n  }\n else {\n    if (s2 \u003d\u003d 0) {\n      norm\u003dx3max * Math.sqrt(s3);\n    }\n else {\n      if (s2 \u003e\u003d x3max) {\n        norm\u003dMath.sqrt(s2 * (1 + (x3max / s2) * (x3max * s3)));\n      }\n else {\n        norm\u003dMath.sqrt(x3max * ((s2 / x3max) + (x3max * s3)));\n      }\n    }\n  }\n  return norm;\n}",
    "begin_line": 582,
    "end_line": 635,
    "comment": "/** \n * Returns the Cartesian norm (2-norm), handling both overflow and underflow. Translation of the minpack enorm subroutine. The redistribution policy for MINPACK is available \u003ca href\u003d\"http://www.netlib.org/minpack/disclaimer\"\u003ehere\u003c/a\u003e, for convenience, it is reproduced below.\u003c/p\u003e \u003ctable border\u003d\"0\" width\u003d\"80%\" cellpadding\u003d\"10\" align\u003d\"center\" bgcolor\u003d\"#E0E0E0\"\u003e \u003ctr\u003e\u003ctd\u003e Minpack Copyright Notice (1999) University of Chicago. All rights reserved \u003c/td\u003e\u003c/tr\u003e \u003ctr\u003e\u003ctd\u003e Redistribution and use in source and binary forms, with or without modification, are permitted provided that the following conditions are met: \u003col\u003e \u003cli\u003eRedistributions of source code must retain the above copyright notice, this list of conditions and the following disclaimer.\u003c/li\u003e \u003cli\u003eRedistributions in binary form must reproduce the above copyright notice, this list of conditions and the following disclaimer in the documentation and/or other materials provided with the distribution.\u003c/li\u003e \u003cli\u003eThe end-user documentation included with the redistribution, if any, must include the following acknowledgment: {@code This product includes software developed by the University ofChicago, as Operator of Argonne National Laboratory.}Alternately, this acknowledgment may appear in the software itself, if and wherever such third-party acknowledgments normally appear.\u003c/li\u003e \u003cli\u003e\u003cstrong\u003eWARRANTY DISCLAIMER. THE SOFTWARE IS SUPPLIED \"AS IS\" WITHOUT WARRANTY OF ANY KIND. THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, AND THEIR EMPLOYEES: (1) DISCLAIM ANY WARRANTIES, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO ANY IMPLIED WARRANTIES OF MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE, TITLE OR NON-INFRINGEMENT, (2) DO NOT ASSUME ANY LEGAL LIABILITY OR RESPONSIBILITY FOR THE ACCURACY, COMPLETENESS, OR USEFULNESS OF THE SOFTWARE, (3) DO NOT REPRESENT THAT USE OF THE SOFTWARE WOULD NOT INFRINGE PRIVATELY OWNED RIGHTS, (4) DO NOT WARRANT THAT THE SOFTWARE WILL FUNCTION UNINTERRUPTED, THAT IT IS ERROR-FREE OR THAT ANY ERRORS WILL BE CORRECTED.\u003c/strong\u003e\u003c/li\u003e \u003cli\u003e\u003cstrong\u003eLIMITATION OF LIABILITY. IN NO EVENT WILL THE COPYRIGHT HOLDER, THE UNITED STATES, THE UNITED STATES DEPARTMENT OF ENERGY, OR THEIR EMPLOYEES: BE LIABLE FOR ANY INDIRECT, INCIDENTAL, CONSEQUENTIAL, SPECIAL OR PUNITIVE DAMAGES OF ANY KIND OR NATURE, INCLUDING BUT NOT LIMITED TO LOSS OF PROFITS OR LOSS OF DATA, FOR ANY REASON WHATSOEVER, WHETHER SUCH LIABILITY IS ASSERTED ON THE BASIS OF CONTRACT, TORT (INCLUDING NEGLIGENCE OR STRICT LIABILITY), OR OTHERWISE, EVEN IF ANY OF SAID PARTIES HAS BEEN WARNED OF THE POSSIBILITY OF SUCH LOSS OR DAMAGES.\u003c/strong\u003e\u003c/li\u003e \u003col\u003e\u003c/td\u003e\u003c/tr\u003e \u003c/table\u003e\n * @param v Vector of doubles.\n * @return the 2-norm of the vector.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.sortInPlace#653",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.sortInPlace(double[], double[])",
    "snippet": "public static void sortInPlace(double[] x,double[]... yList) throws DimensionMismatchException, NullArgumentException {\n  sortInPlace(x,OrderDirection.INCREASING,yList);\n}",
    "begin_line": 653,
    "end_line": 656,
    "comment": "/** \n * Sort an array in ascending order in place and perform the same reordering of entries on other arrays. For example, if {@code x \u003d [3, 1, 2], y \u003d [1, 2, 3]} and {@code z \u003d [0, 5, 7]}, then {@code sortInPlace(x, y, z)} will update {@code x} to {@code [1, 2, 3]}, {@code y} to {@code [2, 3, 1]} and {@code z} to {@code [5, 7, 0]}.\n * @param x Array to be sorted and used as a pattern for permutationof the other arrays.\n * @param yList Set of arrays whose permutations of entries will followthose performed on  {@code x}.\n * @throws DimensionMismatchException if any {@code y} is not the samesize as  {@code x}.\n * @throws NullArgumentException if {@code x} or any {@code y} is null.\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.sortInPlace#675",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.sortInPlace(double[], org.apache.commons.math3.util.MathArrays.OrderDirection, double[])",
    "snippet": "public static void sortInPlace(double[] x,final OrderDirection dir,double[]... yList) throws NullArgumentException, DimensionMismatchException {\n  if (x \u003d\u003d null) {\n    throw new NullArgumentException();\n  }\n  final int len\u003dx.length;\n  final List\u003cPair\u003cDouble,double[]\u003e\u003e list\u003dnew ArrayList\u003cPair\u003cDouble,double[]\u003e\u003e(len);\n  final int yListLen\u003dyList.length;\n  for (int i\u003d0; i \u003c len; i++) {\n    final double[] yValues\u003dnew double[yListLen];\n    for (int j\u003d0; j \u003c yListLen; j++) {\n      double[] y\u003dyList[j];\n      if (y \u003d\u003d null) {\n        throw new NullArgumentException();\n      }\n      if (y.length !\u003d len) {\n        throw new DimensionMismatchException(y.length,len);\n      }\n      yValues[j]\u003dy[i];\n    }\n    list.add(new Pair\u003cDouble,double[]\u003e(x[i],yValues));\n  }\n  final Comparator\u003cPair\u003cDouble,double[]\u003e\u003e comp\u003dnew Comparator\u003cPair\u003cDouble,double[]\u003e\u003e(){\n    public int compare(    Pair\u003cDouble,double[]\u003e o1,    Pair\u003cDouble,double[]\u003e o2){\n      int val;\nswitch (dir) {\ncase INCREASING:        val\u003do1.getKey().compareTo(o2.getKey());\n      break;\ncase DECREASING:    val\u003do2.getKey().compareTo(o1.getKey());\n  break;\ndefault:throw new MathInternalError();\n}\nreturn val;\n}\n}\n;\nCollections.sort(list,comp);\nfor (int i\u003d0; i \u003c len; i++) {\nfinal Pair\u003cDouble,double[]\u003e e\u003dlist.get(i);\nx[i]\u003de.getKey();\nfinal double[] yValues\u003de.getValue();\nfor (int j\u003d0; j \u003c yListLen; j++) {\nyList[j][i]\u003dyValues[j];\n}\n}\n}",
    "begin_line": 675,
    "end_line": 733,
    "comment": "/** \n * Sort an array in place and perform the same reordering of entries on other arrays.  This method works the same as the other {@link #sortInPlace(double[],double[][]) sortInPlace} method, butallows the order of the sort to be provided in the  {@code dir}parameter.\n * @param x Array to be sorted and used as a pattern for permutationof the other arrays.\n * @param dir Order direction.\n * @param yList Set of arrays whose permutations of entries will followthose performed on  {@code x}.\n * @throws DimensionMismatchException if any {@code y} is not the samesize as  {@code x}.\n * @throws NullArgumentException if {@code x} or any {@code y} is null\n * @since 3.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.compare#705",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.compare(org.apache.commons.math3.util.Pair\u003cjava.lang.Double,double[]\u003e, org.apache.commons.math3.util.Pair\u003cjava.lang.Double,double[]\u003e)",
    "snippet": "public int compare(Pair\u003cDouble,double[]\u003e o1,Pair\u003cDouble,double[]\u003e o2){\n  int val;\nswitch (dir) {\ncase INCREASING:    val\u003do1.getKey().compareTo(o2.getKey());\n  break;\ncase DECREASING:val\u003do2.getKey().compareTo(o1.getKey());\nbreak;\ndefault:throw new MathInternalError();\n}\nreturn val;\n}",
    "begin_line": 705,
    "end_line": 720,
    "comment": "",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.copyOf#741",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(int[])",
    "snippet": "public static int[] copyOf(int[] source){\n  return copyOf(source,source.length);\n}",
    "begin_line": 741,
    "end_line": 743,
    "comment": "/** \n * Creates a copy of the  {@code source} array.\n * @param source Array to be copied.\n * @return the copied array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.copyOf#751",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[])",
    "snippet": "public static double[] copyOf(double[] source){\n  return copyOf(source,source.length);\n}",
    "begin_line": 751,
    "end_line": 753,
    "comment": "/** \n * Creates a copy of the  {@code source} array.\n * @param source Array to be copied.\n * @return the copied array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.copyOf#764",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(int[], int)",
    "snippet": "public static int[] copyOf(int[] source,int len){\n  final int[] output\u003dnew int[len];\n  System.arraycopy(source,0,output,0,FastMath.min(len,source.length));\n  return output;\n}",
    "begin_line": 764,
    "end_line": 768,
    "comment": "/** \n * Creates a copy of the  {@code source} array.\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the sourcelength, the copy will be truncated, if larger it will padded with zeroes.\n * @return the copied array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.copyOf#779",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.copyOf(double[], int)",
    "snippet": "public static double[] copyOf(double[] source,int len){\n  final double[] output\u003dnew double[len];\n  System.arraycopy(source,0,output,0,FastMath.min(len,source.length));\n  return output;\n}",
    "begin_line": 779,
    "end_line": 783,
    "comment": "/** \n * Creates a copy of the  {@code source} array.\n * @param source Array to be copied.\n * @param len Number of entries to copy. If smaller then the sourcelength, the copy will be truncated, if larger it will padded with zeroes.\n * @return the copied array.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.linearCombination#802",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double[], double[])",
    "snippet": "public static double linearCombination(final double[] a,final double[] b) throws DimensionMismatchException {\n  final int len\u003da.length;\n  if (len !\u003d b.length) {\n    throw new DimensionMismatchException(len,b.length);\n  }\n  final double[] prodHigh\u003dnew double[len];\n  double prodLowSum\u003d0;\n  for (int i\u003d0; i \u003c len; i++) {\n    final double ai\u003da[i];\n    final double ca\u003dSPLIT_FACTOR * ai;\n    final double aHigh\u003dca - (ca - ai);\n    final double aLow\u003dai - aHigh;\n    final double bi\u003db[i];\n    final double cb\u003dSPLIT_FACTOR * bi;\n    final double bHigh\u003dcb - (cb - bi);\n    final double bLow\u003dbi - bHigh;\n    prodHigh[i]\u003dai * bi;\n    final double prodLow\u003daLow * bLow - (((prodHigh[i] - aHigh * bHigh) - aLow * bHigh) - aHigh * bLow);\n    prodLowSum+\u003dprodLow;\n  }\n  final double prodHighCur\u003dprodHigh[0];\n  double prodHighNext\u003dprodHigh[1];\n  double sHighPrev\u003dprodHighCur + prodHighNext;\n  double sPrime\u003dsHighPrev - prodHighNext;\n  double sLowSum\u003d(prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n  final int lenMinusOne\u003dlen - 1;\n  for (int i\u003d1; i \u003c lenMinusOne; i++) {\n    prodHighNext\u003dprodHigh[i + 1];\n    final double sHighCur\u003dsHighPrev + prodHighNext;\n    sPrime\u003dsHighCur - prodHighNext;\n    sLowSum+\u003d(prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n    sHighPrev\u003dsHighCur;\n  }\n  double result\u003dsHighPrev + (prodLowSum + sLowSum);\n  if (Double.isNaN(result)) {\n    result\u003d0;\n    for (int i\u003d0; i \u003c len; ++i) {\n      result+\u003da[i] * b[i];\n    }\n  }\n  return result;\n}",
    "begin_line": 802,
    "end_line": 858,
    "comment": "/** \n * Compute a linear combination accurately. This method computes the sum of the products \u003ccode\u003ea\u003csub\u003ei\u003c/sub\u003e b\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. \u003cbr/\u003e It is based on the 2005 paper \u003ca href\u003d\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi\u003d10.1.1.2.1547\"\u003e Accurate Sum and Dot Product\u003c/a\u003e by Takeshi Ogita, Siegfried M. Rump, and Shin\u0027ichi Oishi published in SIAM J. Sci. Comput.\n * @param a Factors.\n * @param b Factors.\n * @return \u003ccode\u003e\u0026Sigma;\u003csub\u003ei\u003c/sub\u003e a\u003csub\u003ei\u003c/sub\u003e b\u003csub\u003ei\u003c/sub\u003e\u003c/code\u003e.\n * @throws DimensionMismatchException if arrays dimensions don\u0027t match\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.linearCombination#881",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double, double, double, double)",
    "snippet": "public static double linearCombination(final double a1,final double b1,final double a2,final double b2){\n  final double ca1\u003dSPLIT_FACTOR * a1;\n  final double a1High\u003dca1 - (ca1 - a1);\n  final double a1Low\u003da1 - a1High;\n  final double cb1\u003dSPLIT_FACTOR * b1;\n  final double b1High\u003dcb1 - (cb1 - b1);\n  final double b1Low\u003db1 - b1High;\n  final double prod1High\u003da1 * b1;\n  final double prod1Low\u003da1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n  final double ca2\u003dSPLIT_FACTOR * a2;\n  final double a2High\u003dca2 - (ca2 - a2);\n  final double a2Low\u003da2 - a2High;\n  final double cb2\u003dSPLIT_FACTOR * b2;\n  final double b2High\u003dcb2 - (cb2 - b2);\n  final double b2Low\u003db2 - b2High;\n  final double prod2High\u003da2 * b2;\n  final double prod2Low\u003da2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n  final double s12High\u003dprod1High + prod2High;\n  final double s12Prime\u003ds12High - prod2High;\n  final double s12Low\u003d(prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n  double result\u003ds12High + (prod1Low + prod2Low + s12Low);\n  if (Double.isNaN(result)) {\n    result\u003da1 * b1 + a2 * b2;\n  }\n  return result;\n}",
    "begin_line": 881,
    "end_line": 935,
    "comment": "/** \n * Compute a linear combination accurately. \u003cp\u003e This method computes a\u003csub\u003e1\u003c/sub\u003e\u0026times;b\u003csub\u003e1\u003c/sub\u003e + a\u003csub\u003e2\u003c/sub\u003e\u0026times;b\u003csub\u003e2\u003c/sub\u003e to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It is based on the 2005 paper \u003ca href\u003d\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi\u003d10.1.1.2.1547\"\u003e Accurate Sum and Dot Product\u003c/a\u003e by Takeshi Ogita, Siegfried M. Rump, and Shin\u0027ichi Oishi published in SIAM J. Sci. Comput. \u003c/p\u003e\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @return a\u003csub\u003e1\u003c/sub\u003e\u0026times;b\u003csub\u003e1\u003c/sub\u003e +a\u003csub\u003e2\u003c/sub\u003e\u0026times;b\u003csub\u003e2\u003c/sub\u003e\n * @see #linearCombination(double,double,double,double,double,double)\n * @see #linearCombination(double,double,double,double,double,double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.linearCombination#960",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double, double, double, double, double, double)",
    "snippet": "public static double linearCombination(final double a1,final double b1,final double a2,final double b2,final double a3,final double b3){\n  final double ca1\u003dSPLIT_FACTOR * a1;\n  final double a1High\u003dca1 - (ca1 - a1);\n  final double a1Low\u003da1 - a1High;\n  final double cb1\u003dSPLIT_FACTOR * b1;\n  final double b1High\u003dcb1 - (cb1 - b1);\n  final double b1Low\u003db1 - b1High;\n  final double prod1High\u003da1 * b1;\n  final double prod1Low\u003da1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n  final double ca2\u003dSPLIT_FACTOR * a2;\n  final double a2High\u003dca2 - (ca2 - a2);\n  final double a2Low\u003da2 - a2High;\n  final double cb2\u003dSPLIT_FACTOR * b2;\n  final double b2High\u003dcb2 - (cb2 - b2);\n  final double b2Low\u003db2 - b2High;\n  final double prod2High\u003da2 * b2;\n  final double prod2Low\u003da2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n  final double ca3\u003dSPLIT_FACTOR * a3;\n  final double a3High\u003dca3 - (ca3 - a3);\n  final double a3Low\u003da3 - a3High;\n  final double cb3\u003dSPLIT_FACTOR * b3;\n  final double b3High\u003dcb3 - (cb3 - b3);\n  final double b3Low\u003db3 - b3High;\n  final double prod3High\u003da3 * b3;\n  final double prod3Low\u003da3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n  final double s12High\u003dprod1High + prod2High;\n  final double s12Prime\u003ds12High - prod2High;\n  final double s12Low\u003d(prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n  final double s123High\u003ds12High + prod3High;\n  final double s123Prime\u003ds123High - prod3High;\n  final double s123Low\u003d(prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n  double result\u003ds123High + (prod1Low + prod2Low + prod3Low+ s12Low+ s123Low);\n  if (Double.isNaN(result)) {\n    result\u003da1 * b1 + a2 * b2 + a3 * b3;\n  }\n  return result;\n}",
    "begin_line": 960,
    "end_line": 1032,
    "comment": "/** \n * Compute a linear combination accurately. \u003cp\u003e This method computes a\u003csub\u003e1\u003c/sub\u003e\u0026times;b\u003csub\u003e1\u003c/sub\u003e + a\u003csub\u003e2\u003c/sub\u003e\u0026times;b\u003csub\u003e2\u003c/sub\u003e + a\u003csub\u003e3\u003c/sub\u003e\u0026times;b\u003csub\u003e3\u003c/sub\u003e to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It is based on the 2005 paper \u003ca href\u003d\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi\u003d10.1.1.2.1547\"\u003e Accurate Sum and Dot Product\u003c/a\u003e by Takeshi Ogita, Siegfried M. Rump, and Shin\u0027ichi Oishi published in SIAM J. Sci. Comput. \u003c/p\u003e\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @param a3 first factor of the third term\n * @param b3 second factor of the third term\n * @return a\u003csub\u003e1\u003c/sub\u003e\u0026times;b\u003csub\u003e1\u003c/sub\u003e +a\u003csub\u003e2\u003c/sub\u003e\u0026times;b\u003csub\u003e2\u003c/sub\u003e + a\u003csub\u003e3\u003c/sub\u003e\u0026times;b\u003csub\u003e3\u003c/sub\u003e\n * @see #linearCombination(double,double,double,double)\n * @see #linearCombination(double,double,double,double,double,double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.linearCombination#1061",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.linearCombination(double, double, double, double, double, double, double, double)",
    "snippet": "public static double linearCombination(final double a1,final double b1,final double a2,final double b2,final double a3,final double b3,final double a4,final double b4){\n  final double ca1\u003dSPLIT_FACTOR * a1;\n  final double a1High\u003dca1 - (ca1 - a1);\n  final double a1Low\u003da1 - a1High;\n  final double cb1\u003dSPLIT_FACTOR * b1;\n  final double b1High\u003dcb1 - (cb1 - b1);\n  final double b1Low\u003db1 - b1High;\n  final double prod1High\u003da1 * b1;\n  final double prod1Low\u003da1Low * b1Low - (((prod1High - a1High * b1High) - a1Low * b1High) - a1High * b1Low);\n  final double ca2\u003dSPLIT_FACTOR * a2;\n  final double a2High\u003dca2 - (ca2 - a2);\n  final double a2Low\u003da2 - a2High;\n  final double cb2\u003dSPLIT_FACTOR * b2;\n  final double b2High\u003dcb2 - (cb2 - b2);\n  final double b2Low\u003db2 - b2High;\n  final double prod2High\u003da2 * b2;\n  final double prod2Low\u003da2Low * b2Low - (((prod2High - a2High * b2High) - a2Low * b2High) - a2High * b2Low);\n  final double ca3\u003dSPLIT_FACTOR * a3;\n  final double a3High\u003dca3 - (ca3 - a3);\n  final double a3Low\u003da3 - a3High;\n  final double cb3\u003dSPLIT_FACTOR * b3;\n  final double b3High\u003dcb3 - (cb3 - b3);\n  final double b3Low\u003db3 - b3High;\n  final double prod3High\u003da3 * b3;\n  final double prod3Low\u003da3Low * b3Low - (((prod3High - a3High * b3High) - a3Low * b3High) - a3High * b3Low);\n  final double ca4\u003dSPLIT_FACTOR * a4;\n  final double a4High\u003dca4 - (ca4 - a4);\n  final double a4Low\u003da4 - a4High;\n  final double cb4\u003dSPLIT_FACTOR * b4;\n  final double b4High\u003dcb4 - (cb4 - b4);\n  final double b4Low\u003db4 - b4High;\n  final double prod4High\u003da4 * b4;\n  final double prod4Low\u003da4Low * b4Low - (((prod4High - a4High * b4High) - a4Low * b4High) - a4High * b4Low);\n  final double s12High\u003dprod1High + prod2High;\n  final double s12Prime\u003ds12High - prod2High;\n  final double s12Low\u003d(prod2High - (s12High - s12Prime)) + (prod1High - s12Prime);\n  final double s123High\u003ds12High + prod3High;\n  final double s123Prime\u003ds123High - prod3High;\n  final double s123Low\u003d(prod3High - (s123High - s123Prime)) + (s12High - s123Prime);\n  final double s1234High\u003ds123High + prod4High;\n  final double s1234Prime\u003ds1234High - prod4High;\n  final double s1234Low\u003d(prod4High - (s1234High - s1234Prime)) + (s123High - s1234Prime);\n  double result\u003ds1234High + (prod1Low + prod2Low + prod3Low+ prod4Low+ s12Low+ s123Low+ s1234Low);\n  if (Double.isNaN(result)) {\n    result\u003da1 * b1 + a2 * b2 + a3 * b3 + a4 * b4;\n  }\n  return result;\n}",
    "begin_line": 1061,
    "end_line": 1151,
    "comment": "/** \n * Compute a linear combination accurately. \u003cp\u003e This method computes a\u003csub\u003e1\u003c/sub\u003e\u0026times;b\u003csub\u003e1\u003c/sub\u003e + a\u003csub\u003e2\u003c/sub\u003e\u0026times;b\u003csub\u003e2\u003c/sub\u003e + a\u003csub\u003e3\u003c/sub\u003e\u0026times;b\u003csub\u003e3\u003c/sub\u003e + a\u003csub\u003e4\u003c/sub\u003e\u0026times;b\u003csub\u003e4\u003c/sub\u003e to high accuracy. It does so by using specific multiplication and addition algorithms to preserve accuracy and reduce cancellation effects. It is based on the 2005 paper \u003ca href\u003d\"http://citeseerx.ist.psu.edu/viewdoc/summary?doi\u003d10.1.1.2.1547\"\u003e Accurate Sum and Dot Product\u003c/a\u003e by Takeshi Ogita, Siegfried M. Rump, and Shin\u0027ichi Oishi published in SIAM J. Sci. Comput. \u003c/p\u003e\n * @param a1 first factor of the first term\n * @param b1 second factor of the first term\n * @param a2 first factor of the second term\n * @param b2 second factor of the second term\n * @param a3 first factor of the third term\n * @param b3 second factor of the third term\n * @param a4 first factor of the third term\n * @param b4 second factor of the third term\n * @return a\u003csub\u003e1\u003c/sub\u003e\u0026times;b\u003csub\u003e1\u003c/sub\u003e +a\u003csub\u003e2\u003c/sub\u003e\u0026times;b\u003csub\u003e2\u003c/sub\u003e + a\u003csub\u003e3\u003c/sub\u003e\u0026times;b\u003csub\u003e3\u003c/sub\u003e + a\u003csub\u003e4\u003c/sub\u003e\u0026times;b\u003csub\u003e4\u003c/sub\u003e\n * @see #linearCombination(double,double,double,double)\n * @see #linearCombination(double,double,double,double,double,double)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.equals#1163",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.equals(float[], float[])",
    "snippet": "public static boolean equals(float[] x,float[] y){\n  if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n    return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n  }\n  if (x.length !\u003d y.length) {\n    return false;\n  }\n  for (int i\u003d0; i \u003c x.length; ++i) {\n    if (!Precision.equals(x[i],y[i])) {\n      return false;\n    }\n  }\n  return true;\n}",
    "begin_line": 1163,
    "end_line": 1176,
    "comment": "/** \n * Returns true iff both arguments are null or have same dimensions and all their elements are equal as defined by {@link Precision#equals(float,float)}.\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimensionand equal elements.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.equalsIncludingNaN#1189",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.equalsIncludingNaN(float[], float[])",
    "snippet": "public static boolean equalsIncludingNaN(float[] x,float[] y){\n  if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n    return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n  }\n  if (x.length !\u003d y.length) {\n    return false;\n  }\n  for (int i\u003d0; i \u003c x.length; ++i) {\n    if (!Precision.equalsIncludingNaN(x[i],y[i])) {\n      return false;\n    }\n  }\n  return true;\n}",
    "begin_line": 1189,
    "end_line": 1202,
    "comment": "/** \n * Returns true iff both arguments are null or have same dimensions and all their elements are equal as defined by {@link Precision#equalsIncludingNaN(double,double) this method}.\n * @param x first array\n * @param y second array\n * @return true if the values are both null or have same dimension andequal elements\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.equals#1214",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.equals(double[], double[])",
    "snippet": "public static boolean equals(double[] x,double[] y){\n  if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n    return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n  }\n  if (x.length !\u003d y.length) {\n    return false;\n  }\n  for (int i\u003d0; i \u003c x.length; ++i) {\n    if (!Precision.equals(x[i],y[i])) {\n      return false;\n    }\n  }\n  return true;\n}",
    "begin_line": 1214,
    "end_line": 1227,
    "comment": "/** \n * Returns  {@code true} iff both arguments are {@code null} or have samedimensions and all their elements are equal as defined by {@link Precision#equals(double,double)}.\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have samedimension and equal elements.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.equalsIncludingNaN#1240",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.equalsIncludingNaN(double[], double[])",
    "snippet": "public static boolean equalsIncludingNaN(double[] x,double[] y){\n  if ((x \u003d\u003d null) || (y \u003d\u003d null)) {\n    return !((x \u003d\u003d null) ^ (y \u003d\u003d null));\n  }\n  if (x.length !\u003d y.length) {\n    return false;\n  }\n  for (int i\u003d0; i \u003c x.length; ++i) {\n    if (!Precision.equalsIncludingNaN(x[i],y[i])) {\n      return false;\n    }\n  }\n  return true;\n}",
    "begin_line": 1240,
    "end_line": 1253,
    "comment": "/** \n * Returns  {@code true} iff both arguments are {@code null} or have samedimensions and all their elements are equal as defined by {@link Precision#equalsIncludingNaN(double,double) this method}.\n * @param x First array.\n * @param y Second array.\n * @return {@code true} if the values are both {@code null} or have samedimension and equal elements.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.normalizeArray#1277",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.normalizeArray(double[], double)",
    "snippet": "public static double[] normalizeArray(double[] values,double normalizedSum) throws MathIllegalArgumentException, MathArithmeticException {\n  if (Double.isInfinite(normalizedSum)) {\n    throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_INFINITE);\n  }\n  if (Double.isNaN(normalizedSum)) {\n    throw new MathIllegalArgumentException(LocalizedFormats.NORMALIZE_NAN);\n  }\n  double sum\u003d0d;\n  final int len\u003dvalues.length;\n  double[] out\u003dnew double[len];\n  for (int i\u003d0; i \u003c len; i++) {\n    if (Double.isInfinite(values[i])) {\n      throw new MathIllegalArgumentException(LocalizedFormats.INFINITE_ARRAY_ELEMENT,values[i],i);\n    }\n    if (!Double.isNaN(values[i])) {\n      sum+\u003dvalues[i];\n    }\n  }\n  if (sum \u003d\u003d 0) {\n    throw new MathArithmeticException(LocalizedFormats.ARRAY_SUMS_TO_ZERO);\n  }\n  for (int i\u003d0; i \u003c len; i++) {\n    if (Double.isNaN(values[i])) {\n      out[i]\u003dDouble.NaN;\n    }\n else {\n      out[i]\u003dvalues[i] * normalizedSum / sum;\n    }\n  }\n  return out;\n}",
    "begin_line": 1277,
    "end_line": 1307,
    "comment": "/** \n * Normalizes an array to make it sum to a specified value. Returns the result of the transformation \u003cpre\u003e x |-\u003e x * normalizedSum / sum \u003c/pre\u003e applied to each non-NaN element x of the input array, where sum is the sum of the non-NaN entries in the input array.\u003c/p\u003e \u003cp\u003eThrows IllegalArgumentException if  {@code normalizedSum} is infiniteor NaN and ArithmeticException if the input array contains any infinite elements or sums to 0.\u003c/p\u003e \u003cp\u003eIgnores (i.e., copies unchanged to the output array) NaNs in the input array.\u003c/p\u003e\n * @param values Input array to be normalized\n * @param normalizedSum Target sum for the normalized array\n * @return the normalized array.\n * @throws MathArithmeticException if the input array contains infiniteelements or sums to zero.\n * @throws MathIllegalArgumentException if the target sum is infinite or {@code NaN}.\n * @since 2.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.buildArray#1319",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.buildArray(org.apache.commons.math3.Field\u003cT\u003e, int)",
    "snippet": "public static \u003cT\u003eT[] buildArray(final Field\u003cT\u003e field,final int length){\n  @SuppressWarnings(\"unchecked\") T[] array\u003d(T[])Array.newInstance(field.getRuntimeClass(),length);\n  Arrays.fill(array,field.getZero());\n  return array;\n}",
    "begin_line": 1319,
    "end_line": 1324,
    "comment": "/** \n * Build an array of elements. \u003cp\u003e Arrays are filled with field.getZero() \u003c/p\u003e\n * @param \u003c T \u003e the type of the field elements\n * @param field field to which array elements belong\n * @param length of the array\n * @return a new array\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.buildArray#1339",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.buildArray(org.apache.commons.math3.Field\u003cT\u003e, int, int)",
    "snippet": "@SuppressWarnings(\"unchecked\") public static \u003cT\u003eT[][] buildArray(final Field\u003cT\u003e field,final int rows,final int columns){\n  final T[][] array;\n  if (columns \u003c 0) {\n    T[] dummyRow\u003dbuildArray(field,0);\n    array\u003d(T[][])Array.newInstance(dummyRow.getClass(),rows);\n  }\n else {\n    array\u003d(T[][])Array.newInstance(field.getRuntimeClass(),new int[]{rows,columns});\n    for (int i\u003d0; i \u003c rows; ++i) {\n      Arrays.fill(array[i],field.getZero());\n    }\n  }\n  return array;\n}",
    "begin_line": 1339,
    "end_line": 1354,
    "comment": "/** \n * Build a double dimension  array of elements. \u003cp\u003e Arrays are filled with field.getZero() \u003c/p\u003e\n * @param \u003c T \u003e the type of the field elements\n * @param field field to which array elements belong\n * @param rows number of rows in the array\n * @param columns number of columns (may be negative to build partialarrays in the same way \u003ccode\u003enew Field[rows][]\u003c/code\u003e works)\n * @return a new array\n * @since 3.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Function.convolve#1373",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/MathArrays.java",
    "class_name": "org.apache.commons.math3.util.MathArrays",
    "signature": "org.apache.commons.math3.util.MathArrays.convolve(double[], double[])",
    "snippet": "public static double[] convolve(double[] x,double[] h) throws NullArgumentException, NoDataException {\n  MathUtils.checkNotNull(x);\n  MathUtils.checkNotNull(h);\n  final int N\u003dx.length;\n  final int M\u003dh.length;\n  if (N \u003d\u003d 0 || M \u003d\u003d 0) {\n    throw new NoDataException();\n  }\n  final int totalLength\u003dN + M - 1;\n  final double[] y\u003dnew double[totalLength];\n  for (int n\u003d0; n \u003c totalLength; n++) {\n    double yn\u003d0;\n    for (int k\u003d0; k \u003c M; k++) {\n      final int j\u003dn - k;\n      if ((j \u003e -1) \u0026\u0026 (j \u003c N)) {\n        yn\u003dyn + x[j] * h[k];\n      }\n    }\n    y[n]\u003dyn;\n  }\n  return y;\n}",
    "begin_line": 1373,
    "end_line": 1401,
    "comment": "/** \n * Calculates the convolution between two sequences. \u003cp\u003e The solution is obtained via straightforward computation of the convolution sum (and not via FFT; for longer sequences, the performance of this method might be inferior to an FFT-based implementation).\n * @param x the first sequence (double array of length {@code N}); the sequence is assumed to be zero elsewhere (i.e. {x[i]}\u003d0 for i\u003c0 and i\u003e\u003d {@code N}). Typically, this sequence will represent an input signal to a system.\n * @param h the second sequence (double array of length {@code M}); the sequence is assumed to be zero elsewhere (i.e. {h[i]}\u003d0 for i\u003c0 and i\u003e\u003d {@code M}). Typically, this sequence will represent the impulse response of the system.\n * @return the convolution of {@code x} and {@code h} (double array of length {@code N} + {@code M} -1)\n * @throws NullArgumentException if either {@code x} or {@code h} is null\n * @throws NoDataException if either {@code x} or {@code h} is empty\n * @see \u003ca href\u003d\"http://en.wikipedia.org/wiki/Convolution\"\u003eConvolution (Wikipedia)\u003c/a\u003e\n * @since 4.0\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.Precision#83",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.Precision()",
    "snippet": "private Precision(){\n}",
    "begin_line": 83,
    "end_line": 83,
    "comment": "/** \n * Private constructor.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.compareTo#95",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.compareTo(double, double, double)",
    "snippet": "public static int compareTo(double x,double y,double eps){\n  if (equals(x,y,eps)) {\n    return 0;\n  }\n else   if (x \u003c y) {\n    return -1;\n  }\n  return 1;\n}",
    "begin_line": 95,
    "end_line": 102,
    "comment": "/** \n * Compares two numbers given some amount of allowed error.\n * @param x the first number\n * @param y the second number\n * @param eps the amount of error to allow when checking for equality\n * @return \u003cul\u003e\u003cli\u003e0 if  {@link #equals(double,double,double) equals(x, y, eps)}\u003c/li\u003e \u003cli\u003e\u0026lt; 0 if ! {@link #equals(double,double,double) equals(x, y, eps)} \u0026amp;\u0026amp; x \u0026lt; y\u003c/li\u003e\u003cli\u003e\u003e 0 if ! {@link #equals(double,double,double) equals(x, y, eps)} \u0026amp;\u0026amp; x \u003e y\u003c/li\u003e\u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.compareTo#121",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.compareTo(double, double, int)",
    "snippet": "public static int compareTo(final double x,final double y,final int maxUlps){\n  if (equals(x,y,maxUlps)) {\n    return 0;\n  }\n else   if (x \u003c y) {\n    return -1;\n  }\n  return 1;\n}",
    "begin_line": 121,
    "end_line": 128,
    "comment": "/** \n * Compares two numbers given some amount of allowed error. Two float numbers are considered equal if there are  {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from \u003ca href\u003d\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"\u003e Bruce Dawson\u003c/a\u003e\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return \u003cul\u003e\u003cli\u003e0 if  {@link #equals(double,double,int) equals(x, y, maxUlps)}\u003c/li\u003e \u003cli\u003e\u0026lt; 0 if ! {@link #equals(double,double,int) equals(x, y, maxUlps)} \u0026amp;\u0026amp; x \u0026lt; y\u003c/li\u003e\u003cli\u003e\u003e 0 if ! {@link #equals(double,double,int) equals(x, y, maxUlps)} \u0026amp;\u0026amp; x \u003e y\u003c/li\u003e\u003c/ul\u003e\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equals#138",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(float, float)",
    "snippet": "public static boolean equals(float x,float y){\n  return equals(x,y,1);\n}",
    "begin_line": 138,
    "end_line": 140,
    "comment": "/** \n * Returns true iff they are equal as defined by {@link #equals(float,float,int) equals(x, y, 1)}.\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsIncludingNaN#151",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsIncludingNaN(float, float)",
    "snippet": "public static boolean equalsIncludingNaN(float x,float y){\n  return (Float.isNaN(x) \u0026\u0026 Float.isNaN(y)) || equals(x,y,1);\n}",
    "begin_line": 151,
    "end_line": 153,
    "comment": "/** \n * Returns true if both arguments are NaN or neither is NaN and they are equal as defined by  {@link #equals(float,float) equals(x, y, 1)}.\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equals#165",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(float, float, float)",
    "snippet": "public static boolean equals(float x,float y,float eps){\n  return equals(x,y,1) || FastMath.abs(y - x) \u003c\u003d eps;\n}",
    "begin_line": 165,
    "end_line": 167,
    "comment": "/** \n * Returns true if both arguments are equal or within the range of allowed error (inclusive).\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsIncludingNaN#180",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsIncludingNaN(float, float, float)",
    "snippet": "public static boolean equalsIncludingNaN(float x,float y,float eps){\n  return equalsIncludingNaN(x,y) || (FastMath.abs(y - x) \u003c\u003d eps);\n}",
    "begin_line": 180,
    "end_line": 182,
    "comment": "/** \n * Returns true if both arguments are NaN or are equal or within the range of allowed error (inclusive).\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,or both are NaN.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equals#202",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(float, float, int)",
    "snippet": "public static boolean equals(float x,float y,int maxUlps){\n  int xInt\u003dFloat.floatToIntBits(x);\n  int yInt\u003dFloat.floatToIntBits(y);\n  if (xInt \u003c 0) {\n    xInt\u003dSGN_MASK_FLOAT - xInt;\n  }\n  if (yInt \u003c 0) {\n    yInt\u003dSGN_MASK_FLOAT - yInt;\n  }\n  final boolean isEqual\u003dFastMath.abs(xInt - yInt) \u003c\u003d maxUlps;\n  return isEqual \u0026\u0026 !Float.isNaN(x) \u0026\u0026 !Float.isNaN(y);\n}",
    "begin_line": 202,
    "end_line": 217,
    "comment": "/** \n * Returns true if both arguments are equal or within the range of allowed error (inclusive). Two float numbers are considered equal if there are  {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from \u003ca href\u003d\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"\u003e Bruce Dawson\u003c/a\u003e\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floatingpoint values between  {@code x} and {@code y}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsIncludingNaN#231",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsIncludingNaN(float, float, int)",
    "snippet": "public static boolean equalsIncludingNaN(float x,float y,int maxUlps){\n  return (Float.isNaN(x) \u0026\u0026 Float.isNaN(y)) || equals(x,y,maxUlps);\n}",
    "begin_line": 231,
    "end_line": 233,
    "comment": "/** \n * Returns true if both arguments are NaN or if they are equal as defined by  {@link #equals(float,float,int) equals(x, y, maxUlps)}.\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than{@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equals#243",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double, double)",
    "snippet": "public static boolean equals(double x,double y){\n  return equals(x,y,1);\n}",
    "begin_line": 243,
    "end_line": 245,
    "comment": "/** \n * Returns true iff they are equal as defined by {@link #equals(double,double,int) equals(x, y, 1)}.\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsIncludingNaN#256",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsIncludingNaN(double, double)",
    "snippet": "public static boolean equalsIncludingNaN(double x,double y){\n  return (Double.isNaN(x) \u0026\u0026 Double.isNaN(y)) || equals(x,y,1);\n}",
    "begin_line": 256,
    "end_line": 258,
    "comment": "/** \n * Returns true if both arguments are NaN or neither is NaN and they are equal as defined by  {@link #equals(double,double) equals(x, y, 1)}.\n * @param x first value\n * @param y second value\n * @return {@code true} if the values are equal or both are NaN.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equals#271",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double, double, double)",
    "snippet": "public static boolean equals(double x,double y,double eps){\n  return equals(x,y,1) || FastMath.abs(y - x) \u003c\u003d eps;\n}",
    "begin_line": 271,
    "end_line": 273,
    "comment": "/** \n * Returns  {@code true} if there is no double value strictly between thearguments or the difference between them is within the range of allowed error (inclusive).\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed absolute error.\n * @return {@code true} if the values are two adjacent floating pointnumbers or they are within range of each other.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsWithRelativeTolerance#287",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsWithRelativeTolerance(double, double, double)",
    "snippet": "public static boolean equalsWithRelativeTolerance(double x,double y,double eps){\n  if (equals(x,y,1)) {\n    return true;\n  }\n  final double absoluteMax\u003dFastMath.max(FastMath.abs(x),FastMath.abs(y));\n  final double relativeDifference\u003dFastMath.abs((x - y) / absoluteMax);\n  return relativeDifference \u003c\u003d eps;\n}",
    "begin_line": 287,
    "end_line": 296,
    "comment": "/** \n * Returns  {@code true} if there is no double value strictly between thearguments or the reltaive difference between them is smaller or equal to the given tolerance.\n * @param x First value.\n * @param y Second value.\n * @param eps Amount of allowed relative error.\n * @return {@code true} if the values are two adjacent floating pointnumbers or they are within range of each other.\n * @since 3.1\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsIncludingNaN#309",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsIncludingNaN(double, double, double)",
    "snippet": "public static boolean equalsIncludingNaN(double x,double y,double eps){\n  return equalsIncludingNaN(x,y) || (FastMath.abs(y - x) \u003c\u003d eps);\n}",
    "begin_line": 309,
    "end_line": 311,
    "comment": "/** \n * Returns true if both arguments are NaN or are equal or within the range of allowed error (inclusive).\n * @param x first value\n * @param y second value\n * @param eps the amount of absolute error to allow.\n * @return {@code true} if the values are equal or within range of each other,or both are NaN.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equals#330",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equals(double, double, int)",
    "snippet": "public static boolean equals(double x,double y,int maxUlps){\n  long xInt\u003dDouble.doubleToLongBits(x);\n  long yInt\u003dDouble.doubleToLongBits(y);\n  if (xInt \u003c 0) {\n    xInt\u003dSGN_MASK - xInt;\n  }\n  if (yInt \u003c 0) {\n    yInt\u003dSGN_MASK - yInt;\n  }\n  final boolean isEqual\u003dFastMath.abs(xInt - yInt) \u003c\u003d maxUlps;\n  return isEqual \u0026\u0026 !Double.isNaN(x) \u0026\u0026 !Double.isNaN(y);\n}",
    "begin_line": 330,
    "end_line": 345,
    "comment": "/** \n * Returns true if both arguments are equal or within the range of allowed error (inclusive). Two float numbers are considered equal if there are  {@code (maxUlps - 1)}(or fewer) floating point numbers between them, i.e. two adjacent floating point numbers are considered equal. Adapted from \u003ca href\u003d\"http://www.cygnus-software.com/papers/comparingfloats/comparingfloats.htm\"\u003e Bruce Dawson\u003c/a\u003e\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if there are fewer than {@code maxUlps} floatingpoint values between  {@code x} and {@code y}.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.equalsIncludingNaN#359",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.equalsIncludingNaN(double, double, int)",
    "snippet": "public static boolean equalsIncludingNaN(double x,double y,int maxUlps){\n  return (Double.isNaN(x) \u0026\u0026 Double.isNaN(y)) || equals(x,y,maxUlps);\n}",
    "begin_line": 359,
    "end_line": 361,
    "comment": "/** \n * Returns true if both arguments are NaN or if they are equal as defined by  {@link #equals(double,double,int) equals(x, y, maxUlps)}.\n * @param x first value\n * @param y second value\n * @param maxUlps {@code (maxUlps - 1)} is the number of floating pointvalues between  {@code x} and {@code y}.\n * @return {@code true} if both arguments are NaN or if there are less than{@code maxUlps} floating point values between {@code x} and {@code y}.\n * @since 2.2\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.round#372",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.round(double, int)",
    "snippet": "public static double round(double x,int scale){\n  return round(x,scale,BigDecimal.ROUND_HALF_UP);\n}",
    "begin_line": 372,
    "end_line": 374,
    "comment": "/** \n * Rounds the given value to the specified number of decimal places. The value is rounded using the  {@link BigDecimal#ROUND_HALF_UP} method.\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.round#393",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.round(double, int, int)",
    "snippet": "public static double round(double x,int scale,int roundingMethod){\n  try {\n    return (new BigDecimal(Double.toString(x)).setScale(scale,roundingMethod)).doubleValue();\n  }\n catch (  NumberFormatException ex) {\n    if (Double.isInfinite(x)) {\n      return x;\n    }\n else {\n      return Double.NaN;\n    }\n  }\n}",
    "begin_line": 393,
    "end_line": 406,
    "comment": "/** \n * Rounds the given value to the specified number of decimal places. The value is rounded using the given method which is any method defined in  {@link BigDecimal}. If  {@code x} is infinite or {@code NaN}, then the value of  {@code x} isreturned unchanged, regardless of the other parameters.\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws ArithmeticException if {@code roundingMethod \u003d\u003d ROUND_UNNECESSARY}and the specified scaling operation would require rounding.\n * @throws IllegalArgumentException if {@code roundingMethod} does notrepresent a valid rounding mode.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.round#417",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.round(float, int)",
    "snippet": "public static float round(float x,int scale){\n  return round(x,scale,BigDecimal.ROUND_HALF_UP);\n}",
    "begin_line": 417,
    "end_line": 419,
    "comment": "/** \n * Rounds the given value to the specified number of decimal places. The value is rounded using the  {@link BigDecimal#ROUND_HALF_UP} method.\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.round#434",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.round(float, int, int)",
    "snippet": "public static float round(float x,int scale,int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException {\n  final float sign\u003dFastMath.copySign(1f,x);\n  final float factor\u003d(float)FastMath.pow(10.0f,scale) * sign;\n  return (float)roundUnscaled(x * factor,sign,roundingMethod) / factor;\n}",
    "begin_line": 434,
    "end_line": 439,
    "comment": "/** \n * Rounds the given value to the specified number of decimal places. The value is rounded using the given method which is any method defined in  {@link BigDecimal}.\n * @param x Value to round.\n * @param scale Number of digits to the right of the decimal point.\n * @param roundingMethod Rounding method as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n * @throws MathArithmeticException if an exact operation is required but result is not exact\n * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.roundUnscaled#454",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.roundUnscaled(double, double, int)",
    "snippet": "private static double roundUnscaled(double unscaled,double sign,int roundingMethod) throws MathArithmeticException, MathIllegalArgumentException {\nswitch (roundingMethod) {\ncase BigDecimal.ROUND_CEILING:    if (sign \u003d\u003d -1) {\n      unscaled\u003dFastMath.floor(FastMath.nextAfter(unscaled,Double.NEGATIVE_INFINITY));\n    }\n else {\n      unscaled\u003dFastMath.ceil(FastMath.nextAfter(unscaled,Double.POSITIVE_INFINITY));\n    }\n  break;\ncase BigDecimal.ROUND_DOWN:unscaled\u003dFastMath.floor(FastMath.nextAfter(unscaled,Double.NEGATIVE_INFINITY));\nbreak;\ncase BigDecimal.ROUND_FLOOR:if (sign \u003d\u003d -1) {\nunscaled\u003dFastMath.ceil(FastMath.nextAfter(unscaled,Double.POSITIVE_INFINITY));\n}\n else {\nunscaled\u003dFastMath.floor(FastMath.nextAfter(unscaled,Double.NEGATIVE_INFINITY));\n}\nbreak;\ncase BigDecimal.ROUND_HALF_DOWN:{\nunscaled\u003dFastMath.nextAfter(unscaled,Double.NEGATIVE_INFINITY);\ndouble fraction\u003dunscaled - FastMath.floor(unscaled);\nif (fraction \u003e 0.5) {\nunscaled\u003dFastMath.ceil(unscaled);\n}\n else {\nunscaled\u003dFastMath.floor(unscaled);\n}\nbreak;\n}\ncase BigDecimal.ROUND_HALF_EVEN:{\ndouble fraction\u003dunscaled - FastMath.floor(unscaled);\nif (fraction \u003e 0.5) {\nunscaled\u003dFastMath.ceil(unscaled);\n}\n else if (fraction \u003c 0.5) {\nunscaled\u003dFastMath.floor(unscaled);\n}\n else {\nif (FastMath.floor(unscaled) / 2.0 \u003d\u003d FastMath.floor(Math.floor(unscaled) / 2.0)) {\nunscaled\u003dFastMath.floor(unscaled);\n}\n else {\nunscaled\u003dFastMath.ceil(unscaled);\n}\n}\nbreak;\n}\ncase BigDecimal.ROUND_HALF_UP:{\nunscaled\u003dFastMath.nextAfter(unscaled,Double.POSITIVE_INFINITY);\ndouble fraction\u003dunscaled - FastMath.floor(unscaled);\nif (fraction \u003e\u003d 0.5) {\nunscaled\u003dFastMath.ceil(unscaled);\n}\n else {\nunscaled\u003dFastMath.floor(unscaled);\n}\nbreak;\n}\ncase BigDecimal.ROUND_UNNECESSARY:if (unscaled !\u003d FastMath.floor(unscaled)) {\nthrow new MathArithmeticException();\n}\nbreak;\ncase BigDecimal.ROUND_UP:unscaled\u003dFastMath.ceil(FastMath.nextAfter(unscaled,Double.POSITIVE_INFINITY));\nbreak;\ndefault:throw new MathIllegalArgumentException(LocalizedFormats.INVALID_ROUNDING_METHOD,roundingMethod,\"ROUND_CEILING\",BigDecimal.ROUND_CEILING,\"ROUND_DOWN\",BigDecimal.ROUND_DOWN,\"ROUND_FLOOR\",BigDecimal.ROUND_FLOOR,\"ROUND_HALF_DOWN\",BigDecimal.ROUND_HALF_DOWN,\"ROUND_HALF_EVEN\",BigDecimal.ROUND_HALF_EVEN,\"ROUND_HALF_UP\",BigDecimal.ROUND_HALF_UP,\"ROUND_UNNECESSARY\",BigDecimal.ROUND_UNNECESSARY,\"ROUND_UP\",BigDecimal.ROUND_UP);\n}\nreturn unscaled;\n}",
    "begin_line": 454,
    "end_line": 534,
    "comment": "/** \n * Rounds the given non-negative value to the \"nearest\" integer. Nearest is determined by the rounding method specified. Rounding methods are defined in  {@link BigDecimal}.\n * @param unscaled Value to round.\n * @param sign Sign of the original, scaled value.\n * @param roundingMethod Rounding method, as defined in {@link BigDecimal}.\n * @return the rounded value.\n * @throws MathArithmeticException if an exact operation is required but result is not exact\n * @throws MathIllegalArgumentException if {@code roundingMethod} is not a valid rounding method.\n * @since 1.1 (previously in {@code MathUtils}, moved as of version 3.0)\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  },
  {
    "name": "Precision.representableDelta#551",
    "is_bug": true,
    "src_path": "org/apache/commons/math3/util/Precision.java",
    "class_name": "org.apache.commons.math3.util.Precision",
    "signature": "org.apache.commons.math3.util.Precision.representableDelta(double, double)",
    "snippet": "public static double representableDelta(double x,double originalDelta){\n  return x + originalDelta - x;\n}",
    "begin_line": 551,
    "end_line": 554,
    "comment": "/** \n * Computes a number  {@code delta} close to {@code originalDelta} withthe property that \u003cpre\u003e\u003ccode\u003e x + delta - x \u003c/code\u003e\u003c/pre\u003e is exactly machine-representable. This is useful when computing numerical derivatives, in order to reduce roundoff errors.\n * @param x Value.\n * @param originalDelta Offset value.\n * @return a number {@code delta} so that {@code x + delta} and {@code x}differ by a representable floating number.\n */\n",
    "resolved_comments": {},
    "susp": {
      "ochiai_susp": 0.5
    },
    "num_failing_tests": 0
  }
]